import SwiftUI
import MapKit

struct AboutView: View {
    @Binding var refreshMetadata: Bool
    @EnvironmentObject var appRegionViewModel: AppRegionViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    @Environment(\.presentationMode) var presentationMode
    
    @State private var showLinks = false
    @State private var showFlySkyHyLink = false
    @State private var showDevRegions = false
    
    var body: some View {
        NavigationView {
            VStack(alignment: .leading) {
                HStack {
                    Button(action: {
                        presentationMode.wrappedValue.dismiss()
                    }) {
                        HStack {
                            Image(systemName: "chevron.left")
                                .foregroundColor(toolbarActiveImageColor)
                            Text("Back")
                                .foregroundColor(toolbarActiveFontColor)
                        }
                    }
                    Spacer()
                }
                .padding()
                .background(toolbarBackgroundColor)
                
                List {
                    
                    Section(header: Text("Region Select")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        // Do not show "Development" status regions unless user has set showDevRegions
                        ForEach(appRegionViewModel.appRegions.filter {
                            showDevRegions || $0.appRegionStatus.isEmpty
                        }, id: \.appRegion) { region in
                            Button(action: {
                                RegionManager.shared.activeAppRegion = region.appRegion
                                userSettingsViewModel.mapRegion = MKCoordinateRegion(
                                    center: CLLocationCoordinate2D(
                                        latitude: region.mapInitLatitude,
                                        longitude: region.mapInitLongitude
                                    ),
                                    span: MKCoordinateSpan(
                                        latitudeDelta: region.mapInitLatitudeSpan,
                                        longitudeDelta: region.mapInitLongitudeSpan
                                    )
                                )
                                userSettingsViewModel.zoomLevel = region.mapDefaultZoomLevel
                                userSettingsViewModel.saveToStorage()

                                // Defer metadata refresh to allow onChange to fire properly
                                DispatchQueue.main.async {
                                    refreshMetadata = true
                                }
                            }) {
                                HStack {
                                    if region.appRegionStatus.isEmpty {
                                        Text(region.appRegionName)
                                            .font(.subheadline)
                                            .foregroundColor(toolbarActiveFontColor)
                                    } else {
                                        Text("\(region.appRegionName) (\(region.appRegionStatus))")
                                            .font(.subheadline)
                                            .foregroundColor(infoFontColor)
                                    }
                                    Spacer()
                                    if RegionManager.shared.activeAppRegion == region.appRegion {
                                        Image(systemName: "checkmark")
                                            .font(.subheadline)
                                            .foregroundColor(toolbarActiveImageColor)
                                    }
                                }
                            }
                            .contentShape(Rectangle())
                        }
                    }
                    
                    Section(header: Text("Additional Resources")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        // Custom FlySkyHy airspace file
                        Button(action: {
                            showFlySkyHyLink = true
                        }) {
                            Text("FlySkyHy custom data")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }

                        // Links
                        Button(action: {
                            showLinks = true
                        }) {
                            Text("Links")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }
                        
                    }
                    
                    Section(header: Text("About Cloudbase Project")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        
                        // Join Telegram group
                        Button(action: {
                            if let url = URL(string: cloudbaseProjectTelegramLink) {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            Text("Telegram group")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }
                        
                        // Contact via email
                        Button(action: {
                            if let url = URL(string: "mailto:\(cloudbaseProjectEmail)") {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            Text("Contact via email")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }

                        // Github repo
                        Button(action: {
                            if let url = URL(string: cloudbaseProjectGitLink) {
                                UIApplication.shared.open(url)
                            }
                        }) {
                            Text("Github repository")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }
                    }
                    
                    Section(header: Text("Application setup")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        
                        Button(action: {
                            
                            // Force reload app (e.g., metadata changes)
                            refreshMetadata = true

                        }) {
                            Text("Reload metadata")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }
                        
                        // Reset to defaults (clear user settings)
                        Button(action: {
                            userSettingsViewModel.clearUserSettings() {
                                
                                // Reset active app region
                                RegionManager.shared.activeAppRegion = ""

                                // Trigger a change to appRefreshID to reload metadata by making BaseAppView reappear
                                refreshMetadata = true
                                
                            }
                        }) {
                            Text("Clear user settings (reset to defaults)")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        }
                        
                        // Allow user to pick app regions that in development
                        Toggle("Enable regions in development", isOn: $showDevRegions)
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                        
                    }
                    
                    if devMenuAvailable {
                        
                        Section(header: Text("Development Tools")
                            .font(.subheadline)
                            .foregroundColor(sectionHeaderColor)
                            .bold())
                        {
                            
                            // Inactive pilots
                            NavigationLink(destination: DevInactivePilotsView()) {
                                Text("Manage inactive pilots")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                            
                            // Pilots and tracks
                            NavigationLink(destination: DevPilotTracksView()) {
                                Text("Pilots tracks")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                            
                            // Site coordinates map
                            NavigationLink(destination: DevSiteCoordView()) {
                                Text("Site coordinates updates")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                            
                            // UDOT camera map
                            NavigationLink(destination: UDOTCameraListView()) {
                                Text("UDOT cameras map")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                            
                            // Temporary development view
                            NavigationLink(destination: DevTempView()) {
                                Text("Temp View")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                            
                        }
                    }
                }
            }
        }
        
        .sheet(isPresented: $showFlySkyHyLink, onDismiss: {})
        {
            FlySkyHyDataView()
                .interactiveDismissDisabled(true)
        }
        
        .sheet(isPresented: $showLinks, onDismiss: {})
        {
            LinkView()
                .interactiveDismissDisabled(true)
        }

    }
}
import SwiftUI
import Combine

struct SiteDailyForecastView: View {
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @ObservedObject var weatherCodesViewModel: WeatherCodeViewModel
    @StateObject private var viewModel: DailyForecastViewModel
    
    var siteLat: String
    var siteLon: String
    var forecastNote: String
    var siteName: String
    var siteType: String
    
    init(weatherCodesViewModel: WeatherCodeViewModel, siteLat: String, siteLon: String, forecastNote: String, siteName: String, siteType: String) {
        self._weatherCodesViewModel = ObservedObject(wrappedValue: weatherCodesViewModel)
        self._viewModel = StateObject(wrappedValue: DailyForecastViewModel(weatherCodesViewModel: weatherCodesViewModel))
        self.siteLat = siteLat
        self.siteLon = siteLon
        self.forecastNote = forecastNote
        self.siteName = siteName
        self.siteType = siteType
    }

    var body: some View {
        VStack {
            let dataWidth: CGFloat = 40                                     // Width for each data column
            let dataFrameWidth: CGFloat = ( dataWidth * 1.5 )
            
            if let daily = viewModel.dailyForecastData?.daily {

                let surfaceAltitude = convertMetersToFeet(viewModel.dailyForecastData?.elevation ?? 0.0)
                HStack {
                    Text(buildReferenceNote(Alt: String(surfaceAltitude), Note: forecastNote))
                        .font(.footnote)
                        .foregroundColor(infoFontColor)
                        .padding(.bottom, 5)
                    Spacer()
                }
                ScrollView(.horizontal) {
                    HStack (alignment: .top, spacing: 4) {
                        ForEach(0..<daily.time.count, id: \.self) { index in
                            VStack (spacing: 0) {
                                Text(daily.forecastDay?[index] ?? "")
                                    .font(.caption)
                                    .foregroundColor(repeatDateTimeColor)
                                    .frame(height: headingHeight)
                                    .padding(.top, 6)
                                Text(daily.forecastDate?[index] ?? "")
                                    .font(.caption)
                                    .foregroundColor(repeatDateTimeColor)
                                    .frame(height: headingHeight)
                                Image(systemName: daily.weatherCodeImage?[index] ?? "questionmark")
                                    .renderingMode(.original) // Use .multicolor for multicolor rendering
                                    .resizable()
                                    .scaledToFit()
                                    .frame(width: dataWidth * imageScalingFactor, height: imageHeight)
                                // let minTempColor = tempColor(Int(daily.temperature_2m_min[index].rounded()))
                                let maxTempColor = tempColor(Int(daily.temperature_2m_max[index].rounded()))
                                HStack  (spacing: 0) {
                                    /*  Skipping min temp in display
                                     Text(daily.formattedMinTemp?[index] ?? "")
                                     .foregroundStyle(minTempColor)
                                     .font(.caption)
                                     Text("/")
                                     .font(.caption)
                                     */
                                    Text(daily.formattedMaxTemp?[index] ?? "")
                                        .foregroundStyle(maxTempColor)
                                        .font(.caption)
                                    Text("°")
                                        .font(.caption)
                                }
                                .frame(height: dataHeight)
                                let windColor = windSpeedColor(windSpeed: Int(daily.wind_speed_10m_mean[index].rounded()), siteType: siteType)
                                // let gustColor = windSpeedColor(windSpeed: Int(daily.wind_gusts_10m_max[index].rounded()), siteType: siteType)
                                Group {
                                    HStack(spacing: windArrowSpacing) {
                                        VStack(alignment: .trailing, spacing: 1) {
                                            Text("\(Int(daily.wind_speed_10m_mean[index].rounded()))")
                                                .font(.caption)
                                                .foregroundStyle(windColor)
                                            /*  Removing gust from display
                                             HStack (spacing: 1) {
                                             Text("g")
                                             .font(.caption2)
                                             Text("\(Int(daily.wind_gusts_10m_max[index].rounded()))")
                                             .font(.caption)
                                             .foregroundStyle(gustColor)
                                             }
                                             */
                                        }
                                        Image(systemName: windArrow)
                                            .rotationEffect(.degrees(Double(Int(daily.wind_direction_10m_dominant[index]) - 180)))
                                            .font(.footnote)
                                    }
                                    .frame(height: dataHeight) // adjusted for removing gust doubleHeight)
                                }
                                VStack (spacing: 0) {
                                    if daily.precipitation_sum[index] > 0 || daily.precipitation_probability_max[index] > 0 {
                                        HStack (spacing: 0) {
                                            Image(systemName: daily.precipImage?[index] ?? "questionmark")
                                                .font(.caption2)
                                                .imageScale(.small)
                                                .foregroundStyle(.titanium)
                                            Text(" \(String(daily.precipitation_probability_max[index]))%")
                                                .font(.caption)
                                        }
                                        let roundedPrecip = (daily.precipitation_sum[index] * 10).rounded() / 10
                                        Text("\(String(roundedPrecip))\"")
                                            .font(.caption)
                                            .padding(.bottom, 6)
                                    } else {
                                        Text("")
                                        Text("")
                                            .padding(.bottom, 6)
                                    }
                                }
                                .frame(height: doubleHeight)
                            }
                            .frame(width: dataFrameWidth)
                            .background(tableBackgroundColor)
                            .cornerRadius(10)
                            .padding(.horizontal, 2)
                        }
                    }
                }
            }
            else {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(0.75)
                    .frame(width: 20, height: 20)
            }
        }
        .onAppear {
            viewModel.fetchDailyWeatherData(latitude: siteLat,
                                            longitude: siteLon)
        }
    }
}
import SwiftUI

struct PilotActivateView: View {
    var pilot: Pilot
    
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel

    @State private var statusMessage = ""
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                        Spacer()
                    }
                }
                .padding()
                Spacer()
                Text(pilot.pilotName)
                    .foregroundColor(sectionHeaderColor)
                    .bold()
            }
            .padding()
            .background(toolbarBackgroundColor)
            
            List {
                
                Section(header: Text("Inactive Pilots")) {
                    
                    VStack (alignment: .leading) {
                        
                        Text("To reduce time loading tracks, pilots are periodically deactivated in this app when they have empty track feeds.")
                            .font(.subheadline)
                        Text("This occurs when either:")
                            .font(.subheadline)
                        Text(" - The inReach has not be used for a year")
                            .font(.subheadline)
                        Text(" - The inReach share is currently set to private")
                            .font(.subheadline)
                        Text("")
                            .font(.subheadline)
                        Text("If the inReach is now being used and share is set to public, use the button below to re-activate a pilot in this app")
                            .font(.subheadline)
                        
                        HStack {
                            Spacer()
                            Button(action: {
                                
                                // Update Google sheets to activate pilot
                                pilotViewModel.setPilotActiveStatus(pilot: pilot,
                                                                    isInactive: false)

                                // Force update to pilot listing
                                pilotViewModel.getPilots() {

                                    // Dismiss sheet and return to map settings
                                    DispatchQueue.main.async {
                                        dismiss()
                                    }
                                }
                            }) {
                                Text("Activate Pilot")
                                    .foregroundColor(skewTButtonTextColor)
                                    .padding(8)
                            }
                            .frame(width: skewTButtonWidth * 2)
                            .background(skewTButtonBackgroundColor)
                            .cornerRadius(8)
                            .padding(.vertical)

                            Spacer()
                            
                        }
                    }
                    
                }
            }
            Spacer()
        }
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
    
}
import SwiftUI
import Combine
import SDWebImage
import SDWebImageSwiftUI
import Foundation

struct WeatherView: View {
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @StateObject private var weatherAlertViewModel = WeatherAlertViewModel()
    @StateObject private var afdViewModel = AFDViewModel()
    @StateObject private var windsAloftViewModel = WindsAloftViewModel()
    @StateObject private var soaringForecastViewModel = SoaringForecastViewModel()
    @StateObject private var soaringForecastBasicViewModel = SoaringForecastBasicViewModel()
    @StateObject private var TFRviewModel = TFRViewModel()
    
    // Used to open URL links as an in-app sheet using Safari
    @Environment(\.openURL) var openURL
    @State private var externalURL: URL?
    @State private var showWebView = false
    
    // AFD
    @State private var afdSelectedIndex: Int = 0
    @State private var afdCodeOptions: [(name: String, code: String)] = []
    
    // Soaring forecast
    @State private var soaringForecastSelectedIndex: Int = 0
    @State private var soaringForecastCodeOptions: [(name: String, forecastType: String, code: String)] = []
    
    // Winds aloft forecast
    @State private var windsAloftSelectedIndex: Int = 0
    @State private var windsAloftCodeOptions: [(name: String, code: String)] = []
    
    // Latest sounding model
    @State private var soundingModelSelectedIndex: Int = 0
    @State private var soundingModelCodeOptions: [(name: String, code: String)] = []

    
    var body: some View {
        VStack {
            List {
                
                // National forecast map
                Section(header: Text("Forecast (12 hour)")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold()) {
                        VStack {
                            let forecastMapURL = AppURLManager.shared.getAppURL(URLName: "forecastMapURL") ?? "<Unknown forecast map URL>"
                            if !forecastMapURL.isEmpty {
                                WebImage (url: URL(string: forecastMapURL)) { image in image.resizable() }
                                placeholder: {
                                    Text("Tap to view")
                                        .foregroundColor(infoFontColor)
                                        .multilineTextAlignment(.center)
                                        .frame(maxWidth: .infinity, alignment: .trailing)
                                }
                                .onSuccess { image, data, cacheType in }
                                .indicator(.activity) // Activity Indicator
                                .transition(.fade(duration: 0.5)) // Fade Transition with duration
                                .scaledToFit()
                                .onTapGesture { if let url = URL(string: forecastMapURL) { openLink(url) } }
                            } else {
                                Text("No forecast map available for \(RegionManager.shared.activeAppRegion)")
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                            }
                        }
                    }
                
                // TFRs
                Section(header: Text("Temporary Flight Restrictions")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    if TFRviewModel.isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(0.75)
                            .frame(width: 20, height: 20)
                    } else if TFRviewModel.tfrs.isEmpty {
                        Text("No active TFRs for \(RegionManager.shared.activeAppRegion)")
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                    } else {
                        ForEach(TFRviewModel.tfrs) { tfr in
                            VStack(alignment: .leading) {
                                Text(tfr.type.capitalized)
                                    .font(.subheadline)
                                    .foregroundColor(warningFontColor)
                                Text(tfr.description)
                                    .font(.subheadline)
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
                            .contentShape(Rectangle())      // Makes entire area tappable
                            .onTapGesture {
                                let tfrLink = AppURLManager.shared.getAppURL(URLName: "TFRLink") ?? "<Unknown TFR link URL>"
                                let updatedTFRLinkURL = updateURL(url: tfrLink, parameter: "notamID", value: tfr.notam_id.replacingOccurrences(of: "/", with: "_"))
                                if let url = URL(string: updatedTFRLinkURL) {
                                    openLink(url)
                                }
                            }
                        }
                    }
                }
                
                // Weather alerts
                Section(header: Text("Weather Alerts")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    VStack {
                        if weatherAlertViewModel.isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle())
                                .scaleEffect(0.75)
                                .frame(width: 20, height: 20)
                        } else if weatherAlertViewModel.weatherAlerts.count == 0 {
                            Text("No active weather alerts for \(AppRegionManager.shared.getRegionName() ?? "")")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                        } else {
                            ForEach(weatherAlertViewModel.weatherAlerts) { alert in
                                VStack(alignment: .leading) {
                                    Text(alert.event ?? "")
                                        .font(.subheadline)
                                        .foregroundColor(warningFontColor)
                                    Text(alert.headline ?? "")
                                        .font(.subheadline)
                                    Text(alert.areaDescription ?? "")
                                        .font(.footnote)
                                        .foregroundColor(infoFontColor)
                                }
                                .padding(.vertical, 2)
                                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
                            }
                        }
                    }
                    .contentShape(Rectangle())      // Makes entire area tappable
                    .onTapGesture {
                        let baseURL = AppURLManager.shared.getAppURL(URLName: "weatherAlertsLink") ?? ""
                        if let url = URL(string: baseURL) {
                            openLink(url)
                        }
                    }
                }
                
                // Area Forecast Discussion (AFD)
                AreaForecastDiscussionView(
                    viewModel:                afdViewModel,
                    userSettingsViewModel:    userSettingsViewModel,
                    codeOptions:              afdCodeOptions,
                    selectedIndex:            $afdSelectedIndex,
                    openLink:                 openLink(_:)
                )
                
                // Soaring forecast
                SoaringForecastView(
                    richVM:                   soaringForecastViewModel,
                    basicVM:                  soaringForecastBasicViewModel,
                    userSettingsViewModel:    userSettingsViewModel,
                    codeOptions:              soaringForecastCodeOptions,
                    selectedIndex:            $soaringForecastSelectedIndex,
                    openLink:                 openLink(_:)
                )
                
                // Winds aloft forecast
                Section(header: Text("Winds Aloft Forecast")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    if windsAloftViewModel.isLoading {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(0.75)
                            .frame(width: 20, height: 20)
                    } else if windsAloftCodeOptions.count == 0 {
                        Text("No winds aloft forecast found for region")
                    } else {
                        if windsAloftCodeOptions.count > 1 {
                            Picker("Select Location", selection: $windsAloftSelectedIndex) {
                                ForEach(0..<windsAloftCodeOptions.count, id: \.self) { index in
                                    Text(windsAloftCodeOptions[index].name).tag(index)
                                }
                            }
                            .pickerStyle(SegmentedPickerStyle())
                            .padding(.vertical, 4)
                            
                            .onChange(of: windsAloftSelectedIndex) { oldIndex, newIndex in
                                let selectedCode = windsAloftCodeOptions[newIndex].code
                                windsAloftViewModel.getWindsAloftData(airportCode: selectedCode)
                                userSettingsViewModel.updatePickListSelection(pickListName: "windsAloft", selectedIndex: newIndex)
                            }
                        }
                        
                        Text("Forecast for \(String(windsAloftCodeOptions[windsAloftSelectedIndex].name)) for the next \(windsAloftViewModel.cycle) hours")
                            .font(.footnote)
                        LazyVGrid(columns: [
                            GridItem(.fixed(64), spacing: 5, alignment: .trailing),
                            GridItem(.fixed(64), spacing: 5, alignment: .trailing),
                            GridItem(.fixed(64), spacing: 5, alignment: .trailing),
                        ], spacing: 6) {
                            Text("Altitude")
                                .font(.footnote)
                                .foregroundColor(infoFontColor)
                            Text("Temp")
                                .font(.footnote)
                                .foregroundColor(infoFontColor)
                            Text("Wind (mph)")
                                .font(.footnote)
                                .foregroundColor(infoFontColor)
                            ForEach(windsAloftViewModel.readings, id: \.altitude) { reading in
                                Text("\(reading.altitude) ft")
                                    .font(.footnote)
                                HStack {
                                    if reading.temperature != nil {
                                        Text("\(reading.temperature ?? 0)")
                                            .font(.footnote)
                                            .foregroundColor(tempColor(reading.temperature)) +
                                        Text(" ° F")
                                            .font(.footnote)
                                    } else {
                                        Text("")
                                            .font(.footnote)
                                    }
                                }
                                if reading.windDirection == 990 {
                                    Text("Light and variable")
                                        .font(.footnote)
                                } else {
                                    HStack {
                                        if reading.windSpeed != nil {
                                            Text("\(reading.windSpeed ?? 0)")
                                                .font(.footnote)
                                                .foregroundColor(windSpeedColor(windSpeed: reading.windSpeed, siteType: ""))
                                            Image(systemName: windArrow)
                                                .rotationEffect(Angle(degrees: Double(reading.windDirection ?? 0)))
                                                .font(.caption)
                                        } else {
                                            Text("")
                                                .font(.footnote)
                                        }
                                    }
                                }
                            }
                        }
                        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .leading)
                        .contentShape(Rectangle())      // Makes entire area tappable
                        .onTapGesture {
                            let windsAloftLink = AppURLManager.shared.getAppURL(URLName: "windsAloftURL") ?? "<Unknown winds aloft link URL>"
                            let updatedWindsAloftLink = updateURL(url: windsAloftLink, parameter: "cycle", value: windsAloftCycle())
                            if let url = URL(string: updatedWindsAloftLink) {
                                openLink(url)
                            }
                        }
                    }
                }
                
                // High res diagram from morning sounding (from Matt Hansen)
                // Only if region is Utah at this point
                if RegionManager.shared.activeAppRegion == "UT" && soaringForecastViewModel.soaringForecast?.forecastMaxTemp ?? 0 > 0 {
                    Section(header: Text("SLC Morning Sounding")
                        .font(.headline)
                        .foregroundColor(sectionHeaderColor)
                        .bold()) {
                            VStack {
                                SkewTChartView(forecastMaxTemp: soaringForecastViewModel.soaringForecast?.forecastMaxTemp ?? 0)
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                        }
                }
                
                // Link to sounding from latest forecast model
                Section(header: Text("Latest Model Sounding")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold()) {
                        
                        if windsAloftCodeOptions.count == 0 {
                            Text ("No latest model soundings available for region")
                        } else {
                            if soundingModelCodeOptions.count > 1 {
                                Picker("Select Location", selection: $soundingModelSelectedIndex) {
                                    ForEach(0..<soundingModelCodeOptions.count, id: \.self) { index in
                                        Text(soundingModelCodeOptions[index].name).tag(index)
                                    }
                                }
                                .pickerStyle(SegmentedPickerStyle())
                                .padding(.vertical, 4)
                                .onChange(of: soundingModelSelectedIndex) { oldIndex, newIndex in
                                    userSettingsViewModel.updatePickListSelection(pickListName: "soundingModel", selectedIndex: newIndex)
                                }
                            }
                            
                            let soundingModelURL = AppURLManager.shared.getAppURL(URLName: "latestModelSoundingURL") ?? "<Unknown forecast map URL>"
                            let updatedSoundingModelURL = updateURL(url: soundingModelURL, parameter: "stationcode", value: soundingModelCodeOptions[soundingModelSelectedIndex].code)
                            
                            VStack {
                                WebImage (url: URL(string: updatedSoundingModelURL)) { image in image.resizable() }
                                placeholder: {
                                    Text("Tap to view")
                                        .foregroundColor(infoFontColor)
                                }
                                .onSuccess { image, data, cacheType in }
                                .indicator(.activity) // Activity Indicator
                                .transition(.fade(duration: 0.5)) // Fade Transition with duration
                                .scaledToFit()
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
                            .contentShape(Rectangle())      // Makes entire area tappable
                            .onTapGesture { if let url = URL(string: updatedSoundingModelURL) { openLink(url) } }
                        }
                    }
                
                // Attribute SLC morning sounding if displayed (for Utah region only)
                if RegionManager.shared.activeAppRegion == "UT" {
                    VStack (alignment: .leading) {
                        Text("SLC Morning Sounding data served by Matt Hansen")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                        Text("https://wasatchwind.github.io/")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                    }
                    .listRowBackground(attributionBackgroundColor)
                }
            }
        }
        .onAppear {
            
            // TFRs
            TFRviewModel.fetchTFRs()
            
            // Weather Alerts
            weatherAlertViewModel.getWeatherAlerts()
            
            // AFD
            afdCodeOptions = AppRegionCodesManager.shared.getAFDCodes()
            if !afdCodeOptions.isEmpty {
                afdSelectedIndex = userSettingsViewModel.getPickListSelection(pickListName: "afd")
                afdViewModel.fetchAFD(airportCode: afdCodeOptions[0].code)
            }
            
            // Soaring forecast (rich/simple and basic)
            soaringForecastCodeOptions = AppRegionCodesManager.shared.getSoaringForecastCodes()
            if !soaringForecastCodeOptions.isEmpty {
                soaringForecastSelectedIndex = userSettingsViewModel.getPickListSelection(pickListName: "soaringForecast")
                if soaringForecastCodeOptions[0].forecastType == "rich" {
                    soaringForecastViewModel.fetchSoaringForecast(airportCode: soaringForecastCodeOptions[0].code)
                } else {
                    soaringForecastBasicViewModel.fetchSoaringForecast(airportCode: soaringForecastCodeOptions[0].code)
                }
            }
            
            // Winds aloft forecast
            windsAloftCodeOptions = AppRegionCodesManager.shared.getWindsAloftCodes()
            if !windsAloftCodeOptions.isEmpty {
                windsAloftSelectedIndex = userSettingsViewModel.getPickListSelection(pickListName: "windsAloft")
                windsAloftViewModel.getWindsAloftData(airportCode: windsAloftCodeOptions[0].code)
            }
            
            // Latest sounding model
            soundingModelCodeOptions = AppRegionCodesManager.shared.getSoundingModelCodes()
            if !soundingModelCodeOptions.isEmpty {
                soundingModelSelectedIndex = userSettingsViewModel.getPickListSelection(pickListName: "soundingModel")
            }

        }
        
        // Used to open URL links as an in-app sheet using Safari
        .sheet(isPresented: $showWebView) { if let url = externalURL { SafariView(url: url) } }
    }
    // Used to open URL links as an in-app sheet using Safari
    func openLink(_ url: URL) { externalURL = url; showWebView = true }
}
import SwiftUI
import Foundation

// Developer view to troubleshoot pilot live tracks
struct DevPilotTracksView: View {
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    
    // for driving the sheet
    @State private var selectedPilotTrack: PilotTrack?

    // formatters
    private let dayFormatter: DateFormatter = {
        let df = DateFormatter()
        df.dateStyle = .medium
        df.timeStyle = .none
        return df
    }()
    private let timeFormatter: DateFormatter = {
        let df = DateFormatter()
        df.dateStyle = .none
        df.timeStyle = .short
        return df
    }()

    var body: some View {
        NavigationView {
                
            List {
                
                Text("Note: Pilots tracks are filtered based user map settings")
                    .font(.caption)
                
                if pilotTrackViewModel.isLoading {
                    HStack(spacing: 8) {
                        Spacer()
                        Text("Loading pilot tracks")
                            .font(.subheadline)
                            .foregroundStyle(loadingBarTextColor)
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .scaleEffect(0.75)
                            .padding(.horizontal, 8)
                    }
                    .padding(.vertical, 4)
                    
                } else {
                    
                    ForEach(pilotViewModel.pilots) { pilot in
                        
                        // Filter tracks by pilot
                        let tracksForPilot = pilotTrackViewModel.pilotTracks
                            .filter { $0.pilotName == pilot.pilotName }
                        
                        // Group tracks by date
                        let tracksByDay = Dictionary(
                            grouping: tracksForPilot,
                            by: { Calendar.current.startOfDay(for: $0.dateTime) }
                        )
                        
                        // Only show a pilot if there are any tracks
                        if !tracksByDay.isEmpty {
                            Section(header: Text(pilot.pilotName)) {
                                // sort the days descending, for example
                                ForEach(
                                    tracksByDay.keys.sorted(by: >),
                                    id: \.self
                                ) { day in
                                    Button {
                                        // Choose the first track point of that day
                                        selectedPilotTrack = tracksByDay[day]?.first
                                    } label: {
                                        HStack {
                                            Text(dayFormatter.string(from: day))
                                                .font(.subheadline)
                                            Spacer()
                                            Text("(\(tracksByDay[day]?.count ?? 0) pts)")
                                                .font(.caption)
                                                .foregroundColor(.secondary)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            .onAppear {
                DispatchQueue.main.async {
                    pilotTrackViewModel.getPilotTracks(days: userSettingsViewModel.pilotTrackDays,
                                                       selectedPilots: userSettingsViewModel.selectedPilots) {}
                }
            }
            
            .sheet(item: $selectedPilotTrack) { track in
                PilotTrackNodeView(originalPilotTrack: track)
            }
        }
    }
}
import SwiftUI
import Combine
import Charts

struct FlyingPotentialView: View {
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    
    @State private var selectedFlyingDetail: SelectedSiteDetail?

    @Environment(\.scenePhase) private var scenePhase
    
    @State private var forecastMap: [String: ForecastData] = [:] // keyed by siteName
    @State private var selectedSite: SiteSelection?
    @State private var favorites: [UserFavoriteSite] = []
    
    private var favoriteSites: [UserFavoriteSite] {
        userSettingsViewModel.userFavoriteSites
            .filter { $0.appRegion == RegionManager.shared.activeAppRegion }
            .sorted { $0.sortSequence < $1.sortSequence }
    }
    
    // Currently only including favorites due to "too many concurrent request" errors
    // would need to revise logic for forecast calls to handle more sites
    var includeSites: Bool = true
    var includeFavorites: Bool = true
    
    var body: some View {
        VStack {
            Text("Tap on a site for readings history and forecast")
                .font(.caption)
                .foregroundColor(infoFontColor)
                .padding(.top, 8)
            Text("Tap on a circle for details on the paragliding potential")
                .font(.caption)
                .foregroundColor(infoFontColor)
                .padding(.top, 8)


            List {
                if includeFavorites {
                    FavoritesPotentialSection(
                        onDetailTap: { detail in selectedFlyingDetail = detail }, favorites: $favorites,
                        siteViewModel: siteViewModel,
                        onSelect: openSiteDetail,
                        forecastMap: forecastMap,
                        siteFromFavorite: siteFromFavorite
                    )
                }

                if includeSites {
                    // Group sites by area, filtered for Soaring/Mountain
                    let groupedSites = Dictionary(grouping: siteViewModel.sites.filter {
                        $0.siteType == "Soaring" || $0.siteType == "Mountain"
                    }) { $0.area }
                    
                    // Sort areas by your predefined order and only include non-empty groups
                    let sortedGroupedSites: [(String, [Site])] = siteViewModel.areaOrder.compactMap { areaName in
                        guard let sitesInArea = groupedSites[areaName], !sitesInArea.isEmpty else {
                            return nil
                        }
                        return (areaName, sitesInArea)
                    }
                    
                    ForEach(sortedGroupedSites, id: \.0) { (area, sites) in
                        let displaySites = sites.map { SiteWithDisplayName(site: $0, displayName: $0.siteName) }
                        SiteGridSection(title:          area,
                                        sites:          displaySites,
                                        onSelect:       openSiteDetail,
                                        onDetailTap:    { detail in selectedFlyingDetail = detail },
                                        forecastMap:    forecastMap)
                    }
                }

                // Attribution footer
                VStack(alignment: .leading) {
                    Text("Forecast data provided by Open-meteo")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                    Text("https://open-meteo.com")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                }
                .listRowBackground(attributionBackgroundColor)
                .padding(.top, 8)
            }
        }
        
        .onAppear {
            favorites = favoriteSites
            
            let allSites: [Site] = {
                var result: [Site] = []

                if includeFavorites {
                    let favoriteList = favoriteSites.compactMap {
                        if let (site, _) = siteFromFavorite($0) { return site }
                        return nil
                    }
                    result += favoriteList
                }

                if includeSites {
                    let siteList = siteViewModel.sites.filter {
                        $0.siteType == "Soaring" || $0.siteType == "Mountain"
                    }
                    result += siteList
                }

                return result
            }()

            for site in allSites {
                siteForecastViewModel.fetchForecast(siteName:           site.siteName,
                                                    latitude:           site.siteLat,
                                                    longitude:          site.siteLon,
                                                    siteType:           site.siteType,
                                                    siteWindDirection:  site.windDirection) { forecast in

                    DispatchQueue.main.async {
                        if let forecast = forecast {
                            forecastMap[site.siteName] = forecast
                        }
                    }
 
                }
            }
        }
        
        .sheet(item: $selectedSite) { selection in
            SiteDetailView(site: selection.site, favoriteName: selection.favoriteName)
        }
        
        .sheet(item: $selectedFlyingDetail) { detail in
            FlyingPotentialDetailView(
               site: detail.site,
               favoriteName: detail.displayName,
               forecastData: forecastMap[detail.site.siteName]!,
               forecastIndex: detail.forecastIndex
            )
            .interactiveDismissDisabled(true)
        }
        
        // Get external changes (e.g., adding/removing favorites from site detail sheet)
        .onChange(of: userSettingsViewModel.userFavoriteSites) { _, newValue in
            favorites = newValue
        }
    }
    
    private func openSiteDetail(_ site: Site) {
        let matchedFavorite = favorites.first {
            ($0.favoriteType == "site" && $0.favoriteID == site.siteName) ||
            ($0.favoriteType == "station" && $0.stationID == site.readingsStation)
        }

        let favoriteName = matchedFavorite?.favoriteName ?? site.siteName
        selectedSite = SiteSelection(site: site, favoriteName: favoriteName)
    }
    
    private func siteFromFavorite(_ fav: UserFavoriteSite) -> (Site, String)? {
        let display = fav.favoriteName.isEmpty ? fav.favoriteID : fav.favoriteName

        switch fav.favoriteType {
        case "site":
            if let match = siteViewModel.sites.first(where: { $0.siteName == fav.favoriteID }) {
                return (match, display)
            } else {
                return nil
            }
        case "station":
            let windDirection = SiteWindDirection( N:  "", NE: "", E:  "", SE: "", S:  "", SW: "", W:  "", NW: "" )
            
            return (Site(
                area:               "Favorites",
                siteName:           fav.favoriteID,
                readingsNote:       "",
                forecastNote:       "",
                siteType:           "station",
                readingsAlt:        fav.readingsAlt,
                readingsSource:     fav.readingsSource,
                readingsStation:    fav.stationID,
                pressureZoneReadingTime: "",
                siteLat:            fav.siteLat,
                siteLon:            fav.siteLon,
                sheetRow:           0,
                windDirection:      windDirection
            ), display)
        default:
            return nil
        }
    }
}

struct FavoritesPotentialSection: View {
    let onDetailTap: (SelectedSiteDetail) -> Void
    @Binding var favorites: [UserFavoriteSite]
    let siteViewModel: SiteViewModel
    let onSelect: (Site) -> Void
    let forecastMap: [String: ForecastData]
    let siteFromFavorite: (UserFavoriteSite) -> (Site, String)?

    private let columns: [GridItem] = [
        GridItem(.flexible(), alignment: .leading),
        GridItem(.flexible(), alignment: .trailing)
    ]

    var body: some View {

        let filteredFavorites: [SiteWithDisplayName] = favorites.compactMap { favorite in
            guard let (site, displayName) = siteFromFavorite(favorite),
                  site.siteType == "Soaring" || site.siteType == "Mountain" else {
                return nil
            }
            return SiteWithDisplayName(site: site, displayName: displayName)
        }
        
        if !filteredFavorites.isEmpty {
            SiteGridSection(title:          "Favorites",
                            sites:          filteredFavorites,
                            onSelect:       onSelect,
                            onDetailTap:    onDetailTap,
                            forecastMap:    forecastMap)
            
        } else {
            // Currently not displaying Favorites section or any instructions
/*            Section(
                header: Text("Favorites")
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold()
            ) {
                VStack (alignment: .leading) {
                    Text("No favorites found; add favorites on Sites page")
                        .font(.subheadline)
                        .padding(.top, 8)
                    
                    Text("Note: Only Mountain/Soaring sites are displayed")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                        .padding(.vertical, 8)
                }
            }
 */
        }
 
    }

}

struct SiteWithDisplayName: Identifiable, Equatable {
    let site: Site
    let displayName: String
    var id: String { site.siteName }
}

struct SelectedSiteDetail: Identifiable, Equatable {
    let site: Site
    let displayName: String
    let forecastIndex: Int
    var id: String { "\(site.siteName)-\(forecastIndex)" }
}

struct SiteGridSection: View {
    let title: String
    let sites: [SiteWithDisplayName]
    let onSelect: (Site) -> Void
    let onDetailTap: (SelectedSiteDetail) -> Void
    let forecastMap: [String: ForecastData]
    
    private let columns: [GridItem] = [
        GridItem(.flexible(), alignment: .leading),
        GridItem(.flexible(), alignment: .trailing)
    ]
    
    var body: some View {
        Section(
            header: Text(title)
                .font(.subheadline)
                .foregroundColor(sectionHeaderColor)
                .bold()
        ) {
            if let anyForecast = sites.compactMap({ forecastMap[$0.site.siteName] }).first {
                let hourly = anyForecast.hourly
                if let dateTimeCount = hourly.dateTime?.count {
                    
                    let dataWidth: CGFloat = 44
                    let rowHeight: CGFloat = 32
                    
                    HStack(alignment: .top, spacing: 0) {
                        // Non-scrolling first column (site names)
                        VStack(alignment: .leading, spacing: 0) {
                            // Header row that visually matches the forecast header (2 stacked labels)
                            VStack(spacing: 0) {
                                Text(" ")
                                    .font(.caption)
                                    .frame(width: 100, height: rowHeight / 2, alignment: .leading)
                                    .padding(.top, 8)
                                Text(" ")
                                    .font(.caption)
                                    .frame(width: 100, height: rowHeight / 2, alignment: .leading)
                                Text(" ")
                                    .font(.caption)
                                    .frame(width: 100, height: rowHeight / 2, alignment: .leading)
                                    .padding(.bottom, 4)
                            }
                            
                            // Data rows
                            ForEach(sites.indices, id: \.self) { index in
                                let siteInfo = sites[index]
                                Text(siteInfo.displayName != "" ? siteInfo.displayName : siteInfo.site.siteName)
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                                    .frame(width: 100, height: rowHeight, alignment: .leading)
                                    .padding(1)
                                    .contentShape(Rectangle()) // Makes entire area tappable
                                    .onTapGesture {
                                        onSelect(siteInfo.site)
                                    }
                            }
                        }
                        .padding(4)
                        
                        // Scrollable forecast grid (header + rows)
                        ScrollView(.horizontal, showsIndicators: true) {
                            VStack(alignment: .leading, spacing: 0) {
                                // Header row
                                HStack(spacing: 4) {
                                    ForEach(hourly.dateTime?.indices ?? 0..<0, id: \.self) { i in
                                        VStack {
                                            if hourly.newDateFlag?[i] ?? true {
                                                Text(hourly.formattedDay?[i] ?? "")
                                                    .font(.caption)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 8)
                                                    .overlay(Divider().frame(width: dateChangeDividerSize, height: headingHeight)
                                                                .background(getDividerColor(hourly.newDateFlag?[i] ?? true)), alignment: .leading)
                                                
                                                Text(hourly.formattedDate?[i] ?? "")
                                                    .font(.caption)
                                                    .frame(width: dataWidth)
                                                    .overlay(Divider().frame(width: dateChangeDividerSize, height: headingHeight)
                                                                .background(getDividerColor(hourly.newDateFlag?[i] ?? true)), alignment: .leading)
                                            } else {
                                                Text(hourly.formattedDay?[i] ?? "")
                                                    .font(.caption)
                                                    .foregroundColor(repeatDateTimeColor)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 8)
                                                    .overlay(Divider().frame(width: dateChangeDividerSize, height: headingHeight)
                                                                .background(getDividerColor(hourly.newDateFlag?[i] ?? true)), alignment: .leading)
                                                
                                                Text(hourly.formattedDate?[i] ?? "")
                                                    .font(.caption)
                                                    .foregroundColor(repeatDateTimeColor)
                                                    .frame(width: dataWidth)
                                                    .overlay(Divider().frame(width: dateChangeDividerSize, height: headingHeight)
                                                                .background(getDividerColor(hourly.newDateFlag?[i] ?? true)), alignment: .leading)
                                            }
                                            
                                            Text(hourly.formattedTime?[i] ?? "")
                                                .font(.caption)
                                                .frame(width: dataWidth)
                                                .padding(.bottom, 4)
                                                .overlay(Divider().frame(width: dateChangeDividerSize, height: headingHeight)
                                                            .background(getDividerColor(hourly.newDateFlag?[i] ?? true)), alignment: .leading)
                                        }
                                    }
                                }
                                
                                // Forecast rows
                                ForEach(sites.indices, id: \.self) { index in
                                    let siteInfo = sites[index]
                                    let site = siteInfo.site
                                    
                                    if let forecast = forecastMap[site.siteName],
                                       let combinedColorValue = forecast.hourly.combinedColorValue {
                                        
                                        HStack(spacing: 4) {
                                            ForEach(0..<dateTimeCount, id: \.self) { i in
                                                if i < combinedColorValue.count {
                                                    let displayColor = FlyingPotentialColor.color(for: combinedColorValue[i])
                                                    let displaySize = FlyingPotentialImageSize(displayColor)
                                                    
                                                    Image(systemName: flyingPotentialImage)
                                                        .resizable()
                                                        .scaledToFit()
                                                        .font(.system(size: displaySize))
                                                        .frame(width: displaySize, height: displaySize)
                                                        .foregroundColor(Color(displayColor))
                                                        .padding(8)
                                                        .frame(width: dataWidth, height: rowHeight)
                                                        .contentShape(Rectangle())
                                                        .onTapGesture {
                                                            let detail = SelectedSiteDetail(
                                                                site:           site,
                                                                displayName:    siteInfo.displayName,
                                                                forecastIndex:  i)
                                                            onDetailTap(detail)
                                                        }
                                                } else {
                                                    Rectangle()
                                                        .fill(Color.gray.opacity(0.2))
                                                        .frame(width: dataWidth, height: rowHeight)
                                                }
                                            }
                                        }
                                        .padding(1)
                                    } else {
                                        // fallback if forecast missing
                                        HStack(spacing: 4) {
                                            ForEach(0..<dateTimeCount, id: \.self) { _ in
                                                Text("-")
                                                    .font(.caption)
                                                    .frame(width: dataWidth, height: rowHeight)
                                            }
                                        }
                                        .padding(1)
                                    }
                                }
                            }
                            .padding(4)
                            .background(potentialChartBackgroundColor)
                            .cornerRadius(10)
                        }
                    }
                    .padding(.vertical, 4)
                }
            }
        }
    }
}
import SwiftUI
import Combine
import Foundation
import SDWebImage
import SDWebImageSwiftUI

var webcamLastUpdate: Date = Date.distantPast

struct WeatherCamView: View {
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @StateObject private var weatherCamViewModel = WeatherCamViewModel()
    
    @Environment(\.openURL) var openURL     // Used to open URL links as an in-app sheet using Safari
    @State private var externalURL: URL?    // Used to open URL links as an in-app sheet using Safari
    @State private var showWebView = false  // Used to open URL links as an in-app sheet using Safari
    
    var body: some View {
        Group {
            if weatherCamViewModel.isLoading {
                loadingView
            } else if weatherCamViewModel.weatherCams.isEmpty {
                emptyView
            } else {
                contentView
            }
        }
        .onAppear {
            // Clear all image caches and force reload if images are odler than refresh interval
            if Date().timeIntervalSince(webcamLastUpdate) > readingsRefreshInterval {
                SDImageCache.shared.clear(with: .all) {
                    webcamLastUpdate = Date()
                }
            }
            weatherCamViewModel.fetchWeatherCams()
        }
        // Used to open URL links as an in-app sheet using Safari
        .sheet(isPresented: $showWebView) { if let url = externalURL { SafariView(url: url) } }
    }

    private var loadingView: some View {
        VStack {
            Spacer()
            ProgressView() // ("Loading weather cams…")
                .progressViewStyle(CircularProgressViewStyle())
            Spacer()
        }
    }
    
    private var emptyView: some View {
        VStack {
            Spacer()
            Text("No weather cams available")
                .font(.subheadline)
                .foregroundColor(.gray)
                .padding()
            Spacer()
        }
    }

    private var contentView: some View {
        List {
            if RegionManager.shared.activeAppRegion == "UT" {
                Section(header: Text("Point of the Mountain")
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    Button(action: {
                        if let url = URL(string: ipCamLink) {
                            UIApplication.shared.open(url)
                        }
                    }) {
                        VStack(alignment: .leading) {
                            Text("Download IPCams to view POTM webcams")
                                .font(.subheadline)
                                .foregroundColor(rowHeaderColor)
                            Text("UHGPGA webcam page has IP and PW info")
                                .font(.subheadline)
                        }
                    }
                }
            }
            ForEach(weatherCamViewModel.groupedWeatherCams.keys.sorted(), id: \.self) { category in
                Section(header: Text(category)
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold()) {
                        ForEach(weatherCamViewModel.groupedWeatherCams[category] ?? [], id: \.id) { cam in
                            VStack {
                                Text(cam.name)
                                    .multilineTextAlignment(.center)
                                    .frame(maxWidth: .infinity, alignment: .center)
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                                WebImage (url: URL(string: cam.imageURL.isEmpty ? cam.linkURL : cam.imageURL)) { image in
                                    image.resizable() // Control layout like SwiftUI.AsyncImage
                                    // Must use this modifier or the view will use the image bitmap size
                                } placeholder: {
                                    Text("Tap to view")
                                        .foregroundColor(infoFontColor)
                                        .multilineTextAlignment(.center)
                                        .frame(maxWidth: .infinity, alignment: .center)
                                }
                                // Supports options and context, like `.delayPlaceholder` to show placeholder only when error
                                .onSuccess { image, data, cacheType in
                                    // Success
                                    // Note: Data exist only when queried from disk cache or network.
                                    // Use `.queryMemoryData` if you really need data
                                }
                                .indicator(.activity) // Activity Indicator
                                .transition(.fade(duration: 0.5)) // Fade Transition with duration
                                .scaledToFit()
                            }
                            .onTapGesture {
                                if let url = URL(string: cam.linkURL) {
                                    openLink(url)
                                }
                            }
                        }
                    }
            }
        }
    }
    
    // Used to open URL links as an in-app sheet using Safari
    func openLink(_ url: URL) { externalURL = url; showWebView = true }
}
import SwiftUI

struct AreaForecastDiscussionView: View {
    @ObservedObject var viewModel: AFDViewModel
    @ObservedObject var userSettingsViewModel: UserSettingsViewModel
    let codeOptions: [(name:String,code:String)]
    @Binding var selectedIndex: Int
    let openLink: (URL) -> Void
    
    // local @State for which groups are expanded
    @State private var showKeyMessages = true
    @State private var showSynopsis    = true
    @State private var showDiscussion  = false
    @State private var showShortTerm   = false
    @State private var showLongTerm    = false
    @State private var showAviation    = true
    
    var body: some View {
        Section(header: Text("Area Forecast Discussion")
            .font(.headline)
            .foregroundColor(sectionHeaderColor)
            .bold()) {
                
                // Loading / No-codes cases
                if viewModel.isLoading {
                    ProgressView()
                        .scaleEffect(0.75)
                }
                else if codeOptions.isEmpty {
                    Text("No area forecast discussion found for region")
                }
                else {
                    
                    // If more than one airport code, show the picker
                    if codeOptions.count > 1 {
                        Picker("Select Location", selection: $selectedIndex) {
                            ForEach(0..<codeOptions.count, id: \.self) { idx in
                                Text(codeOptions[idx].name).tag(idx)
                            }
                        }
                        .pickerStyle(SegmentedPickerStyle())
                        .padding(.vertical, 4)
                        .onChange(of: selectedIndex) { oldIndex, newIndex in
                            let code = codeOptions[newIndex].code
                            viewModel.fetchAFD(airportCode: code)
                            userSettingsViewModel.updatePickListSelection(pickListName: "afd", selectedIndex: newIndex)
                        }
                    }
                    
                    // Render the disclosure groups
                    if let afd = viewModel.AFDvar {
                        Text("Forecast Date: \(afd.date)")
                            .font(.footnote)
                        
                        buildGroup(label: "Key Messages",         isOn: $showKeyMessages,     content: afd.keyMessages)
                        buildGroup(label: "Synopsis",             isOn: $showSynopsis,        content: afd.synopsis)
                        buildGroup(label: "Discussion",           isOn: $showDiscussion,      content: afd.discussion)
                        buildGroup(label: "Short Term Forecast",  isOn: $showShortTerm,       content: afd.shortTerm)
                        buildGroup(label: "Long Term Forecast",   isOn: $showLongTerm,        content: afd.longTerm)
                        buildGroup(label: "Aviation Forecast",    isOn: $showAviation,        content: afd.aviation)
                    }
                    else {
                        // fallback if we don’t yet have AFDvar
                        ProgressView().scaleEffect(0.75)
                    }
                }
            }
    }
    
    // Helper to reduce duplication
    @ViewBuilder
    private func buildGroup(label: String,
                            isOn: Binding<Bool>,
                            content: String?) -> some View {
        if let text = content, !text.isEmpty {
            DisclosureGroup(isExpanded: isOn) {
                Text(text)
                    .font(.subheadline)
                    .contentShape(Rectangle())
                    .onTapGesture {
                        guard let base = AppURLManager.shared
                            .getAppURL(URLName: "areaForecastDiscussionURL"),
                              let url = URL(string: updateURL(url: base,
                                                              parameter: "airportcode",
                                                              value: codeOptions[selectedIndex].code))
                        else { return }
                        openLink(url)
                    }
            } label: {
                Text(label)
                    .font(.headline)
                    .foregroundColor(rowHeaderColor)
            }
        }
    }
}
import SwiftUI
import Foundation
import SwiftUI
import UIKit   // needed for UIPasteboard

struct DevInactivePilotsView: View {
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel

    // Pilots with no tracks in the past year are considered inactive
    let daysToBecomeInactive: Double = 365.0

    private var loadingBarTextColor: Color { .secondary }
    
    var body: some View {
        NavigationView {
            List {
                if pilotTrackViewModel.isLoading {
                    loadingRow
                } else {
                    ForEach(pilotViewModel.pilots) { pilot in
                        PilotTrackInfoView(
                            pilot: pilot,
                            allTracks: pilotTrackViewModel.pilotTracks
                        )
                    }
                }
            }
            .onAppear(perform: loadAllPilotTracks)
            
        }
    }

    private func loadAllPilotTracks() {
        pilotTrackViewModel.getPilotTracks(
            days: daysToBecomeInactive,
            selectedPilots: []
        ) { }
    }

    private var loadingRow: some View {
        HStack(spacing: 8) {
            Spacer()
            Text("Loading pilot tracks")
                .font(.subheadline)
                .foregroundStyle(loadingBarTextColor)
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
                .scaleEffect(0.75)
                .padding(.horizontal, 8)
            Spacer()
        }
        .padding(.vertical, 4)
    }
}

struct PilotTrackInfoView: View {
    let pilot: Pilot
    let allTracks: [PilotTrack]
    
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    
    // Only this pilot’s tracks
    private var tracks: [PilotTrack] {
            allTracks.filter { $0.pilotName.lowercased() == pilot.pilotName.lowercased() }
    }

    // Date of the most recent track
    private var mostRecentDate: Date? {
        tracks.map(\.dateTime).max()
    }

    // Full days since that date
    private var daysAgo: Int {
        guard let date = mostRecentDate else { return 0 }
        return Calendar.current.dateComponents(
            [.day],
            from: Calendar.current.startOfDay(for: date),
            to: Calendar.current.startOfDay(for: Date())
        ).day ?? 0
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                
                // Pilot name
                Text(pilot.pilotName)
                
                if pilot.inactive {
                    Text("Currently inactive")
                        .font(.caption)
                        .foregroundColor(.orange)
                    Button("Activate Pilot") {
                        pilotViewModel.setPilotActiveStatus(pilot: pilot,
                                                            isInactive: false)
                        pilotViewModel.getPilots() {}
                    }
                    .font(.caption)
                    .buttonStyle(BorderlessButtonStyle())
                }
                
            }

            // Share URL
            Text(pilot.trackingShareURL)
                .font(.caption)
                .foregroundColor(.secondary)
                .onTapGesture {
                    UIPasteboard.general.string = pilot.trackingFeedURL
                }

            // Active vs inactive
            if !pilot.inactive {
                if tracks.isEmpty {
                    HStack {
                        Text("No tracks found")
                            .foregroundColor(.yellow)
                            .foregroundColor(.orange)
                        Button("Deactivate Pilot") {
                            pilotViewModel.setPilotActiveStatus(pilot: pilot,
                                                                isInactive: true)
                            pilotViewModel.getPilots() {}
                        }
                        .font(.caption)
                        .buttonStyle(BorderlessButtonStyle())
                    }
                } else {
                    Text("Newest track is \(daysAgo) day\(daysAgo == 1 ? "" : "s") ago")
                }
            }
        }
        .padding(.vertical, 8)
    }
}
import SwiftUI
import MapKit
import Combine
import UIKit
import CoreGraphics
import CoreLocation
import Foundation

class ArrowOverlay: NSObject, MKOverlay {
    let coordinate: CLLocationCoordinate2D
    let boundingMapRect: MKMapRect
    let angle: CGFloat           // in degrees
    let color: UIColor
    let size: Double             // in map points

    init(center: CLLocationCoordinate2D, angle: CGFloat, color: UIColor, size: Double = mapPilotArrowDefaultSize) {
        self.coordinate = center
        self.angle = angle
        self.color = color
        self.size = size

        let mapPoint = MKMapPoint(center)
        self.boundingMapRect = MKMapRect(
            x: mapPoint.x - size / 2,
            y: mapPoint.y - size / 2,
            width: size,
            height: size
        )
    }
}

class ArrowOverlayRenderer: MKOverlayRenderer {
    private let arrow: ArrowOverlay
    var zoomLevel: Double = 0  // Set from outside, e.g., in map delegate

    init(arrow: ArrowOverlay) {
        self.arrow = arrow
        super.init(overlay: arrow)
    }

    override func draw(_ mapRect: MKMapRect, zoomScale: MKZoomScale, in context: CGContext) {
        let center = point(for: MKMapPoint(arrow.coordinate))
        
        // Use zoomLevel instead of zoomScale directly
        let sizeFactor: CGFloat = zoomLevelSizeFactor(for: zoomLevel)
        let size: CGFloat = CGFloat(arrow.size) * zoomLevel * mapPilotAnnotationZoomFactor * sizeFactor
        let path = CGMutablePath()
        path.move(to: CGPoint(x: center.x, y: center.y - size / 2))
        path.addLine(to: CGPoint(x: center.x - size / 2, y: center.y + size / 2))
        path.addLine(to: CGPoint(x: center.x + size / 2, y: center.y + size / 2))
        path.closeSubpath()

        context.saveGState()
        context.translateBy(x: center.x, y: center.y)
        context.rotate(by: arrow.angle * .pi / 180)
        context.translateBy(x: -center.x, y: -center.y)

        context.setFillColor(arrow.color.cgColor)
        context.addPath(path)
        context.fillPath()

        context.restoreGState()
    }

    private func zoomLevelSizeFactor(for zoomLevel: Double) -> CGFloat {
        return min(0.05 * pow(2.0,(20.0 - zoomLevel)), 200)
    }
}

struct MapView: UIViewRepresentable {
    @Binding var mapRegion: MKCoordinateRegion
    @Binding var zoomLevel: Double
    @Binding var mapStyle: CustomMapStyle
    @Binding var mapDisplayMode: MapDisplayMode
    @Binding var showRadar: Bool
    @Binding var showInfrared: Bool
    @Binding var showSites: Bool
    let radarOverlays: [MKTileOverlay]
    let infraredOverlays: [MKTileOverlay]
    let pilotTracks: [PilotTrack]
    let sites: [Site]
    let stationAnnotations: [StationAnnotation]
    let onPilotSelected: (PilotTrack) -> Void
    let onStationSelected: (StationAnnotation) -> Void
    let onSiteSelected: (Site) -> Void
    @State private var lastPilotTrackHash: Int = 0     // Used to identify track changes requiring re-rendering
    
    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self,
                    onPilotSelected: onPilotSelected,
                    onStationSelected: onStationSelected,
                    onSiteSelected: onSiteSelected)
    }
    
    func makeUIView(context: Context) -> MKMapView {
        let mapView = MKMapView()
        mapView.delegate = context.coordinator
        mapView.setRegion(mapRegion, animated: false)
        mapView.showsUserLocation = false
        mapView.isZoomEnabled = true
        mapView.isScrollEnabled = true
        mapView.isRotateEnabled  = mapEnableRotate
        mapView.isPitchEnabled   = mapEnablePitch
        mapView.mapType = mapStyle.toMapType()
        return mapView
    }
    
    func updateUIView(_ mapView: MKMapView, context: Context) {
        
        // Update map type
        mapView.mapType = mapStyle.toMapType()
        
        // Clear out old overlays and annotations
        mapView.removeAnnotations(mapView.annotations)
        mapView.removeOverlays(mapView.overlays)

        // Display infrared satellite tiles
        if mapDisplayMode == .weather && showInfrared {
            for tile in infraredOverlays {
                mapView.addOverlay(tile, level: .aboveRoads)
            }
        }
        
        // Display radar tiles
        if mapDisplayMode == .weather && showRadar {
            for tile in radarOverlays {
                mapView.addOverlay(tile, level: .aboveRoads)
            }
        }
        
        // Add sites if enabled
        if mapDisplayMode == .weather && showSites {
            let allowedTypes: Set<String> = ["Mountain", "Soaring"]
            let filteredSites = sites
                .filter { allowedTypes.contains($0.siteType) }

            let siteAnnotations = filteredSites.map { site -> MKPointAnnotation in
                let ann = MKPointAnnotation()
                ann.coordinate = CLLocationCoordinate2D(
                    latitude: Double(site.siteLat)!,
                    longitude: Double(site.siteLon)!
                )
                ann.title = site.siteName
                return ann
            }
            mapView.addAnnotations(siteAnnotations)
        }
        
        // Build a stable, ordered list of pilots → color map
        let uniquePilots = Array(Set(pilotTracks.map { $0.pilotName }))
            .sorted()
        let pilotColorMap = Dictionary(
            uniqueKeysWithValues:
                uniquePilots.enumerated().map { idx, name in
                    (name, pilotColorPalette[idx % pilotColorPalette.count])
                }
        )
        context.coordinator.pilotColorMap = pilotColorMap
        
        // Add wind station annotation markers
        mapView.addAnnotations(stationAnnotations)
        
        // Determine whether to show all track markers
        let showAllMarkers = zoomLevel > mapShowAllMarkersZoomLevel
        
        // For each pilot, in sorted order:
        for pilotName in uniquePilots {
            // — grab & time-sort their tracks
            let tracksForPilot = pilotTracks
                .filter { $0.pilotName == pilotName }
                .sorted { $0.dateTime < $1.dateTime }
            
            // — extract coords for polyline
            let coords = tracksForPilot.map {
                CLLocationCoordinate2D(latitude: $0.latitude,
                                       longitude: $0.longitude)
            }
            
            // — add line if we have at least two points
            if coords.count > 1 {
                let polyline = MKPolyline(coordinates: coords, count: coords.count)
                polyline.title = pilotName
                mapView.addOverlay(polyline)
                
            }
            
            // — partition into emergency / message / finish / first / normal
            var emergencyTracks: [PilotTrack] = []
            var messageTracks:   [PilotTrack] = []
            var finishTracks:    [PilotTrack] = []
            var firstTracks:     [PilotTrack] = []
            var normalTracks:    [PilotTrack] = []
            
            for (i, track) in tracksForPilot.enumerated() {
                let isFirst   = (i == 0)
                let isLast    = (i == tracksForPilot.count - 1)
                let isEmerg   = track.inEmergency == true
                let hasMsg    = !(track.message?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
                let isNormal  = !isFirst && !isLast && !isEmerg && !hasMsg
                
                // drop normal if zoomed out
                if !showAllMarkers && isNormal { continue }
                
                switch true {
                case isEmerg:
                    emergencyTracks.append(track)
                case hasMsg:
                    messageTracks.append(track)
                case isLast:
                    finishTracks.append(track)
                case isFirst:
                    firstTracks.append(track)
                default:
                    normalTracks.append(track)
                }
            }
            
            // — add track annotations in that priority order
            for group in [emergencyTracks, messageTracks, finishTracks, firstTracks, normalTracks] {
                for track in group {
                    let idx = tracksForPilot.firstIndex { $0.id == track.id } ?? 0
                    let isFirst = idx == 0
                    let isLast  = idx == tracksForPilot.count - 1
                    let isEmerg = track.inEmergency == true
                    let hasMsg  = !(track.message?.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ?? true)
                    
                    let annotation = PilotTrackAnnotation(
                        coordinate: CLLocationCoordinate2D(
                            latitude:  track.latitude,
                            longitude: track.longitude
                        ),
                        title:      pilotName.components(separatedBy: " ").first ?? pilotName,
                        subtitle:   DateFormatter
                            .localizedString(from: track.dateTime,
                                             dateStyle: .none,
                                             timeStyle: .short),
                        annotationType: "pilot",
                        pilotTrack:     track,
                        pilotName:      pilotName,
                        isFirst:        isFirst,
                        isLast:         isLast,
                        isEmergency:    isEmerg,
                        hasMessage:     hasMsg
                    )
                    mapView.addAnnotation(annotation)
                }
            }
            
            // — if zoomed in, draw arrows between each consecutive pair
            if showAllMarkers {
                for i in 0..<coords.count - 1 {
                    let start = coords[i]
                    let end   = coords[i + 1]
                    let mid   = CLLocationCoordinate2D(
                        latitude:  (start.latitude  + end.latitude)  / 2,
                        longitude: (start.longitude + end.longitude) / 2
                    )
                    let angle = bearing(from: start, to: end)
                    let color = pilotColorMap[pilotName] ?? .gray
                    let arrow = ArrowOverlay(center: mid,
                                             angle: CGFloat(angle),
                                             color: color)
                    mapView.addOverlay(arrow)
                }
            }
        }
    }
    
    class Coordinator: NSObject, MKMapViewDelegate {
        var parent: MapView
        let onPilotSelected: (PilotTrack) -> Void
        let onStationSelected: (StationAnnotation) -> Void
        let onSiteSelected: (Site) -> Void
        var pilotColorMap: [String: UIColor] = [:]
        
        init(parent: MapView,
             onPilotSelected: @escaping (PilotTrack) -> Void,
             onStationSelected: @escaping (StationAnnotation) -> Void,
             onSiteSelected: @escaping (Site) -> Void) {
            self.parent = parent
            self.onPilotSelected = onPilotSelected
            self.onStationSelected = onStationSelected
            self.onSiteSelected = onSiteSelected
        }
        
        func mapView(_ mapView: MKMapView, regionDidChangeAnimated animated: Bool) {
            let newZoom = log2(360 * (Double(mapView.frame.size.width) / 256) / mapView.region.span.longitudeDelta)
            DispatchQueue.main.async {
                self.parent.zoomLevel = newZoom
                
                // Set map region to retain setting when user switches map modes
                self.parent.mapRegion = mapView.region
            }
        }
        
        func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -> MKOverlayRenderer {
            
            // Tile overlays (radar / infrared satellite)
            if let tile = overlay as? MKTileOverlay {
                let renderer = MKTileOverlayRenderer(tileOverlay: tile)
                if tile.urlTemplate?.contains("/satellite/") == true {
                    renderer.alpha = 0.6
                } else if tile.urlTemplate?.contains("/radar/") == true {
                    renderer.alpha = 1.0
                }
                return renderer
            }
            
            // Pilot track lines
            if let polyline = overlay as? MKPolyline,
               let pilotName = polyline.title {
                let r = MKPolylineRenderer(polyline: polyline)
                r.strokeColor = pilotColorMap[pilotName] ?? .gray
                r.lineWidth = mapPilotTrackWidth
                return r
            }
            
            // Arrows between nodes
            if let arrow = overlay as? ArrowOverlay {
                let renderer = ArrowOverlayRenderer(arrow: arrow)
                let zl = log2(360 * (Double(mapView.frame.size.width)/256) / mapView.region.span.longitudeDelta)
                renderer.zoomLevel = zl
                return renderer
            }
            
            // Fallback empty
            return MKOverlayRenderer(overlay: overlay)
        }
        
        func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
            
            // Pilot annotations
            if let pilotAnnotation = annotation as? PilotTrackAnnotation {
                
                let identifier = "PilotAnnotation"
                let view = mapView.dequeueReusableAnnotationView(withIdentifier: identifier)
                ?? MKAnnotationView(annotation: annotation, reuseIdentifier: identifier)
                
                view.annotation = annotation
                view.clusteringIdentifier = nil
                view.collisionMode = .circle
                
                // Remove prior views
                view.subviews.forEach { $0.removeFromSuperview() }
                
                // Determing track node annotation type
                var trackNodeType = "normal"
                if pilotAnnotation.isEmergency || pilotAnnotation.hasMessage || pilotAnnotation.isFirst || pilotAnnotation.isLast {
                    trackNodeType = "special"
                }
                
                var annotationSizingFactor: CGFloat = 1
                if trackNodeType != "normal" {
                    annotationSizingFactor = 3
                }
                let dotDiameter: CGFloat = parent.zoomLevel * mapPilotAnnotationZoomFactor * annotationSizingFactor
                let container = UIView()
                container.backgroundColor = .clear
                
                let pilotTrackColor = pilotColorMap[pilotAnnotation.pilotName] ?? .gray
                
                // Dot
                let dot = UIView(frame: CGRect(x: 0, y: 0, width: dotDiameter, height: dotDiameter))
                dot.frame = CGRect(x: 0, y: 0, width: dotDiameter, height: dotDiameter)
                dot.layer.cornerRadius = dotDiameter / 2
                dot.backgroundColor = pilotTrackColor
                dot.center = CGPoint(x: dotDiameter / 2, y: dotDiameter / 2)
                
                // Overlay icon for emergency/message/first/last
                if trackNodeType != "normal" {
                    let imageName: UIImage?
                    var imageSizeFactor: CGFloat = 1.0
                    if pilotAnnotation.isEmergency {
                        imageName = pilotInEmergencyAnnotationImage
                        dot.backgroundColor = UIColor(pilotEmergencyAnnotationColor)
                    } else if pilotAnnotation.hasMessage {
                        imageName = pilotMessageAnnotationImage
                    } else if pilotAnnotation.isFirst {
                        imageName = pilotLaunchAnnotationImage
                    } else {
                        imageName = pilotLatestAnnotationImage
                        imageSizeFactor = 2.5
                    }
                    
                    if let imageName = imageName {
                        let imageView = UIImageView(image: imageName.withRenderingMode(.alwaysTemplate))
                        imageView.tintColor = .white
                        imageView.contentMode = .scaleAspectFit
                        imageView.translatesAutoresizingMaskIntoConstraints = false
                        dot.addSubview(imageView)
                        
                        // calculate the size you want:
                        let baseInset = dotDiameter * 0.15
                        let imageSize = (dotDiameter - (2 * baseInset)) * imageSizeFactor
                        
                        NSLayoutConstraint.activate([
                            imageView.widthAnchor.constraint(equalToConstant: imageSize),
                            imageView.heightAnchor.constraint(equalToConstant: imageSize),
                            imageView.centerXAnchor.constraint(equalTo: dot.centerXAnchor),
                            imageView.centerYAnchor.constraint(equalTo: dot.centerYAnchor),
                        ])                }
                }
                
                // Label
                let label = UILabel()
                label.numberOfLines = 0
                label.textAlignment = .center
                let attributedText = NSMutableAttributedString()
                let span = mapView.region.span
                
                if let name = pilotAnnotation.title {
                    attributedText.append(NSAttributedString(
                        string: name + "\n",
                        attributes: [
                            .foregroundColor: UIColor(pilotLabelNameTextColor),
                            .font: UIFont.systemFont(ofSize: 10, weight: .semibold)
                        ]))
                }
                
                if span.latitudeDelta < pilotNodeLabelThreeRowSpan {
                    let pilotTrackNodeDateTime = getFormattedTimefromDate(pilotAnnotation.pilotTrack?.dateTime ?? Date())
                    attributedText.append(NSAttributedString(
                        string: pilotTrackNodeDateTime + "\n",
                        attributes: [
                            .foregroundColor: UIColor(pilotLabelDateTextColor),
                            .font: UIFont.systemFont(ofSize: 9)
                        ]))
                    
                    let pilotTrackNodeAltitude = pilotAnnotation.pilotTrack?.altitude ?? 0
                    let formattedAltitude = formatAltitude(String(pilotTrackNodeAltitude))
                    attributedText.append(NSAttributedString(
                        string: formattedAltitude,
                        attributes: [
                            .foregroundColor: UIColor(pilotLabelAltTextColor),
                            .font: UIFont.systemFont(ofSize: 9)
                        ]))
                }
                
                label.attributedText = attributedText
                label.sizeToFit()
                
                let labelContainer = UIView()
                var labelTopMargin: CGFloat = 2.0
                if span.latitudeDelta < pilotNodeLabelThreeRowSpan {
                    labelContainer.backgroundColor = UIColor.black.withAlphaComponent(0.7)
                    labelContainer.layer.borderColor = pilotTrackColor.cgColor
                    labelContainer.layer.borderWidth = 0.5
                    labelContainer.layer.cornerRadius = 5
                    labelContainer.layer.masksToBounds = true
                    labelTopMargin = 6.0
                }
                
                let padding: CGFloat = 4
                label.frame = CGRect(
                    x: padding,
                    y: padding,
                    width: label.frame.width,
                    height: label.frame.height
                )
                labelContainer.addSubview(label)
                labelContainer.frame = CGRect(
                    x: 0,
                    y: dot.frame.maxY + labelTopMargin,
                    width: label.frame.width + 2 * padding,
                    height: label.frame.height + 2 * padding
                )
                let containerWidth = max(dot.frame.width, labelContainer.frame.width)
                let containerHeight = dot.frame.height + labelTopMargin + labelContainer.frame.height
                
                container.frame = CGRect(x: 0, y: 0, width: containerWidth, height: containerHeight)
                
                // Align subviews
                dot.center = CGPoint(x: containerWidth / 2, y: dot.frame.height / 2)
                labelContainer.center.x = containerWidth / 2  // Only horizontal centering
                
                container.addSubview(dot)
                container.addSubview(labelContainer)
                
                view.addSubview(container)
                view.frame = container.frame
                
                // Anchor the center of the dot to the annotation coordinate
                // Center the dot exactly on the annotation coordinate
                let dotCenterInContainer = dot.center
                let containerCenter = CGPoint(x: container.frame.width / 2, y: container.frame.height / 2)
                let offsetY = dotCenterInContainer.y - containerCenter.y
                view.centerOffset = CGPoint(x: 0, y: -offsetY)
                
                // Handle annotation display/filtering based on type
                if trackNodeType != "normal" {
                    view.displayPriority = .required
                    view.collisionMode = .none
                } else {
                    // Normal nodes: more visible as you zoom in
                    switch span.latitudeDelta {
                    case ..<0.005:
                        // really close in → show everything
                        view.displayPriority = .required
                        view.collisionMode = .none
                    case 0.005..<0.02:
                        // mid-zoom → moderate density
                        view.displayPriority = .defaultHigh
                        view.collisionMode    = .circle
                    default:
                        // zoomed way out → thin them out
                        view.displayPriority = .defaultLow
                        view.collisionMode    = .circle
                    }
                }
                view.canShowCallout = false
                view.clusteringIdentifier = nil
                
                return view
            }
            
            // Stations
            if let station = annotation as? StationAnnotation {
                // Define separate IDs for each station on the map
                let id = "Station-\(station.title ?? "")"
                let view = mapView.dequeueReusableAnnotationView(withIdentifier: id)
                  ?? MKAnnotationView(annotation: station, reuseIdentifier: id)
                view.annotation = station
                
                // Clear old badge from the map
                view.subviews.forEach { $0.removeFromSuperview() }
                
                // Create and add current badge
                let badge = makeStationBadge(for: station)
                view.frame = badge.frame
                view.addSubview(badge)
                view.canShowCallout = false
                
                return view
            }
            
            // Sites
            if let siteAnnotation = annotation as? MKPointAnnotation,
               let title = siteAnnotation.title
            {
                let id = "Site-\(title)"
                let view = mapView.dequeueReusableAnnotationView(withIdentifier: id)
                         ?? MKAnnotationView(annotation: siteAnnotation, reuseIdentifier: id)

                // Reset site annotations
                view.annotation = siteAnnotation
                view.subviews.forEach { $0.removeFromSuperview() }

                // Set constants
                let imageSize: CGFloat = 40
                let verticalPadding: CGFloat = -6

                // Create imageView
                let imageView = UIImageView(image: siteAnnotationImage)
                imageView.contentMode = .scaleAspectFit
                imageView.frame = CGRect(origin: .zero,
                                         size: CGSize(width: imageSize, height: imageSize))

                // Create label
                let label = UILabel()
                label.text = title
                label.font = UIFont.systemFont(ofSize: 11)
                label.textColor = .white
                label.sizeToFit()   // now label.frame.size is its intrinsic size

                // Set container size: width = max(imageWidth, labelWidth)
                let containerWidth = max(imageSize, label.frame.width)
                let containerHeight = imageSize + verticalPadding + label.frame.height

                // Position subviews in container
                let container = UIView(frame: CGRect(x: 0, y: 0,
                                                     width: containerWidth,
                                                     height: containerHeight))
                container.backgroundColor = .clear

                // Center image horizontally at top
                imageView.frame.origin = CGPoint(
                    x: (containerWidth - imageSize) / 2,
                    y: 0
                )

                // Place label centered below image
                label.frame.origin = CGPoint(
                    x: (containerWidth - label.frame.width) / 2,
                    y: imageSize + verticalPadding
                )

                // Assemble
                container.addSubview(imageView)
                container.addSubview(label)
                view.addSubview(container)

                // Size the annotation view and offset so pin tip is anchored
                view.frame = container.frame
                view.centerOffset = CGPoint(x: 0, y: -containerHeight/2)

                view.canShowCallout = false
                view.clusteringIdentifier = nil

                return view
            }
            
            // Not a recognized annotation type
            return nil
        }
        
        private func makeStationBadge(for station: StationAnnotation) -> UIView {
            let horizPadding: CGFloat = 5
            let vertPadding: CGFloat = 3
            let badge = UIView()
            badge.backgroundColor    = UIColor.black.withAlphaComponent(0.7)
            badge.layer.cornerRadius = 6
            badge.clipsToBounds      = false  // so rotated arrow can draw past its bounds if needed
            
            // Wind speed label
            let speed = Int(station.windSpeed?.rounded() ?? 0)
            let label = UILabel()
            label.text      = "\(speed)"
            label.font      = .systemFont(ofSize: 11, weight: .semibold)
            label.textColor = UIColor(windSpeedColor(windSpeed: speed, siteType: ""))
            label.sizeToFit()
            
            // Arrow container
            let arrowSize = CGSize(width: 11, height: 11)
            let arrow = UIImageView(image: UIImage(systemName: "arrow.up"))
            arrow.tintColor   = .white
            arrow.contentMode = .scaleAspectFit
            
            // Set bounds to keep the logical size constant
            arrow.bounds = CGRect(origin: .zero, size: arrowSize)
            // Reset any old transform before rotating
            arrow.transform = .identity
            if let dir = station.windDirection {
                arrow.transform = CGAffineTransform(rotationAngle: CGFloat((dir - 180) * .pi/180))
            }
            
            // Position both subviews
            label.frame.origin = CGPoint(x: horizPadding, y: vertPadding)
            
            // Place the arrow by center so its bounds don’t change size
            let arrowCenter = CGPoint(
                x: label.frame.maxX + horizPadding + ( arrowSize.width / 2 ),
                y: vertPadding + ( label.frame.height / 2 )
            )
            arrow.center = arrowCenter
            
            // Compute badge size based on unrotated extents
            let badgeWidth  = arrowCenter.x + ( arrowSize.width / 2 ) + horizPadding
            let badgeHeight = max(label.frame.height, arrowSize.height) + ( 2 * vertPadding )
            badge.frame = CGRect(origin: .zero,
                                 size: CGSize(width: badgeWidth,
                                              height: badgeHeight))
            
            // Assemble
            badge.addSubview(label)
            badge.addSubview(arrow)
            return badge
        }
        
        func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {
            guard let annotation = view.annotation else { return }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                switch annotation {
                case let pilot as PilotTrackAnnotation:
                    if let track = pilot.pilotTrack {
                        self.onPilotSelected(track)
                    }
                case let station as StationAnnotation:
                    self.onStationSelected(station)
                case let pin as MKPointAnnotation:
                    // look up the Site by title (or store a map from pin → Site)
                    if let site = self.parent.sites.first(where: { $0.siteName == pin.title }) {
                        self.onSiteSelected(site)
                    }
                default:
                    break
                }
                mapView.deselectAnnotation(annotation, animated: false)
            }
        }
    }
}
        
func getPilotLabelHeightFromMapSpan(span: MKCoordinateSpan) -> CGFloat {
    if span.latitudeDelta < pilotNodeLabelThreeRowSpan {
        return pilotNodeLabelTextThreeRowHeight
    }
    else {
        return pilotNodeLabelTextOneRowHeight
    }
}

struct MapContainerView: View {
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    @Environment(\.scenePhase) private var scenePhase

    @StateObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    @StateObject private var stationAnnotationViewModel: StationAnnotationViewModel
    @StateObject private var rainViewerOverlayViewModel = RainViewerOverlayViewModel()

    @State private var selectedStation: StationAnnotation?
    @State private var selectedPilotTrack: PilotTrack?
    @State private var selectedSite: Site?
    @State private var isLayerSheetPresented = false
    @State private var isPlaying = false
    @State private var animationProgress: Double = 0.0
    @State private var currentTime: String = "00:00"
    @State private var isActive = false
    @State private var refreshWorkItem: DispatchWorkItem?
    @State private var position = MapCameraPosition.region(MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: mapDefaultLatitude, longitude: mapDefaultLongitude),
        span: MKCoordinateSpan(latitudeDelta: mapDefaultLatitudeSpan, longitudeDelta: mapDefaultLongitudeSpan)))
    @State private var lastRegionSpan: MKCoordinateSpan = MKCoordinateSpan(latitudeDelta: 0, longitudeDelta: 0)

    private var cancellables = Set<AnyCancellable>()
    
    init(pilotViewModel: PilotViewModel, siteViewModel: SiteViewModel, userSettingsViewModel: UserSettingsViewModel) {
        let stationVM = StationLatestReadingViewModel(siteViewModel: siteViewModel, userSettingsViewModel: userSettingsViewModel)
        _stationLatestReadingViewModel = StateObject(wrappedValue: stationVM)
        _stationAnnotationViewModel = StateObject(wrappedValue:
            StationAnnotationViewModel(
                userSettingsViewModel: userSettingsViewModel,
                siteViewModel: siteViewModel,
                stationLatestReadingViewModel: stationVM))
    }
    
    var body: some View {
        VStack {
            ZStack {
                
                // Validate annotation coordinates
                let _ = stationAnnotationViewModel.clusteredStationAnnotations.forEach { annotation in
                    assert(annotation.coordinate.latitude >= -90 && annotation.coordinate.latitude <= 90, "Invalid latitude: \(annotation.coordinate.latitude)")
                    assert(annotation.coordinate.longitude >= -180 && annotation.coordinate.longitude <= 180, "Invalid longitude: \(annotation.coordinate.longitude)")
                }
                
                // Get selected pilots (if specified by user)
                let selectedNames = Set(userSettingsViewModel
                                          .selectedPilots
                                          .map(\.pilotName))

                // Get filteredTracks only if map is in tracking mode
                let filteredTracks: [PilotTrack] = {
                  guard userSettingsViewModel.isMapTrackingMode else {
                    return []
                  }
                  // if no one is explicitly selected, show all pilots,
                  // otherwise only the selected ones:
                  return selectedNames.isEmpty
                    ? pilotTrackViewModel.pilotTracks
                    : pilotTrackViewModel.pilotTracks.filter { selectedNames.contains($0.pilotName) }
                }()
                
                // Get data for wind stations if map is in weather mode
                let stations = userSettingsViewModel.isMapWeatherMode
                  ? stationAnnotationViewModel.clusteredStationAnnotations
                  : []

                MapView(
                    mapRegion:          $userSettingsViewModel.mapRegion,
                    zoomLevel:          $userSettingsViewModel.zoomLevel,
                    mapStyle:           $userSettingsViewModel.selectedMapType,  // Standard or hybrid
                    mapDisplayMode:     $userSettingsViewModel.mapDisplayMode,   // Weather or track
                    showRadar:          $userSettingsViewModel.showRadar,
                    showInfrared:       $userSettingsViewModel.showInfrared,
                    showSites:          $userSettingsViewModel.showSites,
                    radarOverlays:      rainViewerOverlayViewModel.radarOverlays,
                    infraredOverlays:   rainViewerOverlayViewModel.infraredOverlays,
                    pilotTracks:        filteredTracks,
                    sites:              siteViewModel.sites,
                    stationAnnotations: stations,
                    onPilotSelected:    { track in selectedPilotTrack = track },
                    onStationSelected:  { station in selectedStation = station },
                    onSiteSelected:     { site in selectedSite = site }
                )
                .cornerRadius(10)
                .padding(.vertical, 8)
                    
                // Floating Item Bar and loading status indicators
                VStack {
                    Spacer()
                    VStack() {
                        
                        if pilotTrackViewModel.isLoading {
                            HStack(spacing: 8) {
                                Spacer()
                                Text("Loading pilot tracks")
                                    .font(.subheadline)
                                    .foregroundStyle(loadingBarTextColor)
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.75)
                                    .padding(.horizontal, 8)
                            }
                            .padding(.vertical, 4)
                        }
                        
                        if stationLatestReadingViewModel.isLoading {
                            HStack(spacing: 8) {
                                Spacer()
                                Text("Loading station latest readings")
                                    .font(.subheadline)
                                    .foregroundStyle(loadingBarTextColor)
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.75)
                                    .padding(.horizontal, 8)
                            }
                            .padding(.vertical, 4)
                        }
                        
                        if rainViewerOverlayViewModel.isLoading {
                            HStack(spacing: 8) {
                                Spacer()
                                Text("Loading radar / satellite data")
                                    .font(.subheadline)
                                    .foregroundStyle(loadingBarTextColor)
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.75)
                                    .padding(.horizontal, 8)
                            }
                            .padding(.vertical, 4)
                        }

                    }
                    .background(loadingBarBackgroundColor.opacity(0.5))
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .padding(.horizontal, 8)

                    HStack(alignment: .bottom) {
                        VStack(alignment: .leading) {
                            Button(action: { isLayerSheetPresented.toggle() }) {
                                VStack {
                                    Image(systemName: layersImage)
                                        .imageScale(.large)
                                        .foregroundStyle(layersIconColor)
                                        .padding(.bottom, 6)
                                    Text("Settings")
                                        .font(.caption)
                                        .foregroundColor(layersTextColor)
                                }
                            }
                            .sheet(isPresented: $isLayerSheetPresented) {
                                MapSettingsView(
                                    selectedMapType:    $userSettingsViewModel.selectedMapType,
                                    pilotTrackDays:     $userSettingsViewModel.pilotTrackDays,
                                    mapDisplayMode:     $userSettingsViewModel.mapDisplayMode,
                                    showSites:          $userSettingsViewModel.showSites,
                                    showStations:       $userSettingsViewModel.showStations,
                                    showRadar:          $userSettingsViewModel.showRadar,
                                    showInfrared:       $userSettingsViewModel.showInfrared,
                                    radarColorScheme:   $userSettingsViewModel.radarColorScheme,
                                    selectedPilots:     $userSettingsViewModel.selectedPilots
                                )
                                .interactiveDismissDisabled(true) // Disables swipe-to-dismiss (force use of back button)\
                                .environmentObject(pilotViewModel)
                                .environmentObject(pilotTrackViewModel)
                                
                            }
                        }
                        .padding()
                        .background(layersIconBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        
                        Spacer()
                        
                        VStack (alignment: .center) {
                            Picker("Display", selection: $userSettingsViewModel.mapDisplayMode) {
                                Text("Weather").tag(MapDisplayMode.weather)
                                Text("Tracking").tag(MapDisplayMode.tracking)
                            }
                            .pickerStyle(SegmentedPickerStyle())
                            .padding(.bottom, 6)
                            Text ("Map Type")
                                .font(.caption)
                                .foregroundColor(layersTextColor)
                        }
                        .padding(.top, 15)
                        .padding(.trailing, 16)
                        .padding(.leading, 16)
                        .padding(.bottom, 12)
                        .background(layersIconBackgroundColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                    }
                    .padding(.horizontal, 8)
                    .padding(.bottom, 16)
                }
            }
            
            .onAppear {
                isActive = true
                startTimer()
                startMonitoringRegion()
                
                if userSettingsViewModel.isMapTrackingMode {
                    // Reload latest pilot tracks
                    DispatchQueue.main.async {
                        pilotTrackViewModel.getPilotTracks(days: userSettingsViewModel.pilotTrackDays,
                                                           selectedPilots: userSettingsViewModel.selectedPilots) {}
                    }
                }
                else if userSettingsViewModel.isMapWeatherMode {
                    // Reload radar overlay
                    if userSettingsViewModel.showRadar {
                        DispatchQueue.main.async {
                            rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                        }
                    }
                    // Reload infrared overlay
                    if userSettingsViewModel.showInfrared {
                        DispatchQueue.main.async {
                            rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                        }
                    }
                    // Reload weather readings
                    DispatchQueue.main.async {
                        stationAnnotationViewModel.userSettingsViewModel = userSettingsViewModel
                        stationAnnotationViewModel.siteViewModel = siteViewModel
                    }
                    DispatchQueue.main.async {
                        stationLatestReadingViewModel.getLatestReadingsData (sitesOnly: false) {
                            stationAnnotationViewModel.stationLatestReadingViewModel = stationLatestReadingViewModel
                            stationAnnotationViewModel.updateStationAnnotations {
                                stationAnnotationViewModel.clusterStationAnnotations(mapRegionSpan: userSettingsViewModel.mapRegion.span)
                            }
                        }
                    }
                }
            }
            
            .onChange(of: MapSettingsState(pilotTrackDays:      userSettingsViewModel.pilotTrackDays,
                                           mapDisplayMode:      userSettingsViewModel.mapDisplayMode,
                                           showSites:           userSettingsViewModel.showSites,
                                           showStations:        userSettingsViewModel.showStations,
                                           showRadar:           userSettingsViewModel.showRadar,
                                           showInfrared:        userSettingsViewModel.showInfrared,
                                           radarColorScheme:    userSettingsViewModel.radarColorScheme,
                                           scenePhase:          scenePhase,
                                           selectedPilots:      userSettingsViewModel.selectedPilots
                                          )) {

                // Check all changes together to only execute updateMapAnnotations once
                if scenePhase == .active {
                    
                    startTimer() // Cancels existing timer and restarts
                    isActive = true
                    startMonitoringRegion()
                    
                    if userSettingsViewModel.isMapTrackingMode {
                        // Reload latest pilot tracks
                        DispatchQueue.main.async {
                            pilotTrackViewModel.getPilotTracks(days: userSettingsViewModel.pilotTrackDays,
                                                               selectedPilots: userSettingsViewModel.selectedPilots) {}
                        }
                    }
                    else if userSettingsViewModel.isMapWeatherMode {
                        // Reload radar overlay
                        if userSettingsViewModel.showRadar {
                            DispatchQueue.main.async {
                                rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                            }
                        }
                        // Reload infrared overlay
                        if userSettingsViewModel.showInfrared {
                            DispatchQueue.main.async {
                                rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                            }
                        }
                        // Reload weather readings
                        DispatchQueue.main.async {
                            stationAnnotationViewModel.userSettingsViewModel = userSettingsViewModel
                            stationAnnotationViewModel.siteViewModel = siteViewModel
                        }
                        DispatchQueue.main.async {
                            stationLatestReadingViewModel.getLatestReadingsData (sitesOnly: false) {
                                stationAnnotationViewModel.stationLatestReadingViewModel = stationLatestReadingViewModel
                                stationAnnotationViewModel.updateStationAnnotations {
                                    stationAnnotationViewModel.clusterStationAnnotations(mapRegionSpan: userSettingsViewModel.mapRegion.span)
                                }
                            }
                        }
                    }
                } else {
                    isActive = false
                }
            }
        }
        
       .onDisappear {
           isActive = false
       }
        
       .sheet(item: $selectedStation) { station in
           let windDirection = SiteWindDirection( N:  "", NE: "", E:  "", SE: "", S:  "", SW: "", W:  "", NW: "" )

           let site = Site(
               id:                  UUID(),
               area:                "",
               siteName:            station.title ?? "",
               readingsNote:        "",
               forecastNote:        "",
               siteType:            "station",
               readingsAlt:         String(Int(station.altitude)),
               readingsSource:      station.readingsSource,
               readingsStation:     station.annotationID,
               pressureZoneReadingTime: "",
               siteLat:             "\(station.coordinate.latitude)",
               siteLon:             "\(station.coordinate.longitude)",
               sheetRow:            0,
               windDirection:       windDirection
           )
           SiteDetailView(site: site, favoriteName: nil)
       }
        
       .sheet(item: $selectedPilotTrack) { track in
           PilotTrackNodeView(originalPilotTrack: track)
       }
        
       .sheet(item: $selectedSite) { site in
           SiteDetailView(site: site, favoriteName: nil)
       }
        
        // Make sure pilot live track view model is published
       .environmentObject(pilotTrackViewModel)
    }
    
    // Timer to reload annotations if page stays active
    private func startTimer() {
        // Cancel any existing timer
        refreshWorkItem?.cancel()
        
        // Create a new work item
        let workItem = DispatchWorkItem {
            if isActive {
                if userSettingsViewModel.isMapTrackingMode {
                    
                    // Reload latest pilot tracks
                    DispatchQueue.main.async {
                        pilotTrackViewModel.getPilotTracks(days: userSettingsViewModel.pilotTrackDays,
                                                           selectedPilots: userSettingsViewModel.selectedPilots) {}
                    }
                }
                else if userSettingsViewModel.isMapWeatherMode {
                    // Reload radar overlay
                    if userSettingsViewModel.showRadar {
                        DispatchQueue.main.async {
                            rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                        }
                    }
                    // Reload infrared overlay
                    if userSettingsViewModel.showInfrared {
                        DispatchQueue.main.async {
                            rainViewerOverlayViewModel.loadOverlays(radarColorScheme: userSettingsViewModel.radarColorScheme)
                        }
                    }
                    // Reload weather readings
                    DispatchQueue.main.async {
                        stationAnnotationViewModel.userSettingsViewModel = userSettingsViewModel
                        stationAnnotationViewModel.siteViewModel = siteViewModel
                    }
                    DispatchQueue.main.async {
                        stationLatestReadingViewModel.getLatestReadingsData (sitesOnly: false) {
                            stationAnnotationViewModel.stationLatestReadingViewModel = stationLatestReadingViewModel
                            stationAnnotationViewModel.updateStationAnnotations {
                                stationAnnotationViewModel.clusterStationAnnotations(mapRegionSpan: userSettingsViewModel.mapRegion.span)
                            }
                        }
                    }
                }
            }
        }
        refreshWorkItem = workItem
        
        // Schedule the new timer
        DispatchQueue.main.asyncAfter(deadline: .now() + readingsRefreshInterval, execute: workItem)
    }
    
    private func startMonitoringRegion() {
        if userSettingsViewModel.isMapTrackingMode {
            // Do nothing; pilot map changes handled elsewhere
        } else {
            Timer.scheduledTimer(withTimeInterval: mapBatchProcessingInterval, repeats: true) { _ in
                let currentSpan = userSettingsViewModel.mapRegion.span
                if hasRegionSpanChanged(from: lastRegionSpan, to: currentSpan) {
                    lastRegionSpan = currentSpan
                    stationAnnotationViewModel.clusterStationAnnotations(mapRegionSpan: currentSpan)
                }
            }
        }
    }
    
    private func hasRegionSpanChanged(from oldSpan: MKCoordinateSpan, to newSpan: MKCoordinateSpan) -> Bool {
        return abs(oldSpan.latitudeDelta - newSpan.latitudeDelta) > mapScaleChangeTolerance ||
        abs(oldSpan.longitudeDelta - newSpan.longitudeDelta) > mapScaleChangeTolerance
    }
}
import SwiftUI
import MapKit
import Combine
import SDWebImage
import SDWebImageSwiftUI

struct UDOTCameraListView: View {
    @StateObject private var camerasViewModel = UDOTCamerasViewModel()
    @State private var mapRegion = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: mapDefaultLatitude, longitude: mapDefaultLongitude),
        span: MKCoordinateSpan(latitudeDelta: mapDefaultLatitudeSpan, longitudeDelta: mapDefaultLongitudeSpan)
    )
    @State private var lastRegionSpan: MKCoordinateSpan = MKCoordinateSpan(latitudeDelta: 0, longitudeDelta: 0)
    @State private var selectedCamera: UDOTCameraData?

    var body: some View {
        NavigationView {
            
            // Validate camera coordinates
            let _ = camerasViewModel.clusteredCameras.forEach { camera in
                assert(camera.latitude >= -90 && camera.latitude <= 90, "Invalid latitude: \(camera.latitude)")
                assert(camera.longitude >= -180 && camera.longitude <= 180, "Invalid longitude: \(camera.longitude)")
            }
            
            Map(coordinateRegion: $mapRegion, annotationItems: camerasViewModel.clusteredCameras) { camera in
                MapAnnotation(coordinate: CLLocationCoordinate2D(latitude: camera.latitude, longitude: camera.longitude)) {
                    Button {
                        selectedCamera = camera
                    } label: {
                        VStack {
                            Image(systemName: cameraAnnotationImage)
                                .foregroundColor(cameraAnnotationColor)
                            Text(camera.location)
                                .font(.footnote)
                                .foregroundColor(cameraAnnotationTextColor)
                        //        .multilineTextAlignment(.center)
                                .frame(width: annotationTextWidth, height: annotationTextHeight)
                        }
                    }
                }
            }
            .cornerRadius(10)
            .padding(.vertical, 8)
            .onAppear {
                camerasViewModel.fetchCameras()
                startMonitoringRegion()
            }
            .sheet(item: $selectedCamera) { camera in
                CameraDetailView(camera: camera)
            }
        }
    }

    private func startMonitoringRegion() {
        Timer.scheduledTimer(withTimeInterval: mapBatchProcessingInterval, repeats: true) { _ in
            let currentSpan = mapRegion.span
            if hasRegionSpanChanged(from: lastRegionSpan, to: currentSpan) {
                lastRegionSpan = currentSpan
                camerasViewModel.updateClusters(mapRegionSpan: currentSpan)
            }
        }
    }

    private func hasRegionSpanChanged(from oldSpan: MKCoordinateSpan, to newSpan: MKCoordinateSpan) -> Bool {
        return abs(oldSpan.latitudeDelta - newSpan.latitudeDelta) > mapScaleChangeTolerance ||
            abs(oldSpan.longitudeDelta - newSpan.longitudeDelta) > mapScaleChangeTolerance
    }
}

struct CameraDetailView: View {
    let camera: UDOTCameraData
    @Environment(\.presentationMode) var presentationMode

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                        Spacer()
                    }
                }
                .padding()
                Spacer()
            }
            .background(toolbarBackgroundColor)
            
            List {

                VStack(alignment: .leading, spacing: 16) {
                    Text("Location: \(camera.location)")
                    Text("Latitude: \(camera.latitude)")
                    Text("Longitude: \(camera.longitude)")
                    if let view = camera.views.first {
                        Text("View ID: \(view.viewId)")
                        HStack {
                            Text("View URL: ")
                            Text (view.viewURL)
                                .foregroundColor(.blue)
                                .onTapGesture {
                                    if let url = URL(string: view.viewURL) {
                                        UIApplication.shared.open(url)
                                    }
                                }
                        }
                        WebImage (url: URL(string: view.viewURL)) { image in
                            image.resizable() // Control layout like SwiftUI.AsyncImage
                            // Must use this modifier or the view will use the image bitmap size
                        } placeholder: {
                            Text("Image not available")
                                .foregroundColor(infoFontColor)
                                .multilineTextAlignment(.center)
                                .frame(maxWidth: .infinity, alignment: .center)
                        }
                        // Supports options and context, like `.delayPlaceholder` to show placeholder only when error
                        .onSuccess { image, data, cacheType in
                            // Success
                            // Note: Data exist only when queried from disk cache or network.
                            // Use `.queryMemoryData` if you really need data
                        }
                        .indicator(.activity) // Activity Indicator
                        .transition(.fade(duration: 0.5)) // Fade Transition with duration
                        .scaledToFit()
                    }
                }
            }
        }
    }
}
import SwiftUI
import Combine
import MapKit

// Full listing of station latest readings used as the source for creating map annotations
// Created based on active layers and refreshed on app navigation or elapsed time
class StationAnnotation: NSObject, MKAnnotation, Identifiable {
    let id = UUID()
    let annotationID: String
    let title: String?
    let coordinate: CLLocationCoordinate2D
    let altitude: Double
    let readingsSource: String
    let windSpeed: Double?
    let windDirection: Double?
    let windGust: Double?

    init(
      annotationID: String,
      annotationName: String,
      coordinate: CLLocationCoordinate2D,
      altitude: Double,
      readingsSource: String,
      windSpeed: Double?,
      windDirection: Double?,
      windGust: Double?
    ) {
      self.annotationID    = annotationID
      self.title           = annotationName
      self.coordinate      = coordinate
      self.altitude        = altitude
      self.readingsSource  = readingsSource
      self.windSpeed       = windSpeed
      self.windDirection   = windDirection
      self.windGust        = windGust
    }
}

class StationAnnotationViewModel: ObservableObject {
    @Published var stationAnnotations: [StationAnnotation] = []
    @Published var clusteredStationAnnotations: [StationAnnotation] = []
    private var cancellables = Set<AnyCancellable>()
    
    var userSettingsViewModel: UserSettingsViewModel
    var siteViewModel: SiteViewModel
    var stationLatestReadingViewModel: StationLatestReadingViewModel

    init(
        userSettingsViewModel: UserSettingsViewModel,
        siteViewModel: SiteViewModel,
        stationLatestReadingViewModel: StationLatestReadingViewModel
    ) {
        self.userSettingsViewModel = userSettingsViewModel
        self.siteViewModel = siteViewModel
        self.stationLatestReadingViewModel = stationLatestReadingViewModel
    }

    
    // Update the annotation source item list based on the active layers.
    func updateStationAnnotations(completion: @escaping () -> Void) {
        
        // Remove all existing station annotations before starting parallel/async processing
        stationAnnotations = []

        // Define dispatch group for async/parallel processing, and will be used later to ensure all have completed
        let stationAnnotationsGroup = DispatchGroup()
        
        if userSettingsViewModel.isMapDisplayingStations {
            stationAnnotationsGroup.enter()
            
            // Define another dispatch group for to ensure station annotations aren't added until prior calls complete
            let readingsGroup = DispatchGroup()
            readingsGroup.enter()
            stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: false) {
                readingsGroup.leave()
            }

            // When all CUASA readings are received, update annotations
            readingsGroup.notify(queue: .main) { [self] in
                // Create annotations for each latest reading
                for reading in stationLatestReadingViewModel.latestAllReadings {
                    if let lat = Double(reading.stationLatitude), let lon = Double(reading.stationLongitude) {
                        let stationAnnotation = StationAnnotation(
                            annotationID: reading.stationID,
                            annotationName: reading.stationName,
                            coordinate: CLLocationCoordinate2D(latitude: lat, longitude: lon),
                            altitude: Double((reading.stationElevation.replacingOccurrences(of: ",", with: ""))) ?? 0.0,
                            readingsSource: reading.readingsSource,
                            windSpeed: reading.windSpeed,
                            windDirection: reading.windDirection,
                            windGust: reading.windGust
                        )
                        stationAnnotations.append(stationAnnotation)
                    }
                }
                stationAnnotationsGroup.leave()
            }
        }
        
        if userSettingsViewModel.isMapTrackingMode {
            // Do nothing; pilot tracks handled separately
        }
        
        stationAnnotationsGroup.notify(queue: .main) {
            completion()
        }
    }
    
    func clusterStationAnnotations(mapRegionSpan: MKCoordinateSpan) {
        let threshold = max(mapRegionSpan.latitudeDelta, mapRegionSpan.longitudeDelta)
                      * mapClusterThresholdFactor
        clusteredStationAnnotations = []

        // Split out CUASA stations so that filtering will prioritize CUASA stations
        // e.g., we want to see the Cove launch CUASA reading over the Mesonet Signal Peak reading
        let cuasaStations = stationAnnotations.filter { $0.readingsSource == "CUASA" }
        let otherStations = stationAnnotations.filter { $0.readingsSource != "CUASA" }

        // Concatenate so CUASA ones get considered first
        let orderedStations = cuasaStations + otherStations

        // Standard clustering loop on the ordered list
        for station in orderedStations {
            // only compare against already‐accepted (clustered) stations
            let isFarEnough = clusteredStationAnnotations.allSatisfy { existing in
                let dLat = existing.coordinate.latitude  - station.coordinate.latitude
                let dLon = existing.coordinate.longitude - station.coordinate.longitude
                let distance = sqrt(dLat * dLat + dLon * dLon)
                return distance > threshold
            }

            if isFarEnough {
                clusteredStationAnnotations.append(station)
            }
        }
    }
}
import Foundation

// Make app URL functions available globally (without injecting view model each time)
// To call, use this format:
//      AppURLManager.shared.getAppURL(URLName: "<URL name to get>")

final class AppURLManager {
    
    static let shared = AppURLManager()
    
    private init() {}
    
    private(set) var appURLs: [AppURL] = []

    func setAppURLs(_ appURLs: [AppURL]) {
        self.appURLs = appURLs
    }

    func getAppURL(URLName: String) -> String? {
        let regionCountry = AppRegionManager.shared.getRegionCountry()

        // Try exact country match
        if let match = appURLs.first(where: {
            $0.appCountry == regionCountry && $0.URLName == URLName
        }) {
            return match.URL
        }

        // Fallback to Global
        return appURLs.first(where: {
            $0.appCountry == "Global" && $0.URLName == URLName
        })?.URL
    }

}
import SwiftUI
import Combine

// Weather Alerts
struct WeatherAlert: Identifiable, Decodable {
    let id = UUID()
    let areaDescription: String?
    let effectiveDate: String?
    let onsetDate: String?
    let endDate: String?
    let status: String?
    let category: String?
    let severity: String?
    let certainty: String?
    let urgency: String?
    let event: String?
    let headline: String?
    let description: String?
    let instruction: String?

    enum CodingKeys: String, CodingKey {
        case areaDescription = "areaDesc"
        case effectiveDate = "effective"
        case onsetDate = "onset"
        case endDate = "ends"
        case status
        case category
        case severity
        case certainty
        case urgency
        case event
        case headline
        case description
        case instruction
    }
}

struct WeatherAlertsResponse: Decodable {
    let features: [Feature]
    
    struct Feature: Decodable {
        let properties: WeatherAlert
    }
}

class WeatherAlertViewModel: ObservableObject {
    @Published var weatherAlerts: [WeatherAlert] = []
    @Published var isLoading = false
    
    func getWeatherAlerts() {
        isLoading = true

        guard let baseURL = AppURLManager.shared.getAppURL(URLName: "weatherAlertsURL") else {
            print("Could not find weather alerts URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }

        let updatedURL = updateURL(url: baseURL, parameter: "appregion", value: RegionManager.shared.activeAppRegion)

        guard let url = URL(string: updatedURL) else {
            print("Invalid weather alerts URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }

        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                print("Weather alerts request failed: \(error.localizedDescription)")
                DispatchQueue.main.async { self.isLoading = false }
                return
            }

            guard let data = data else {
                print("No data received in weather alerts response")
                DispatchQueue.main.async { self.isLoading = false }
                return
            }
            self.parseWeatherAlertsData(data: data)

        }.resume()
    }
    
    private func parseWeatherAlertsData(data: Data) {
        do {
            let decodedResponse = try JSONDecoder().decode(WeatherAlertsResponse.self, from: data)
            DispatchQueue.main.async {
                self.weatherAlerts = decodedResponse.features.map { $0.properties }
                self.isLoading = false
            }
        } catch {
            print("Error decoding weather alerts JSON: \(error)")
            DispatchQueue.main.async { self.isLoading = false }
        }
    }
    
}
import SwiftUI
import Combine
import Foundation
import MapKit

// Set development build flags
let devMenuAvailable: Bool          = false
let logThermalCalcs: Bool           = false
let printReadingsURL: Bool          = false
let printForecastURL: Bool          = false
let printPilotTracksTimings: Bool   = false
let printPilotTrackURLs: Bool       = false
let printFunctionCallSource: Bool   = false         /* Need to put logic at top of function being called to see output:
                                                    if printFunctionCallSource { Thread.callStackSymbols.forEach { print($0) } }
                                                    */

// Get API keys and tokens from .xcconfig file (need to be mapped in .plist)
let googleAPIKey        = Bundle.main.object(forInfoDictionaryKey:              "GoogleSheetsAPIKey") as? String ?? ""
let synopticsAPIToken   = "&token=\(Bundle.main.object(forInfoDictionaryKey:    "SynopticsAPIToken" ) as? String ?? "")"
let UDOTCamerasAPIKey   = Bundle.main.object(forInfoDictionaryKey:              "UDOTCamerasAPIKey" ) as? String ?? ""
let RMHPAAPIKey         = Bundle.main.object(forInfoDictionaryKey:              "RMHPAAPIKey"       ) as? String ?? ""

// Cloudbase Project link info
let cloudbaseProjectEmail: String           = "CloudbaseProjectApp@gmail.com"
let cloudbaseProjectGitLink: String         = "https://github.com/CloudbaseProjectApp/CloudbaseProject"
let cloudbaseProjectGitIssueLink: String    = "https://github.com/CloudbaseProjectApp/CloudbaseProject/issues/new"
let cloudbaseProjectTelegramLink: String    = "https://t.me/+bSHu5KTsRkU1M2Mx"

// HTTP links and APIs
let globalGoogleSheetID     = "18EU5k34_nhOa7Qv_SA5oMeEWpD00pWDHiAC0Nh7vUho"
let uDOTCamerasAPI: String  = "https://www.udottraffic.utah.gov/api/v2/get/cameras?key=\(UDOTCamerasAPIKey)&format=json"
let uDOTCamerasLink: String = "https://www.udottraffic.utah.gov"
let ipCamLink: String       = "https://apps.apple.com/us/app/ip-camera-viewer-ipcams/id1045600272"
let UHGPGAcamsLink: String  = "https://www.uhgpga.org/webcams"

// App parameters
let toolbarItemSize: CGFloat                    = 14        // Height and width of toolbar icon frames
let skewTButtonWidth: CGFloat                   = 100
let defaultTopOfLiftAltitude                    = 18000.0   // Use in lift area graph when top of lift isn't reached in calculations
let defaultMaxPressureReading: Int              = 1000      // Pressure to start displaying winds aloft (1000 hpa is sea level)
let readingsRefreshInterval: TimeInterval       = 120       // Time in seconds to refresh wind readings (300 for 5 min)
let pilotTrackRefreshInterval: TimeInterval     = 600       // Setting refresh to 10 min to prevent timeout errors on frequent refreshes
let forecastCacheInterval: TimeInterval         = 600       // 10 minute refresh interval for each site hourly forecast

// Map parameters
let mapDefaultLatitude: Double                  = 39.72     // Should not be displayed; will update based on region selected
let mapDefaultLongitude: Double                 = -111.45   // Should not be displayed; will update based on region selected
let mapDefaultLatitudeSpan: Double              = 7.2       // Should not be displayed; will update based on region selected
let mapDefaultLongitudeSpan: Double             = 5.2       // Should not be displayed; will update based on region selected
let mapDefaultZoomLevel: Double                 = 6.7       // Should not be displayed; will update based on region selected
let mapBatchProcessingInterval: Double          = 0.2
let mapScaleChangeTolerance: Double             = 0.01      // Don't refresh annotation filtering for minor scale changes
let mapEnableRotate: Bool                       = false
let mapEnablePitch: Bool                        = false

// Map annotation parameters
let mapShowAllMarkersZoomLevel: Double          = 10.0
let mapPilotArrowDefaultSize: Double            = 15
let mapPilotAnnotationZoomFactor: Double        = 0.9       // Drives sizing of pilot node annotation based on zoom level
let mapPilotTrackWidth: CGFloat                 = 2
let stationSpacingBaseThreshold: Double         = 0.01      // Larger number will reduce the number of stations displayed
let stationSpacingZoomFactor: Double            = 700       // Larger number will reduce number of stations displayed
let annotationDuplicateTolerance                = 0.0001
let mapClusterThresholdFactor                   = 0.1       // Initial value was 0.1
let annotationTextWidth: CGFloat                = 60
let annotationTextHeight: CGFloat               = 4
let stationAnnotationWidth: CGFloat             = 40
let stationAnnotationHeight: CGFloat            = 22
let defaultAnnotationImageWidth: CGFloat        = 50
let pilotNodeAnnotationImageWidth: CGFloat      = 20
let pilotLaunchAnnotationImageWidth: CGFloat    = 40
let pilotLatestAnnotationImageWidth: CGFloat    = 40
let pilotNodeLabelTextWidth: CGFloat            = 56
let pilotNodeLabelTextOneRowHeight: CGFloat     = 16
let pilotNodeLabelTextThreeRowHeight: CGFloat   = pilotNodeLabelTextOneRowHeight * 3
let pilotNodeLabelThreeRowSpan: CGFloat         = 0.2       // Map scale that determines when to display time/altitude for each node

// Map default settings
let defaultPilotTrackDays: Double               = 1.0       // Default days of live tracking to display
let defaultmapDisplayMode: MapDisplayMode       = .weather
let defaultmapType: CustomMapStyle              = .standard
let defaultShowSites: Bool                      = false
let defaultShowStations: Bool                   = true
let defaultShowRadar: Bool                      = true
let defaultShowInfrared: Bool                   = true
let defaultRadarColorScheme: Int                = 3
    /* Rainviewer radar color scheme options are:
    0        BW Black and White: dBZ values
    1        Original (green -> blue)  for increasing precip)
    2        Universal Blue (blue -> yellow -> red for increasing precip)  **
    3        TITAN (green -> blue -> purple -> magenta -> orange -> yellow for increasing precip)  **
    4        The Weather Channel (TWC) (green -> yellow for increasing precip) *
    5        Meteored (blue -> green -> yellow for increasing precip) *
    6        NEXRAD Level III (blue -> green -> yellow -> red for increasing precip) *
    7        Rainbow @ SELEX-IS (green -> yellow -> red for increasing precip)  **
    8        Dark Sky ((deep blue -> red -> yellow for increasing precip)  **
    */

// Grid structure sizing parameters
let headingHeight: CGFloat                      = 16        // Day, date, time rows
let imageHeight: CGFloat                        = 38        // Weather skies image
let dataHeight: CGFloat                         = 22
let labelHeight: CGFloat                        = 22        // Wind, Lift label rows
let doubleHeight: CGFloat                       = dataHeight * 2    // Surface wind + gust combined
var areaChartHeight: CGFloat                    = 0         // ToL area chart height calculated below
let areaChartPaddingHeight: CGFloat             = 0         // Adjustment to reflect spacing between table rows
let imageScalingFactor: CGFloat                 = 0.5       // Weather skies image
let windArrowSpacing: CGFloat                   = 3         // Space between wind speed and direction arrow
let dateChangeDividerSize: CGFloat              = 1
let areaChartOpacity: CGFloat                   = 0.5
import SwiftUI
import Combine

// Note:  Use the globally available function calls in AppURLManager to access data

struct AppURL {
    let appCountry: String                  // Country code or "Global"
    let URLName: String
    let URL: String
}

struct AppURLResponse: Codable {
    let values: [[String]]
}

class AppURLViewModel: ObservableObject {
    @Published var appURLs: [AppURL] = []
    private var cancellables = Set<AnyCancellable>()
    let sheetName = "URLs"
    
    func getAppURLs(completion: @escaping () -> Void) {
        let appURLsURLString = "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(sheetName)?alt=json&key=\(googleAPIKey)"
        guard let url = URL(string: appURLsURLString) else {
            print("Invalid URL for app URLs metadata")
            DispatchQueue.main.async { completion() }
            return
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: AppURLResponse.self, decoder: JSONDecoder())
        
            .map { response -> [AppURL] in
                response.values.dropFirst().compactMap { row in
                    guard row.count >= 3 else {
                        print("Skipping malformed app URL metadata row: \(row)")
                        return nil
                    }
                    let appCountry = row[0]
                    let URLName = row[1]
                    let URL = row[2]
                    
                    // Make sure URL name and URL are populated
                    guard !URLName.isEmpty,
                          !URL.isEmpty else {
                        print("Skipping app URL metadata row with missing critical fields: \(row)")
                        return nil
                    }
                    
                    return AppURL(appCountry: appCountry,
                                  URLName: URLName,
                                  URL: URL
                    )
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)

            // Save URLs globally so they can be accessed from anywhere in the app
            .handleEvents(receiveOutput: { [weak self] appURLs in
                self?.appURLs = appURLs
                AppURLManager.shared.setAppURLs(appURLs) // global set
            }, receiveCompletion: { _ in
                completion()
            })
        
            .sink { _ in }
            .store(in: &cancellables)
    }
    
}
import SwiftUI
import Combine

struct WindsAloftReading {
    let altitude: Int
    let windDirection: Int?
    let windSpeed: Int?
    let temperature: Int?
}

// Winds Aloft forecast
class WindsAloftViewModel: ObservableObject {
    @Published var readings: [WindsAloftReading] = []
    @Published var cycle: String = ""
    @Published var isLoading = false
        
    func getWindsAloftData(airportCode: String) {
        isLoading = true

        // Get base URL, update parameters, and format into URL format
        guard let baseURL = AppURLManager.shared.getAppURL(URLName: "windsAloftURL")
        else {
            print("Could not find winds aloft URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        let cycle = windsAloftCycle()
        self.cycle = cycle
        let updatedURL = updateURL(url: baseURL, parameter: "cycle", value: cycle)
        
        // Format URL
        guard let URL = URL(string: updatedURL)
        else {
            print("Invalid winds aloft URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        
        // Process URL query
        let task = URLSession.shared.dataTask(with: URL) { data, response, error in
            guard let data = data, error == nil else {
                print("URL response error for: \(RegionManager.shared.activeAppRegion); error: \(error ?? NSError())")
                DispatchQueue.main.async { self.isLoading = false }
                return
            }
            if let responseString = String(data: data, encoding: .utf8) {
                self.parseWindsAloftData(code: airportCode,
                                        data: responseString)
            }
        }
        task.resume()
    }
    
    private func parseWindsAloftData(code: String, data: String) {
        let lines = data.split(separator: "\n")
        guard let regionLine = lines.first(where: { $0.starts(with: code) }) else {
            print("Could not find a matching row for code: \(code)")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }

        // Fixed-width column offsets (based on space-separated but fixed-length layout)
        // PHX[0–2]      - Station code
        // <space>[3]
        // 3000[4–7]     - Skip
        // <space>[8]
        // 6000[9–15]    - needed
        // <space>[16]
        // 9000[17–23]   - needed
        // <space>[24]
        // 12000[25–31]  - needed
        // <space>[32]
        // 18000[33–39]  - needed
        // <space>[40]
        // Additional levels can be ignored

        let offsets: [(altitude: Int, range: Range<Int>)] = [
            (6000, 9..<16),
            (9000, 17..<24),
            (12000, 25..<32),
            (18000, 33..<40)
        ]

        var newReadings: [WindsAloftReading] = []

        for (altitude, range) in offsets {
            if range.upperBound <= regionLine.count {
                let start = regionLine.index(regionLine.startIndex, offsetBy: range.lowerBound)
                let end = regionLine.index(regionLine.startIndex, offsetBy: range.upperBound)
                let substring = regionLine[start..<end].trimmingCharacters(in: .whitespaces)

                if !substring.isEmpty, let parsedReading = parseReading(substring, altitude: altitude) {
                    newReadings.append(parsedReading)
                }
            }
        }

        DispatchQueue.main.async {
            self.isLoading = false
            self.readings = newReadings.reversed()
        }
    }
    
    private func parseReading(_ reading: String, altitude: Int) -> WindsAloftReading? {
        guard reading.count >= 4 else { return nil }

        // Parse wind direction
        let windDirSource = reading.prefix(2)
        var windDirection: Int? = (windDirSource == "  ") ? nil : 10 * (Int(windDirSource) ?? 0)

        // Parse wind speed
        let windSpeedSource = reading.dropFirst(2).prefix(2)
        var windSpeedKnots: Int? = (windSpeedSource == "  ") ? nil : (Int(windSpeedSource) ?? 0)
        
        // Check for wind greater than 100 knots, which is indicated by adding 500 degrees to the wind direction
        // (anything greater than 199 knots is indicated as 199 knots)
        // Ignore 990, which indicated light and variable winds
        if let direction = windDirection, direction > 360 && direction < 990 {
            windDirection = direction - 360
            windSpeedKnots = (windSpeedKnots ?? 0) + 100
        }
        
        // Convert wind speed to mph
        let windSpeed: Int? = (windSpeedSource == "  ") ? nil : convertKnotsToMPH(windSpeedKnots ?? 0)
        
        // Convert wind direction to arrow direction (offset by 180 degrees)
        if let direction = windDirection {
            windDirection = (direction + 180) % 360
        }
        
        // Parse temperature, convert to F, and return results
        var temperature: Int? = nil
        if reading.count > 4 {
            let tempString = reading.dropFirst(4)
            if let tempValue = Int(tempString) {
                temperature = Int(tempValue)
            }
        }
        if let tempCelsius = temperature {
            let tempFahrenheit = convertCelsiusToFahrenheit(Int(tempCelsius))
            return WindsAloftReading(altitude: altitude, windDirection: windDirection, windSpeed: windSpeed, temperature: tempFahrenheit)
        } else {
            return WindsAloftReading(altitude: altitude, windDirection: windDirection, windSpeed: windSpeed, temperature: nil)
        }
    }
}
import SwiftUI
import Combine

struct LinkGoogleSheetResponse: Codable {
    let range: String
    let majorDimension: String
    let values: [[String]]
}

struct LinkItem: Identifiable {
    let id = UUID()
    let category: String
    let title: String
    let description: String
    let link: String
}

class LinkViewModel: ObservableObject {
    @Published var groupedLinks: [String: [LinkItem]] = [:]
    @Published var orderedGroupNames: [String] = []
    @Published var isLoading = false

    private var cancellable: AnyCancellable?

    func fetchLinks() {
        isLoading = true
        let linksRange = "Links"

        guard let globalLinksURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(linksRange)?alt=json&key=\(googleAPIKey)"),
              let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
              let regionLinksURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(linksRange)?alt=json&key=\(googleAPIKey)") else {
            print("Invalid sheet URLs")
            isLoading = false
            return
        }

        let globalPublisher = fetchAndParseLinks(from: globalLinksURL)
        let regionPublisher = fetchAndParseLinks(from: regionLinksURL)

        // Step 1: Fetch LinkGroups first
        fetchLinkGroupOrder { [weak self] groupOrder in
            guard let self = self else { return }

            self.orderedGroupNames = groupOrder

            // Step 2: Fetch links concurrently
            self.cancellable = Publishers.CombineLatest(globalPublisher, regionPublisher)
                .map { global, region -> [String: [LinkItem]] in
                    var combined = global
                    for (category, items) in region {
                        combined[category, default: []] += items
                    }
                    return combined
                }
                .receive(on: DispatchQueue.main)
                .sink { [weak self] combinedLinks in
                    self?.groupedLinks = combinedLinks
                    self?.isLoading = false
                }
        }
    }

    // Parses a given link sheet into [Category: [LinkItem]]
    private func fetchAndParseLinks(from url: URL) -> AnyPublisher<[String: [LinkItem]], Never> {
        URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: LinkGoogleSheetResponse.self, decoder: JSONDecoder())
            .map { response in
                let dataRows = response.values.dropFirst()
                let linkItems = dataRows.compactMap { row -> LinkItem? in
                    guard row.count >= 4,
                          !row[3].trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
                    else { return nil }
                    return LinkItem(
                        category: row[0],
                        title: row[1],
                        description: row[2],
                        link: row[3]
                    )
                }
                return Dictionary(grouping: linkItems, by: \.category)
            }
            .replaceError(with: [:])
            .eraseToAnyPublisher()
    }

    // Fetch group names in display order from LinkGroups!A2:A
    private func fetchLinkGroupOrder(completion: @escaping ([String]) -> Void) {
        let rangeName = "Validations!A2:A"

        guard let url = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)") else {
            print("Invalid LinkGroups URL")
            DispatchQueue.main.async {
                completion([])
            }
            return
        }

        URLSession.shared.dataTask(with: url) { data, _, _ in
            guard let data = data,
                  let response = try? JSONDecoder().decode(LinkGoogleSheetResponse.self, from: data) else {
                print("Failed to fetch LinkGroups")
                DispatchQueue.main.async {
                    completion([])
                }
                return
            }

            let groupOrder = response.values.compactMap { $0.first?.trimmingCharacters(in: .whitespacesAndNewlines) }

            // Ensure this runs on the main thread
            DispatchQueue.main.async {
                completion(groupOrder)
            }
        }.resume()
    }
    
    func sortedGroupedLinks() -> [(String, [LinkItem])] {
        let existing = groupedLinks
        let sorted: [(String, [LinkItem])] = orderedGroupNames.compactMap { name -> (String, [LinkItem])? in
            guard let items = existing[name] else { return nil }
            return (name, items)
        }
        return sorted
    }
}
import SwiftUI
import Combine
import MapKit

enum MapDisplayMode: String, Codable {
    case weather
    case tracking
}

// Custom Map Style
enum CustomMapStyle: String, Codable, CaseIterable {
    case standard, hybrid

    // Conversion to Maptype (for MKMapView)
    func toMapType() -> MKMapType {
        switch self {
        case .standard:
            return .standard
        case .hybrid:
            return .hybrid
        }
    }
}

struct UserFavoriteSite: Identifiable, Codable, Equatable {
    var id: String { "\(appRegion)-\(favoriteType)-\(favoriteID)" }
    let appRegion: String
    let favoriteType: String    // "station" or "site"
    let favoriteID: String      // site name or station name
    var favoriteName: String    // User specified
    let readingsSource: String  // for stations only (used to build mock site for favorites)
    let stationID: String       // for stations only
    let readingsAlt: String     // for stations only
    let siteLat: String         // for stations only
    let siteLon: String         // for stations only
    var sortSequence: Int       // allows user to re-sort favorites
    
}

struct UserPickListSelection: Identifiable, Codable, Equatable {
    var id: String { "\(appRegion)-\(pickListName)" }
    var appRegion: String
    var pickListName: String
    var selectedIndex: Int?
}

class UserSettingsViewModel: ObservableObject {
    @Published var mapRegion: MKCoordinateRegion
    @Published var zoomLevel: Double
    @Published var selectedMapType: CustomMapStyle
    @Published var pilotTrackDays: Double
    @Published var mapDisplayMode: MapDisplayMode
    @Published var showSites: Bool
    @Published var showStations: Bool
    @Published var showRadar: Bool
    @Published var showInfrared: Bool
    @Published var radarColorScheme: Int
    @Published var selectedPilots: [Pilot]
    @Published var userFavoriteSites: [UserFavoriteSite]
    @Published var userPickListSelections: [UserPickListSelection]
    
    init(mapRegion:                 MKCoordinateRegion,
         zoomLevel:                 Double = 6,
         selectedMapType:           CustomMapStyle = defaultmapType,
         pilotTrackDays:            Double = defaultPilotTrackDays,
         mapDisplayMode:            MapDisplayMode = defaultmapDisplayMode,
         showSites:                 Bool = defaultShowSites,
         showStations:              Bool = defaultShowStations,
         showRadar:                 Bool = defaultShowRadar,
         showInfrared:              Bool = defaultShowInfrared,
         radarColorSchme:           Int = defaultRadarColorScheme,
         selectedPilots:            [Pilot] = [],
         userFavoriteSites:         [UserFavoriteSite] = [],
         userPickListSelections:    [UserPickListSelection] = []
    ) {
        self.mapRegion              = mapRegion
        self.zoomLevel              = zoomLevel
        self.selectedMapType        = selectedMapType
        self.pilotTrackDays         = pilotTrackDays
        self.mapDisplayMode         = mapDisplayMode
        self.showSites              = showSites
        self.showStations           = showStations
        self.showRadar              = showRadar
        self.showInfrared           = showInfrared
        self.radarColorScheme       = radarColorSchme
        self.selectedPilots         = selectedPilots
        self.userFavoriteSites      = userFavoriteSites
        self.userPickListSelections = userPickListSelections
    }
    
    var isMapWeatherMode:           Bool { mapDisplayMode == .weather }
    var isMapTrackingMode:          Bool { mapDisplayMode == .tracking }
    var isMapDisplayingSites:       Bool { mapDisplayMode == .weather && showSites }
    var isMapDisplayingStations:    Bool { mapDisplayMode == .weather && showStations }
    var isMapDisplayingRadar:       Bool { mapDisplayMode == .weather && showRadar }
    var isMapDisplayingInfrared:    Bool { mapDisplayMode == .weather && showInfrared }
    
    // Persistent storage
    private let storageKey = "UserSettings"
    private struct PersistedSettings: Codable {
        let centerLatitude:         Double
        let centerLongitude:        Double
        let spanLatitude:           Double
        let spanLongitude:          Double
        let zoomLevel:              Double
        let selectedMapType:        CustomMapStyle.RawValue
        let pilotTrackDays:         Double
        let mapDisplayMode:         MapDisplayMode.RawValue
        let showSites:              Bool
        let showStations:           Bool
        let showRadar:              Bool
        let showInfrared:           Bool
        let radarColorScheme:       Int
        let selectedPilots:         [Pilot]
        let userFavoriteSites:      [UserFavoriteSite]
        let userPickListSelections: [UserPickListSelection]
    }
    
    // Functions to manage favorites
    enum FavoriteSiteError: Error, LocalizedError {
        case alreadyExists
        case notFound
        
        var errorDescription: String? {
            switch self {
            case .alreadyExists: return "Favorite already exists."
            case .notFound: return "Favorite not found."
            }
        }
    }
    
    func isDuplicateFavorite(
        favoriteType: String,
        favoriteID: String,
        appRegion: String
    ) -> Bool {
        userFavoriteSites.contains {
            $0.favoriteType == favoriteType &&
            $0.favoriteID == favoriteID &&
            $0.appRegion == appRegion
        }
    }
    
    func addFavorite(
        favoriteType: String,
        favoriteID: String,
        favoriteName: String,
        readingsSource: String,
        stationID: String,
        readingsAlt: String,
        siteLat: String,
        siteLon: String
    ) throws {
        
        // Check for duplicates
        let region = RegionManager.shared.activeAppRegion
        if isDuplicateFavorite(favoriteType: favoriteType, favoriteID: favoriteID, appRegion: region) {
            throw FavoriteSiteError.alreadyExists
        }
        
        // Compute the next sortSequence
        let nextSequence = (userFavoriteSites.map { $0.sortSequence }.max() ?? 0) + 1
        
        // Build and append the new favorite
        let newFavorite = UserFavoriteSite(
            appRegion:      RegionManager.shared.activeAppRegion,
            favoriteType:   favoriteType,
            favoriteID:     favoriteID,
            favoriteName:   favoriteName,
            readingsSource: readingsSource,
            stationID:      stationID,
            readingsAlt:    readingsAlt,
            siteLat:        siteLat,
            siteLon:        siteLon,
            sortSequence:   nextSequence
        )
        userFavoriteSites.append(newFavorite)
    }
    
    func removeFavorite(favoriteType: String, favoriteID: String) throws {
        let region = RegionManager.shared.activeAppRegion
        let favoriteKey = "\(region)-\(favoriteType)-\(favoriteID)"

        guard let index = userFavoriteSites.firstIndex(where: {
            $0.id == favoriteKey
        }) else {
            throw FavoriteSiteError.notFound
        }

        userFavoriteSites.remove(at: index)
    }
    
    func updatePickListSelection(pickListName: String, selectedIndex: Int) {
        let currentRegion = RegionManager.shared.activeAppRegion

        if let index = userPickListSelections.firstIndex(where: {
            $0.appRegion == currentRegion && $0.pickListName == pickListName
        }) {
            // Update existing selection
            userPickListSelections[index].selectedIndex = selectedIndex
        } else {
            // Create and append a new selection
            let newSelection = UserPickListSelection(
                appRegion: currentRegion,
                pickListName: pickListName,
                selectedIndex: selectedIndex
            )
            userPickListSelections.append(newSelection)
        }
    }
    
    func getPickListSelection(pickListName: String) -> Int {
        let currentRegion = RegionManager.shared.activeAppRegion
        if let selection = userPickListSelections.first(where: {
            $0.appRegion == currentRegion && $0.pickListName == pickListName
        }), let index = selection.selectedIndex {
            return index
        }
        return 0
    }
}

// Composite structure to check for all map settings and view changes together
// and only rebuild annotations once if there are multiple changes
struct MapSettingsState: Equatable {
    let pilotTrackDays: Double
    let mapDisplayMode: MapDisplayMode
    let showSites: Bool
    let showStations: Bool
    let showRadar: Bool
    let showInfrared: Bool
    let radarColorScheme: Int
    let scenePhase: ScenePhase
    let selectedPilots: [Pilot]
}

// Functions to handle persistent storage
extension UserSettingsViewModel {
    
    // Call this once on launch
    func loadFromStorage() {
        let defaults = UserDefaults.standard
        guard
            let data = defaults.data(forKey: storageKey),
            let stored = try? JSONDecoder().decode(PersistedSettings.self, from: data)
        else {
            return
        }
        
        // Apply loaded values back into @Published properties
        mapRegion = MKCoordinateRegion(
            center: CLLocationCoordinate2D(
                latitude: stored.centerLatitude,
                longitude: stored.centerLongitude
            ),
            span: MKCoordinateSpan(
                latitudeDelta: stored.spanLatitude,
                longitudeDelta: stored.spanLongitude
            )
        )
        zoomLevel               = stored.zoomLevel
        selectedMapType         = CustomMapStyle(rawValue: stored.selectedMapType) ?? selectedMapType
        pilotTrackDays          = stored.pilotTrackDays
        mapDisplayMode          = MapDisplayMode(rawValue: stored.mapDisplayMode) ?? mapDisplayMode
        showSites               = stored.showSites
        showStations            = stored.showStations
        showRadar               = stored.showRadar
        showInfrared            = stored.showInfrared
        radarColorScheme        = stored.radarColorScheme
        selectedPilots          = stored.selectedPilots
        userFavoriteSites       = stored.userFavoriteSites
        userPickListSelections  = stored.userPickListSelections
    }
    
    // Call this to store persistence (e.g. on background/inactive)
    func saveToStorage() {
        let settings = PersistedSettings(
            centerLatitude:         mapRegion.center.latitude,
            centerLongitude:        mapRegion.center.longitude,
            spanLatitude:           mapRegion.span.latitudeDelta,
            spanLongitude:          mapRegion.span.longitudeDelta,
            zoomLevel:              zoomLevel,
            selectedMapType:        selectedMapType.rawValue,
            pilotTrackDays:         pilotTrackDays,
            mapDisplayMode:         mapDisplayMode.rawValue,
            showSites:              showSites,
            showStations:           showStations,
            showRadar:              showRadar,
            showInfrared:           showInfrared,
            radarColorScheme:       radarColorScheme,
            selectedPilots:         selectedPilots,
            userFavoriteSites:      userFavoriteSites,
            userPickListSelections: userPickListSelections
        )
        
        if let data = try? JSONEncoder().encode(settings) {
            UserDefaults.standard.set(data, forKey: storageKey)
        }
    }
    
    // Reset to app defaults (clear local storage and in-memory settings)
    func clearUserSettings(completion: @escaping () -> Void) {

        // Remove from local storage
        UserDefaults.standard.removeObject(forKey: storageKey)

        // Remove from memory
        mapRegion          = MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: mapDefaultLatitude, longitude: mapDefaultLongitude),
            span: MKCoordinateSpan(latitudeDelta: mapDefaultLatitudeSpan, longitudeDelta: mapDefaultLongitudeSpan)
        )
        zoomLevel               = mapDefaultZoomLevel
        selectedMapType         = defaultmapType
        pilotTrackDays          = defaultPilotTrackDays
        mapDisplayMode          = defaultmapDisplayMode
        showSites               = defaultShowSites
        showStations            = defaultShowStations
        showRadar               = defaultShowRadar
        showInfrared            = defaultShowInfrared
        radarColorScheme        = defaultRadarColorScheme
        selectedPilots          = []
        userFavoriteSites       = []
        userPickListSelections  = []
        
        completion()
    }
}
import Foundation

// appRegion functions are available globally (without injecting view model each time)
// To call these functions, use this format:
//      AppRegionManager.shared.getRegionCountry()

final class AppRegionManager {
    static let shared = AppRegionManager()
    
    private init() {}
    
    private(set) var appRegions: [AppRegion] = []
    
    func setAppRegions(_ regions: [AppRegion]) {
        self.appRegions = regions
    }
    
    func getRegionName() -> String? {
        appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion })?.appRegionName
    }
    
    func getRegionGoogleSheet() -> String? {
        appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion })?.appRegionGoogleSheetID
    }
    
    func getRegionCountry() -> String? {
        appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion })?.appCountry
    }
    
    func getRegionEncodedTimezone() -> String? {
        guard let timezone = appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion })?.timezone else { return nil }
        var allowed = CharacterSet.urlQueryAllowed
        allowed.remove(charactersIn: "/")
        return timezone.addingPercentEncoding(withAllowedCharacters: allowed)
    }
    
    func getRegionSunriseCoordinates() -> (latitude: Double, longitude: Double)? {
        guard let region = appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion }) else { return nil }
        return (region.sunriseLatitude, region.sunriseLongitude)
    }
    
    func getRegionMapDefaults() -> (mapInitLatitude: Double,
                                    mapInitLongitude: Double,
                                    mapInitLatitudeSpan: Double,
                                    mapInitLongitudeSpan: Double,
                                    mapDefaultZoomLevel: Double)? {
        guard let region = appRegions.first(where: { $0.appRegion == RegionManager.shared.activeAppRegion }) else { return nil }
        return (region.mapInitLatitude,
                region.mapInitLongitude,
                region.mapInitLatitudeSpan,
                region.mapInitLongitudeSpan,
                region.mapDefaultZoomLevel)
    }
    
}
import SwiftUI
import Combine

// Used to specify good/ok wind directions for flying
struct SiteWindDirection: Codable, Equatable, Hashable {
    var N:  String
    var NE: String
    var E:  String
    var SE: String
    var S:  String
    var SW: String
    var W:  String
    var NW: String
}

struct Site: Codable, Identifiable, Equatable, Hashable {
    var id = UUID()
    var area: String
    var siteName: String
    var readingsNote: String
    var forecastNote: String
    var siteType: String        // sites have types of Soaring, Mountain, Airport, or blank
                                // Detailed forecast uses type of Aloft
                                // Map view and favorites also use type of Station
    var readingsAlt: String
    var readingsSource: String
    var readingsStation: String
    var pressureZoneReadingTime: String
    var siteLat: String
    var siteLon: String
    var sheetRow: Int           // Used to manage updates to Google sheet via API
    var windDirection: SiteWindDirection
}

struct SitesResponse: Codable {
    let values: [[String]]
}

class SiteViewModel: ObservableObject {
    @Published var areaOrder: [String] = []
    @Published var sites: [Site] = []
    private var cancellables = Set<AnyCancellable>()
    
    func getSites(completion: @escaping () -> Void) {
        let rangeName = "Sites"
        
        guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
              let regionURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)") else {
            print("Invalid or missing region Google Sheet ID for region: \(RegionManager.shared.activeAppRegion)")
            DispatchQueue.main.async { completion() }
            return
        }

        URLSession.shared.dataTaskPublisher(for: regionURL)
            .map { $0.data }
            .decode(type: SitesResponse.self, decoder: JSONDecoder())
            .map { response in
                response.values.enumerated().compactMap { index, row -> Site? in
                    guard index > 0 else { return nil }
                    guard row.count >= 12 else { return nil }
                    guard row[0] != "Yes" else { return nil }
                    let siteLat = row[10].trimmingCharacters(in: .whitespacesAndNewlines)
                    let siteLon = row[11].trimmingCharacters(in: .whitespacesAndNewlines)
                    guard let _ = Double(siteLat), let _ = Double(siteLon) else {
                        print("Skipping row with invalid coordinates: \(row[10]), \(row[11])")
                        return nil
                    }

                    let windDirection = SiteWindDirection(
                        N:  row.count > 12 ? row[12] : "",
                        NE: row.count > 13 ? row[13] : "",
                        E:  row.count > 14 ? row[14] : "",
                        SE: row.count > 15 ? row[15] : "",
                        S:  row.count > 16 ? row[16] : "",
                        SW: row.count > 17 ? row[17] : "",
                        W:  row.count > 18 ? row[18] : "",
                        NW: row.count > 19 ? row[19] : ""
                    )

                    return Site(
                        area:               row[1],
                        siteName:           row[2],
                        readingsNote:       row[3],
                        forecastNote:       row[4],
                        siteType:           row[5],
                        readingsAlt:        row[6],
                        readingsSource:     row[7],
                        readingsStation:    row[8],
                        pressureZoneReadingTime: row[9],
                        siteLat:            siteLat,
                        siteLon:            siteLon,
                        sheetRow:           index + 1,
                        windDirection:      windDirection
                    )
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .sink { [weak self] sites in
                self?.sites = sites

                self?.fetchAreaOrder { orderedAreas in
                    DispatchQueue.main.async {
                        self?.areaOrder = orderedAreas
                        completion()
                    }
                }
            }
            .store(in: &cancellables)
    }

    func fetchAreaOrder(completion: @escaping ([String]) -> Void) {
        let rangeName = "Areas"

        guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
              let areaURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(rangeName)!A2:B?alt=json&key=\(googleAPIKey)") else {
            print("Invalid or missing region Google Sheet ID for Areas tab.")
            completion([])
            return
        }

        URLSession.shared.dataTask(with: areaURL) { data, response, error in
            guard let data = data,
                  let response = try? JSONDecoder().decode(SitesResponse.self, from: data) else {
                print("Failed to fetch or parse Areas tab.")
                completion([])
                return
            }

            // Column A = Exclude flag, Column B = Area name
            let orderedAreas = response.values.compactMap { row -> String? in
                guard row.count >= 2 else { return nil }

                let exclude = row[0].trimmingCharacters(in: .whitespacesAndNewlines).lowercased() == "yes"
                let areaName = row[1].trimmingCharacters(in: .whitespacesAndNewlines)

                return exclude ? nil : areaName
            }

            completion(orderedAreas)
        }.resume()
    }
    
}
import SwiftUI
import Combine

struct TFR: Identifiable, Codable {
    var id: String { notam_id }
    let notam_id: String
    let type: String
    let facility: String
    let state: String
    let description: String
    let creation_date: String
}

class TFRViewModel: ObservableObject {
    @Published var tfrs: [TFR] = []
    @Published var isLoading: Bool = false
    
    func fetchTFRs() {
        isLoading = true
        
        guard let url = URL(string: AppURLManager.shared.getAppURL(URLName: "TFRAPI") ?? "<Unknown TFR API URL>") else {
            print("Error getting TFR API URL")
            isLoading = false
            return
        }
        
        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in
            if let self = self, let data = data {
                do {
                    let tfrList = try JSONDecoder().decode([TFR].self, from: data)
                    DispatchQueue.main.async {
                        self.tfrs = tfrList.filter { $0.state == RegionManager.shared.activeAppRegion }
                        self.isLoading = false
                    }
                } catch {
                    print("Error decoding JSON: \(error)")
                    DispatchQueue.main.async { self.isLoading = false }
                }
            } else {
                print("Error processing TFRs: \(String(describing: error))")
                DispatchQueue.main.async {
                    self?.isLoading = false
                }
            }
        }.resume()
    }
}

import SwiftUI
import Combine

// Forecast data structures
struct ForecastData: Codable {
    var elevation: Double
    var hourly: HourlyData
}

struct HourlyData: Codable {
    var time: [String]
    var weathercode: [Int]
    var cloudcover: [Double]
    var precipitation_probability: [Double]
    var cape: [Double]
    var temperature_2m: [Double]
    var windspeed_500hPa: [Double]
    var windspeed_550hPa: [Double]
    var windspeed_600hPa: [Double]
    var windspeed_650hPa: [Double]
    var windspeed_700hPa: [Double]
    var windspeed_750hPa: [Double]
    var windspeed_800hPa: [Double]
    var windspeed_850hPa: [Double]
    var windspeed_900hPa: [Double]
    var windspeed_10m: [Double]
    var windgusts_10m: [Double]
    var winddirection_500hPa: [Double]
    var winddirection_550hPa: [Double]
    var winddirection_600hPa: [Double]
    var winddirection_650hPa: [Double]
    var winddirection_700hPa: [Double]
    var winddirection_750hPa: [Double]
    var winddirection_800hPa: [Double]
    var winddirection_850hPa: [Double]
    var winddirection_900hPa: [Double]
    var winddirection_10m: [Double]
    var temperature_500hPa: [Double]
    var temperature_550hPa: [Double]
    var temperature_600hPa: [Double]
    var temperature_650hPa: [Double]
    var temperature_700hPa: [Double]
    var temperature_750hPa: [Double]
    var temperature_800hPa: [Double]
    var temperature_850hPa: [Double]
    var temperature_900hPa: [Double]
    var dewpoint_500hPa: [Double]
    var dewpoint_550hPa: [Double]
    var dewpoint_600hPa: [Double]
    var dewpoint_650hPa: [Double]
    var dewpoint_700hPa: [Double]
    var dewpoint_750hPa: [Double]
    var dewpoint_800hPa: [Double]
    var dewpoint_850hPa: [Double]
    var dewpoint_900hPa: [Double]
    var geopotential_height_500hPa: [Double]
    var geopotential_height_550hPa: [Double]
    var geopotential_height_600hPa: [Double]
    var geopotential_height_650hPa: [Double]
    var geopotential_height_700hPa: [Double]
    var geopotential_height_750hPa: [Double]
    var geopotential_height_800hPa: [Double]
    var geopotential_height_850hPa: [Double]
    var geopotential_height_900hPa: [Double]
    var dateTime: [Date]?
    var newDateFlag: [Bool]?
    var formattedDay: [String]?
    var formattedDate: [String]?
    var formattedTime: [String]?
    var weatherCodeImage: [String]?
    var thermalVelocity_500hPa: [Double]?
    var thermalVelocity_550hPa: [Double]?
    var thermalVelocity_600hPa: [Double]?
    var thermalVelocity_650hPa: [Double]?
    var thermalVelocity_700hPa: [Double]?
    var thermalVelocity_750hPa: [Double]?
    var thermalVelocity_800hPa: [Double]?
    var thermalVelocity_850hPa: [Double]?
    var thermalVelocity_900hPa: [Double]?
    var topOfLiftTemp: [Double]?
    var gustFactor: [Double]?
    // formatted variables to prevent errors where compiler cannot determine types when converting double to string in a view
    var formattedCloudbaseAltitude: [String]?
    var topOfLiftAltitude: [Double]?
    var formattedTopOfLiftAltitude: [String]?
    var formattedTopOfLiftTemp: [String]?
    var formattedCAPE: [String]?
    var formattedPrecipProbability: [String]?
    var formattedCloudCover: [String]?
    var formattedSurfaceTemp: [String]?
    // Flying potential data
    var combinedColorValue: [Int]?
    var cloudCoverColorValue: [Int]?
    var precipColorValue: [Int]?
    var CAPEColorValue: [Int]?
    var windDirectionColorValue: [Int]?
    var surfaceWindColorValue: [Int]?
    var surfaceGustColorValue: [Int]?
    var gustFactorColorValue: [Int]?
    var windsAloftColorValue: [Int]?
    var thermalVelocityColorValue: [Int]?
    var windsAloftMax: [Double]?
    var thermalVelocityMax: [Double]?
}

// Structure used to store data that is common for all altitudes and pass to thermal calculation function
struct ForecastBaseData {
    var siteName: String
    var date: String
    var time: String
    var surfaceAltitude: Double
    var surfaceTemp: Double
}

// Used to prevent re-querying and processing forecast for a given site if recently processed
private struct ForecastCacheEntry {
    let data: ForecastData
    let timestamp: Date
}

class SiteForecastViewModel: ObservableObject {
    @Published var forecastData: ForecastData?
    @Published var maxPressureReading: Int = defaultMaxPressureReading
    
    private var liftParametersViewModel: LiftParametersViewModel
    private var sunriseSunsetViewModel: SunriseSunsetViewModel
    private var weatherCodesViewModel: WeatherCodeViewModel

    // Forecast cache based on each forecast URL
    private var forecastCache: [String: ForecastCacheEntry] = [:]
    
    // Define a specific URL session to number of concurrent API requests (e.g., when called from Flying Potential with many sites)
    private let urlSession: URLSession
    
    // Make thermal lift parameters, weather code images, and sunrise/sunset times available in this view model
    init(liftParametersViewModel: LiftParametersViewModel,
         sunriseSunsetViewModel: SunriseSunsetViewModel,
         weatherCodesViewModel: WeatherCodeViewModel) {
        self.liftParametersViewModel = liftParametersViewModel
        self.sunriseSunsetViewModel = sunriseSunsetViewModel
        self.weatherCodesViewModel = weatherCodesViewModel
        
        // Set limit on number of concurrent API requests for this session
        let config = URLSessionConfiguration.default
        config.httpMaximumConnectionsPerHost = 3   // allow only 3 concurrent requests
        self.urlSession = URLSession(configuration: config)

        print("SiteForecastViewModel initialized: \(ObjectIdentifier(self))")
    }
    
    func clearForecastCache() {
        forecastCache.removeAll()
    }
    
    func fetchForecast(siteName: String,
                       latitude: String,
                       longitude: String,
                       siteType: String,
                       siteWindDirection: SiteWindDirection) {

        let encodedTimezone = AppRegionManager.shared.getRegionEncodedTimezone() ?? ""
        let baseForecastURL = AppURLManager.shared.getAppURL(URLName: "forecastURL") ?? "<Unknown forecast URL>"
        var updatedForecastURL = updateURL(url: baseForecastURL, parameter: "latitude", value: latitude)
        updatedForecastURL = updateURL(url: updatedForecastURL, parameter: "longitude", value: longitude)
        updatedForecastURL = updateURL(url: updatedForecastURL, parameter: "encodedTimezone", value: encodedTimezone)
        
        if printForecastURL { print(updatedForecastURL) }

        // Cache check
        if let cached = forecastCache[updatedForecastURL],
           Date().timeIntervalSince(cached.timestamp) < forecastCacheInterval {
            DispatchQueue.main.async {
                self.forecastData = cached.data
                self.maxPressureReading = self.maxPressureReading  // Optional: re-process if needed
            }
            return
        }

        guard let forecastURL = URL(string: updatedForecastURL) else { return }
        
        urlSession.dataTask(with: forecastURL) { data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                let modifiedData = replaceNullsInJSON(data: data)
                if let forecastData = try? decoder.decode(ForecastData.self, from: modifiedData ?? data) {
                    DispatchQueue.main.async {
                        let (maxPressure, processed) = self.processForecastData(siteName: siteName,
                                                                                siteType: siteType,
                                                                                siteWindDirection: siteWindDirection,
                                                                                data: forecastData)
                        self.forecastData = processed
                        self.maxPressureReading = maxPressure
                        self.forecastCache[updatedForecastURL] = ForecastCacheEntry(data: processed, timestamp: Date())
                    }
                } else {
                    print("JSON decode failed for forecast")
                }
            }
        }.resume()
    }
    
    // Overloaded version with completion handler for use in FlyingPotentialView
    func fetchForecast(siteName: String,
                       latitude: String,
                       longitude: String,
                       siteType: String,
                       siteWindDirection: SiteWindDirection,
                       completion: @escaping (ForecastData?) -> Void) {

        let encodedTimezone = AppRegionManager.shared.getRegionEncodedTimezone() ?? ""
        let baseForecastURL = AppURLManager.shared.getAppURL(URLName: "forecastURL") ?? "<Unknown forecast URL>"
        
        var updatedForecastURL = updateURL(url: baseForecastURL, parameter: "latitude", value: latitude)
        updatedForecastURL = updateURL(url: updatedForecastURL, parameter: "longitude", value: longitude)
        updatedForecastURL = updateURL(url: updatedForecastURL, parameter: "encodedTimezone", value: encodedTimezone)

        if printForecastURL { print(updatedForecastURL) }

        // Cache check
        if let cached = forecastCache[updatedForecastURL],
           Date().timeIntervalSince(cached.timestamp) < forecastCacheInterval {
            DispatchQueue.main.async {
                completion(cached.data)
            }
            return
        }
let cached = forecastCache[updatedForecastURL]
print("Passed cache check for site: \(siteName), cache time stamp: \(String(describing: cached?.timestamp))")
        guard let forecastURL = URL(string: updatedForecastURL) else {
            completion(nil)
            return
        }
        
        urlSession.dataTask(with: forecastURL) { data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                let modifiedData = replaceNullsInJSON(data: data)
                do {
                    let forecastData = try decoder.decode(ForecastData.self, from: modifiedData ?? data)
                    let (_, processed) = self.processForecastData(siteName: siteName,
                                                                  siteType: siteType,
                                                                  siteWindDirection: siteWindDirection,
                                                                  data: forecastData)
                    DispatchQueue.main.async {
                        self.forecastCache[updatedForecastURL] = ForecastCacheEntry(data: processed, timestamp: Date())
                        completion(processed)
                    }
                } catch {
                    print("Decoding error: \(error)")
                    print("Raw JSON: \(String(data: modifiedData ?? data, encoding: .utf8) ?? "Invalid data")")
                    DispatchQueue.main.async {
                        completion(nil)
                    }
                }
            } else {
                DispatchQueue.main.async {
                    completion(nil)
                }
            }
        }.resume()
    }
    
    func processForecastData(siteName: String,
                            siteType: String,
                            siteWindDirection: SiteWindDirection,
                            data: ForecastData) -> (maxPressureReading: Int, ForecastData) {
        
        var processedHourly = HourlyData(
            time: [],
            weathercode: [],
            cloudcover: [],
            precipitation_probability: [],
            cape: [],
            temperature_2m: [],
            windspeed_500hPa: [],
            windspeed_550hPa: [],
            windspeed_600hPa: [],
            windspeed_650hPa: [],
            windspeed_700hPa: [],
            windspeed_750hPa: [],
            windspeed_800hPa: [],
            windspeed_850hPa: [],
            windspeed_900hPa: [],
            windspeed_10m: [],
            windgusts_10m: [],
            winddirection_500hPa: [],
            winddirection_550hPa: [],
            winddirection_600hPa: [],
            winddirection_650hPa: [],
            winddirection_700hPa: [],
            winddirection_750hPa: [],
            winddirection_800hPa: [],
            winddirection_850hPa: [],
            winddirection_900hPa: [],
            winddirection_10m: [],
            temperature_500hPa: [],
            temperature_550hPa: [],
            temperature_600hPa: [],
            temperature_650hPa: [],
            temperature_700hPa: [],
            temperature_750hPa: [],
            temperature_800hPa: [],
            temperature_850hPa: [],
            temperature_900hPa: [],
            dewpoint_500hPa: [],
            dewpoint_550hPa: [],
            dewpoint_600hPa: [],
            dewpoint_650hPa: [],
            dewpoint_700hPa: [],
            dewpoint_750hPa: [],
            dewpoint_800hPa: [],
            dewpoint_850hPa: [],
            dewpoint_900hPa: [],
            geopotential_height_500hPa: [],
            geopotential_height_550hPa: [],
            geopotential_height_600hPa: [],
            geopotential_height_650hPa: [],
            geopotential_height_700hPa: [],
            geopotential_height_750hPa: [],
            geopotential_height_800hPa: [],
            geopotential_height_850hPa: [],
            geopotential_height_900hPa: [],
            dateTime: [],
            newDateFlag: [],
            formattedDay: [],
            formattedDate: [],
            formattedTime: [],
            weatherCodeImage: [],
            thermalVelocity_500hPa: [],
            thermalVelocity_550hPa: [],
            thermalVelocity_600hPa: [],
            thermalVelocity_650hPa: [],
            thermalVelocity_700hPa: [],
            thermalVelocity_750hPa: [],
            thermalVelocity_800hPa: [],
            thermalVelocity_850hPa: [],
            thermalVelocity_900hPa: [],
            topOfLiftTemp: [],
            gustFactor: [],
            formattedCloudbaseAltitude: [],
            topOfLiftAltitude: [],
            formattedTopOfLiftAltitude: [],
            formattedTopOfLiftTemp: [],
            formattedCAPE: [],
            formattedPrecipProbability: [],
            formattedCloudCover: [],
            formattedSurfaceTemp: [],
            combinedColorValue: [],
            cloudCoverColorValue: [],
            precipColorValue: [],
            CAPEColorValue: [],
            windDirectionColorValue: [],
            surfaceWindColorValue: [],
            surfaceGustColorValue: [],
            gustFactorColorValue: [],
            windsAloftColorValue: [],
            thermalVelocityColorValue: [],
            windsAloftMax: [],
            thermalVelocityMax: []
        )
        
        // Get sunrise/sunset times from environment object
        var forecastStartTime = 6
        var forecastEndTime = 21
        if let sunriseSunset = sunriseSunsetViewModel.sunriseSunset {
            // Get the hour from sunrise and sunset times (provided in format hh:mm)
            // Add 13 to sunset to convert to pm and provide forecast at least until after sunset
            forecastStartTime = Int(sunriseSunset.sunrise.split(separator: ":", maxSplits: 1).first ?? "6") ?? 6
            forecastEndTime = ( Int(sunriseSunset.sunset.split(separator: ":", maxSplits: 1).first ?? "6") ?? 6 ) + 13
        } else {
            print("Sunrise/sunset not available")
            if logThermalCalcs {logToFile("Sunrise/sunset times not available") }
        }
        
        let currentDate = Date()
        let startOfDay = Calendar.current.startOfDay(for: currentDate)
        let oneHourAgo = Calendar.current.date(byAdding: .hour, value: -1, to: currentDate)!
        var priorReadingFormattedDate: String?
        var newDateFlag: Bool = true
        var thermalTriggerReachedForDay: Bool = false
        
        // Determine altitude in feet and limit wind readings to only those more than 200 ft above the surface
        // by reducing the number of rows to display and specifying the max pressure reading to display
        let surfaceAltitude = Double(convertMetersToFeet(data.elevation) + 10).rounded()
        let surfaceBuffer = 200.0           // Don't display winds aloft within surface buffer distance above surface
        var maxPressureReading: Int = maxPressureReading
        if (data.hourly.geopotential_height_900hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 850 }
        if (data.hourly.geopotential_height_850hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 800 }
        if (data.hourly.geopotential_height_800hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 750 }
        if (data.hourly.geopotential_height_750hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 700 }
        if (data.hourly.geopotential_height_700hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 650 }
        if (data.hourly.geopotential_height_650hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 600 }
        if (data.hourly.geopotential_height_600hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 550 }
        if (data.hourly.geopotential_height_550hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 500 }
        if (data.hourly.geopotential_height_500hPa.first ?? 0).rounded() < (surfaceAltitude + surfaceBuffer) { maxPressureReading = 450 }

        for (index, time) in data.hourly.time.enumerated() {
            let timeFormatter = DateFormatter()
            timeFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm"
            if let timeObj = timeFormatter.date(from: time) {
                // Process all times starting at beginning of today in order to correctly calculate if
                // thermal trigger temperature was reached for today.
                // There is logic below to filter the display for only times starting from one hour prior to now
                if timeObj >= startOfDay {
                    let hour = Calendar.current.component(.hour, from: timeObj)
                    if hour >= forecastStartTime && hour <= forecastEndTime {

                        let dateFormatter = DateFormatter()
                        dateFormatter.dateFormat = "E"
                        let formattedDay = dateFormatter.string(from: timeObj)
                        dateFormatter.dateFormat = "M/d"
                        let formattedDate = dateFormatter.string(from: timeObj)
                        timeFormatter.dateFormat = "h a"
                        let formattedTime = timeFormatter.string(from: timeObj).lowercased()
                        let surfaceTemp = convertCelsiusToFahrenheit(Int(data.hourly.temperature_2m[index]))
                                                
                        // Determine if this reading is a new day to set a divider in the view
                        if formattedDate == priorReadingFormattedDate {
                            newDateFlag = false
                        } else {
                            newDateFlag = true
                            // Reset thermal trigger temp reached for the day
                            thermalTriggerReachedForDay = false
                        }
                        priorReadingFormattedDate = formattedDate
                        
                        // Set weather code image
                        let weatherCodeImage = self.weatherCodesViewModel.weatherCodeImage (
                            weatherCode: Int(data.hourly.weathercode[index]),
                            cloudcover: data.hourly.cloudcover[index],
                            precipProbability: data.hourly.precipitation_probability[index],
                            tempF: Double(surfaceTemp)) ?? ""
                        
                        // Create variables to store thermal lift at each altitude
                        var thermalVelocity_900hPa: Double = 0.0
                        var thermalVelocity_850hPa: Double = 0.0
                        var thermalVelocity_800hPa: Double = 0.0
                        var thermalVelocity_750hPa: Double = 0.0
                        var thermalVelocity_700hPa: Double = 0.0
                        var thermalVelocity_650hPa: Double = 0.0
                        var thermalVelocity_600hPa: Double = 0.0
                        var thermalVelocity_550hPa: Double = 0.0
                        var thermalVelocity_500hPa: Double = 0.0
                        
                        // Set base data (common for all altitudes) used to calculate thermal velocity
                        let forecastBaseData = ForecastBaseData(
                            siteName: siteName,
                            date: formattedDate,
                            time: formattedTime,
                            surfaceAltitude: surfaceAltitude,
                            surfaceTemp: data.hourly.temperature_2m[index]
                        )
                        // 900 hpa pressure level thermal calcs
                        var thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_900hPa[index],
                            ambientTemp: data.hourly.temperature_900hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_900hPa[index],
                            priorAmbientDPTemp: 0.0,
                            priorThermalDPTemp: data.hourly.temperature_2m[index],
                            priorAltitude: surfaceAltitude,
                            thermalTriggerReachedForDay: thermalTriggerReachedForDay,
                            topOfLiftAltitude: 0.0,
                            topOfLiftTemp: 0.0,
                            cloudbaseAltitude: 0.0)
                        thermalVelocity_900hPa = thermalResult.thermalVelocity
                        
                        // 850 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_850hPa[index],
                            ambientTemp: data.hourly.temperature_850hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_850hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_900hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_900hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_850hPa = thermalResult.thermalVelocity
                        
                        // 800 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_800hPa[index],
                            ambientTemp: data.hourly.temperature_800hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_800hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_850hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_850hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_800hPa = thermalResult.thermalVelocity
                        
                        // 750 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_750hPa[index],
                            ambientTemp: data.hourly.temperature_750hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_750hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_800hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_800hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_750hPa = thermalResult.thermalVelocity
                        
                        // 700 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_700hPa[index],
                            ambientTemp: data.hourly.temperature_700hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_700hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_750hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_750hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_700hPa = thermalResult.thermalVelocity
                        
                        // 650 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_650hPa[index],
                            ambientTemp: data.hourly.temperature_650hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_650hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_700hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_700hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_650hPa = thermalResult.thermalVelocity
                        
                        // 600 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_600hPa[index],
                            ambientTemp: data.hourly.temperature_600hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_600hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_650hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_650hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_600hPa = thermalResult.thermalVelocity
                        
                        // 550 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_550hPa[index],
                            ambientTemp: data.hourly.temperature_550hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_550hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_600hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_600hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_550hPa = thermalResult.thermalVelocity
                        
                        // 500 hpa pressure level thermal calcs
                        thermalResult = calcThermalVelocity (
                            forecastBaseData: forecastBaseData,
                            altitude: data.hourly.geopotential_height_500hPa[index],
                            ambientTemp: data.hourly.temperature_500hPa[index],
                            ambientDPTemp: data.hourly.dewpoint_500hPa[index],
                            priorAmbientDPTemp: data.hourly.dewpoint_550hPa[index],
                            priorThermalDPTemp: thermalResult.thermalDPTemp,
                            priorAltitude: data.hourly.geopotential_height_550hPa[index],
                            thermalTriggerReachedForDay: thermalResult.thermalTriggerReachedForDay,
                            topOfLiftAltitude: thermalResult.topOfLiftAltitude,
                            topOfLiftTemp: thermalResult.topOfLiftTemp,
                            cloudbaseAltitude: thermalResult.cloudbaseAltitude)
                        thermalVelocity_500hPa = thermalResult.thermalVelocity

                        // Maintain status if thermal trigger has been reached for the day
                        thermalTriggerReachedForDay = thermalResult.thermalTriggerReachedForDay
                        
                        // Format cloudbase data if present (is a number and not 0 or very large)
                        // Altitudes are / 1000 so they can be displayed like "13k)
                        var formattedCloudbaseAltitude = ""
                        if thermalResult.cloudbaseAltitude > 0 && thermalResult.cloudbaseAltitude < 100000 {
                            formattedCloudbaseAltitude = String(Int((thermalResult.cloudbaseAltitude/1000).rounded())) + "k"
                        }
                        
                        // Format top of lift data
                        // Altitudes are / 1000 so they can be displayed like "13k)
                        var topOfLiftAltitude = thermalResult.topOfLiftAltitude
                        var formattedTopOfLiftAltitude = ""
                        var topOfLiftTemp = 0.0
                        if topOfLiftAltitude > 0 {
                            if topOfLiftAltitude > surfaceAltitude {
                                formattedTopOfLiftAltitude = String(Int((topOfLiftAltitude/1000).rounded())) + "k"
                            } else {
                                formattedTopOfLiftAltitude = ""
                                topOfLiftTemp = data.hourly.temperature_2m[index]
                            }
                        } else if thermalResult.thermalDPTemp > data.hourly.dewpoint_500hPa[index] {
                            // Never reached top of lift
                            formattedTopOfLiftAltitude = "rocket"
                            topOfLiftAltitude = defaultTopOfLiftAltitude
                            topOfLiftTemp = data.hourly.temperature_500hPa[index]
                        }
                        // Convert top of Lift Temp to F
                        let topOfLiftTempF = convertCelsiusToFahrenheit(Int(topOfLiftTemp))
                        
                        // Calculate surface gust factor
                        let gustFactor =  Int(data.hourly.windgusts_10m[index]) - Int(data.hourly.windspeed_10m[index])

                        // Only append display structure for times that are no more than an hour ago
                        // (earlier times only processed to determine if thermal trigger temp has already been reached today)
                        if timeObj >= oneHourAgo {
                            processedHourly.time.append(time)
                            processedHourly.dateTime?.append(timeObj)
                            processedHourly.formattedDay?.append(formattedDay)
                            processedHourly.formattedDate?.append(formattedDate)
                            processedHourly.formattedTime?.append(formattedTime)
                            processedHourly.newDateFlag?.append(newDateFlag)
                            processedHourly.weatherCodeImage?.append(weatherCodeImage)
                            processedHourly.weathercode.append(data.hourly.weathercode[index])
                            processedHourly.cloudcover.append(data.hourly.cloudcover[index])
                            if data.hourly.cloudcover[index] == 0 {
                                processedHourly.formattedCloudCover?.append("")
                            } else {
                                processedHourly.formattedCloudCover?.append(String(Int(data.hourly.cloudcover[index])))
                            }
                            processedHourly.precipitation_probability.append(data.hourly.precipitation_probability[index])
                            if data.hourly.precipitation_probability[index] == 0 {
                                processedHourly.formattedPrecipProbability?.append("")
                            } else {
                                processedHourly.formattedPrecipProbability?.append(String(Int(data.hourly.precipitation_probability[index])))
                            }
                            processedHourly.cape.append(data.hourly.cape[index])
                            if data.hourly.cape[index].rounded() == 0 {
                                processedHourly.formattedCAPE?.append("")
                            } else {
                                processedHourly.formattedCAPE?.append(String(Int(data.hourly.cape[index].rounded())))
                            }
                            processedHourly.temperature_2m.append(Double(surfaceTemp))
                            processedHourly.formattedSurfaceTemp?.append(String(surfaceTemp) + "°")
                            processedHourly.windspeed_500hPa.append(data.hourly.windspeed_500hPa[index].rounded())
                            processedHourly.windspeed_550hPa.append(data.hourly.windspeed_550hPa[index].rounded())
                            processedHourly.windspeed_600hPa.append(data.hourly.windspeed_600hPa[index].rounded())
                            processedHourly.windspeed_650hPa.append(data.hourly.windspeed_650hPa[index].rounded())
                            processedHourly.windspeed_700hPa.append(data.hourly.windspeed_700hPa[index].rounded())
                            processedHourly.windspeed_750hPa.append(data.hourly.windspeed_750hPa[index].rounded())
                            processedHourly.windspeed_800hPa.append(data.hourly.windspeed_800hPa[index].rounded())
                            processedHourly.windspeed_850hPa.append(data.hourly.windspeed_850hPa[index].rounded())
                            processedHourly.windspeed_900hPa.append(data.hourly.windspeed_900hPa[index].rounded())
                            processedHourly.windspeed_10m.append(data.hourly.windspeed_10m[index].rounded())
                            processedHourly.windgusts_10m.append(data.hourly.windgusts_10m[index].rounded())
                            processedHourly.winddirection_500hPa.append(data.hourly.winddirection_500hPa[index])
                            processedHourly.winddirection_550hPa.append(data.hourly.winddirection_550hPa[index])
                            processedHourly.winddirection_600hPa.append(data.hourly.winddirection_600hPa[index])
                            processedHourly.winddirection_650hPa.append(data.hourly.winddirection_650hPa[index])
                            processedHourly.winddirection_700hPa.append(data.hourly.winddirection_700hPa[index])
                            processedHourly.winddirection_750hPa.append(data.hourly.winddirection_750hPa[index])
                            processedHourly.winddirection_800hPa.append(data.hourly.winddirection_800hPa[index])
                            processedHourly.winddirection_850hPa.append(data.hourly.winddirection_850hPa[index])
                            processedHourly.winddirection_900hPa.append(data.hourly.winddirection_900hPa[index])
                            processedHourly.winddirection_10m.append(data.hourly.winddirection_10m[index])
                            // Heights are divided by 1,000 and rounded so they can be displayed like "12k ft"
                            processedHourly.geopotential_height_500hPa.append((data.hourly.geopotential_height_500hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_550hPa.append((data.hourly.geopotential_height_550hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_600hPa.append((data.hourly.geopotential_height_600hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_650hPa.append((data.hourly.geopotential_height_650hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_700hPa.append((data.hourly.geopotential_height_700hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_750hPa.append((data.hourly.geopotential_height_750hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_800hPa.append((data.hourly.geopotential_height_800hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_850hPa.append((data.hourly.geopotential_height_850hPa[index]/1000).rounded())
                            processedHourly.geopotential_height_900hPa.append((data.hourly.geopotential_height_900hPa[index]/1000).rounded())
                            processedHourly.thermalVelocity_900hPa?.append(thermalVelocity_900hPa)
                            processedHourly.thermalVelocity_850hPa?.append(thermalVelocity_850hPa)
                            processedHourly.thermalVelocity_800hPa?.append(thermalVelocity_800hPa)
                            processedHourly.thermalVelocity_750hPa?.append(thermalVelocity_750hPa)
                            processedHourly.thermalVelocity_700hPa?.append(thermalVelocity_700hPa)
                            processedHourly.thermalVelocity_650hPa?.append(thermalVelocity_650hPa)
                            processedHourly.thermalVelocity_600hPa?.append(thermalVelocity_600hPa)
                            processedHourly.thermalVelocity_550hPa?.append(thermalVelocity_550hPa)
                            processedHourly.thermalVelocity_500hPa?.append(thermalVelocity_500hPa)
                            // Add top of lift results to data structure
                            processedHourly.formattedCloudbaseAltitude?.append(formattedCloudbaseAltitude)
                            if topOfLiftAltitude.isNaN {
                                print(String(topOfLiftAltitude))
                                topOfLiftAltitude = 0 }
                            // Set top of lift altitude to a minimum of surface altitude for area chart
                            // (leaves formatted top of lift altitude set to ""
                            processedHourly.topOfLiftAltitude?.append(max(topOfLiftAltitude, surfaceAltitude))
                            processedHourly.formattedTopOfLiftAltitude?.append(formattedTopOfLiftAltitude)
                            processedHourly.topOfLiftTemp?.append(Double(topOfLiftTempF))
                            processedHourly.formattedTopOfLiftTemp?.append(String(topOfLiftTempF) + "°")
                            processedHourly.gustFactor?.append(Double(gustFactor))
                            
                            //------------------------------------------------------------------------------------------------------
                            // Flying potential section
                            //------------------------------------------------------------------------------------------------------
                            
                            let cloudCoverColorValue = FlyingPotentialColor.value(for: cloudCoverColor(Int(data.hourly.cloudcover[index])))
                            let precipColorValue = FlyingPotentialColor.value(for: precipColor(Int(data.hourly.precipitation_probability[index])))
                            let CAPEColorValue = FlyingPotentialColor.value(for: CAPEColor(Int(data.hourly.cape[index])))
                            let surfaceWindColorValue = FlyingPotentialColor.value(for: windSpeedColor(windSpeed: Int(data.hourly.windspeed_10m[index]), siteType: siteType))
                            let surfaceGustColorValue = FlyingPotentialColor.value(for: windSpeedColor(windSpeed: Int(data.hourly.windgusts_10m[index]), siteType: siteType))
                            let gustFactorColorValue = FlyingPotentialColor.value(for: gustFactorColor(gustFactor))
                            
                            // Winds aloft and thermals up to 6k ft (800 hpa) for all sites; higher altitude for mountain sites
                            var windsAloftMax: Double = max(data.hourly.windspeed_900hPa[index],
                                                    data.hourly.windspeed_850hPa[index],
                                                    data.hourly.windspeed_800hPa[index])
                            var thermalVelocityMax: Double = max(thermalVelocity_900hPa,
                                                         thermalVelocity_850hPa,
                                                         thermalVelocity_800hPa)
                            if siteType == "Mountain" {
                                windsAloftMax = max(windsAloftMax,
                                                    data.hourly.windspeed_750hPa[index],
                                                    data.hourly.windspeed_700hPa[index],
                                                    data.hourly.windspeed_650hPa[index])
                                thermalVelocityMax = max(thermalVelocityMax,
                                                         thermalVelocity_750hPa,
                                                         thermalVelocity_700hPa,
                                                         thermalVelocity_650hPa)
                            }
                            let thermalVelocityColorValue = FlyingPotentialColor.value(for: thermalColor(thermalVelocityMax))
                            let windsAloftColorValue = FlyingPotentialColor.value(for: windSpeedColor(
                                    windSpeed: Int(windsAloftMax), siteType: siteType))

                            // Determine wind direction color for site
                            let windDirectionColorValue = FlyingPotentialColor.value(for: windDirectionColor(
                                siteWindDirection:  siteWindDirection,
                                siteType:           siteType,
                                windDirection:      Int(data.hourly.winddirection_10m[index]),
                                windSpeed:          Int(data.hourly.windspeed_10m[index]),
                                windGust:           Int(data.hourly.windgusts_10m[index])))

                            // Determine potential
                            var combinedColorValue = max(cloudCoverColorValue,
                                                         precipColorValue,
                                                         CAPEColorValue,
                                                         windsAloftColorValue,
                                                         surfaceWindColorValue,
                                                         surfaceGustColorValue,
                                                         gustFactorColorValue,
                                                         windDirectionColorValue)
                            
                            // For soaring sites, reduce the value if wind speed can is too low to soar
                            if siteType == "Soaring" {
                                if combinedColorValue <= FlyingPotentialColor.value(for: .green) {
                                    // No warning conditions; base color on wind, including "downgrading" if there isn't enough surface wind
                                    combinedColorValue = max(surfaceWindColorValue, surfaceGustColorValue)
                                }
                            }
                            // Note:  Not currently checking top of lift to limit winds aloft readings
                            
                            // Store potential results
                            processedHourly.combinedColorValue?.append(combinedColorValue)
                            processedHourly.cloudCoverColorValue?.append(cloudCoverColorValue)
                            processedHourly.precipColorValue?.append(precipColorValue)
                            processedHourly.CAPEColorValue?.append(CAPEColorValue)
                            processedHourly.windDirectionColorValue?.append(windDirectionColorValue)
                            processedHourly.surfaceWindColorValue?.append(surfaceWindColorValue)
                            processedHourly.surfaceGustColorValue?.append(surfaceGustColorValue)
                            processedHourly.gustFactorColorValue?.append(gustFactorColorValue)
                            processedHourly.windsAloftColorValue?.append(windsAloftColorValue)
                            processedHourly.thermalVelocityColorValue?.append(thermalVelocityColorValue)
                            processedHourly.windsAloftMax?.append(windsAloftMax)
                            processedHourly.thermalVelocityMax?.append(thermalVelocityMax)
                            
                        }
                    }
                }
            }
        }
        return (maxPressureReading, ForecastData(elevation: data.elevation, hourly: processedHourly))
    }
    
    struct ThermalResult {
        let thermalVelocity: Double
        let thermalDPTemp: Double
        let cloudbaseAltitude: Double
        let topOfLiftAltitude: Double
        let topOfLiftTemp: Double
        let thermalTriggerReachedForDay: Bool
    }
    
    func calcThermalVelocity(
        forecastBaseData: ForecastBaseData,
        altitude: Double,
        ambientTemp: Double,
        ambientDPTemp: Double,
        priorAmbientDPTemp: Double,
        priorThermalDPTemp: Double,
        priorAltitude: Double,
        thermalTriggerReachedForDay: Bool,
        topOfLiftAltitude: Double,
        topOfLiftTemp: Double,
        cloudbaseAltitude: Double
    ) -> ThermalResult {

        // Set buffer for calculation altitudes (should be the same as the buffer set in the above function)
        let surfaceBuffer = 200.0
        
        // Base values passed (common for all altitudes)
        let siteName = forecastBaseData.siteName
        let forecastDate = forecastBaseData.date
        let forecastTime = forecastBaseData.time
        let surfaceAltitude = forecastBaseData.surfaceAltitude
        let surfaceTemp = forecastBaseData.surfaceTemp
        
        // Initial values (setting here to allow all to be written to log file)
        var thermalDPTemp = priorThermalDPTemp
        var thermalVelocity: Double = 0.0
        var cloudbaseRatio: Double = 0.0
        var cloudbaseAltitude = cloudbaseAltitude
        var topOfLiftAltitude  = topOfLiftAltitude
        var topOfLiftTemp = topOfLiftTemp
        var thermalTriggerReachedForDay = thermalTriggerReachedForDay
        var topOfLiftRatio: Double = 0.0
        var altitudeChange: Double = 0.0
        var thermalRampTop: Double = 0.0
        var rampImpactAltitude: Double = 0.0
        var rampImpactPortion: Double = 0.0
        var rampReductionFactor: Double = 0.0
        var thermalDPTempToAmbientDPTempDiff: Double = 0.0
        var ambientTempToAmbientDPTempDiff: Double = 0.0
        var ambientDPTempDiff: Double = 0.0
        var priorAmbientDPTempToAmbientTempDiff: Double = 0.0
        var priorAltitudeThermalDPDiff: Double = 0.0
        var priorThermalDPTempToAmbientDPTempDiff: Double = 0.0

        // Get thermal lift parameters from environment object
        guard let liftParameters = liftParametersViewModel.liftParameters else {
            // End processing if lift parameters are not available
            print("Error - thermal lift parameters not available")
            if logThermalCalcs {logToFile("Error - thermal lift parameters not available") }
            return ThermalResult(
                thermalVelocity: thermalVelocity,
                thermalDPTemp: thermalDPTemp,
                cloudbaseAltitude: cloudbaseAltitude,
                topOfLiftAltitude: topOfLiftAltitude,
                topOfLiftTemp: topOfLiftTemp,
                thermalTriggerReachedForDay: thermalTriggerReachedForDay)
        }

        // Check if altitude is less than surfaceAltitude
        guard altitude >= (surfaceAltitude + surfaceBuffer) else {
            // End processing if altitude is less than surfaceAltitude
            return ThermalResult(
                thermalVelocity: thermalVelocity,
                thermalDPTemp: thermalDPTemp,
                cloudbaseAltitude: cloudbaseAltitude,
                topOfLiftAltitude: topOfLiftAltitude,
                topOfLiftTemp: topOfLiftTemp,
                thermalTriggerReachedForDay: thermalTriggerReachedForDay)
        }
        
        // Set priorAltitude to surfaceAltitude if it is less than surfaceAltitude
        let adjustedPriorAltitude = priorAltitude < surfaceAltitude ? surfaceAltitude : priorAltitude
        
        // Only process if top of lift has not been previously reached
        if topOfLiftAltitude < surfaceAltitude {
            
            // Check if initial thermal trigger temperature difference between ground temp and ambient temp is not yet reached for the day
            // If it has previously been reached, use ongoing thermal trigger temperature difference instead
            var adjustedThermalTriggerTempDiff = liftParameters.initialTriggerTempDiff
            if thermalTriggerReachedForDay {
                adjustedThermalTriggerTempDiff = liftParameters.ongoingTriggerTempDiff
            }
            // if thermals not yet triggering; set top of lift to surface altitude
            if  surfaceTemp < ( ambientTemp + adjustedThermalTriggerTempDiff) {
                topOfLiftAltitude = adjustedPriorAltitude
            }
            // Thermal trigger temp reached...continue processing
            else {

                // Ensure thermal trigger temp reached is set to true
                thermalTriggerReachedForDay = true
                
                // Determine altitude change
                altitudeChange = altitude - adjustedPriorAltitude
                
                // Convert altitude from feet to kilometers
                let altitudeKm = convertFeetToMeters(altitude) / 1000
                let adjustedPriorAltitudeKm = convertFeetToMeters(adjustedPriorAltitude) / 1000
                let altitudeChangeKm = altitudeKm - adjustedPriorAltitudeKm
                
                // Td = T - (DALR * altitudeChange in km) where DALR is the thermalLapseRate
                thermalDPTemp = priorThermalDPTemp - ( liftParameters.thermalLapseRate * altitudeChangeKm )
                
                // Calculate temperature differences
                thermalDPTempToAmbientDPTempDiff = max( (thermalDPTemp - ambientDPTemp), 0.0 )
                ambientTempToAmbientDPTempDiff = max( (ambientTemp - ambientDPTemp), 0.0 )
                ambientDPTempDiff = max( (priorAmbientDPTemp - ambientDPTemp), 0.0 )
                priorAmbientDPTempToAmbientTempDiff = max( priorAmbientDPTemp - ambientTemp, 0.0)
                priorAltitudeThermalDPDiff = max( (priorAmbientDPTemp - thermalDPTemp), 0.0 )
                priorThermalDPTempToAmbientDPTempDiff = max( (priorThermalDPTemp - priorAmbientDPTemp), 0.0 )
                
                // Determine if cloudbase is reached (thermal dew point temp does not exceed ambient temp)
                if  ambientTemp <= ambientDPTemp {
                    if ambientDPTempDiff == 0 {
                        cloudbaseAltitude = adjustedPriorAltitude
                    } else {
                        cloudbaseRatio = priorAmbientDPTempToAmbientTempDiff / priorAltitudeThermalDPDiff
                        cloudbaseAltitude = adjustedPriorAltitude + ( altitudeChange * cloudbaseRatio )
                    }
                }
                
                // Determine if top of lift is reached (thermal dew point temp does not exceed ambient dew point)
                if thermalDPTemp <= ambientDPTemp {
                    if priorThermalDPTempToAmbientDPTempDiff == 0 {
                        topOfLiftAltitude = adjustedPriorAltitude
                        topOfLiftTemp = ambientTemp     // Should actually be prior ambient temp, which is not available
                    } else {
                        if priorAltitudeThermalDPDiff == 0 {
                            // Prior ambient DP temp <= thermal DP temp (top of lift should have been already reached)
                            // May be indicative of an inversion layer
                            topOfLiftAltitude = adjustedPriorAltitude
                            topOfLiftTemp = ambientTemp     // Should actually be prior ambient temp, which is not available
                        } else {
                            topOfLiftRatio = ( priorAmbientDPTempToAmbientTempDiff / priorAltitudeThermalDPDiff )
                            if topOfLiftRatio.isNaN {
                                print("topOfLiftRatio is NaN, \(priorAmbientDPTempToAmbientTempDiff), \(priorAltitudeThermalDPDiff), \(priorAmbientDPTemp), \(thermalDPTemp)")
                                topOfLiftRatio = 0.0
                            }
                            topOfLiftAltitude = adjustedPriorAltitude + ( altitudeChange * topOfLiftRatio )
                            topOfLiftTemp = ambientTemp     // Should actually be a ratio of prior and current ambient Temps
                        }
                    }
                }
                
                // If cloudbase < top of lift, set top of (usable) lift to cloudbase
                if cloudbaseAltitude > 0.0 && topOfLiftAltitude > 0.0 && cloudbaseAltitude < topOfLiftAltitude {
                    topOfLiftAltitude = cloudbaseAltitude
                }
                
                // If neither cloudbase or top of lift is reached, calculate thermal velocity (w)
                if cloudbaseAltitude == 0.0 && topOfLiftAltitude == 0.0 {
                    // w = thermalVelocityConstant * sqrt [ ((1.1)^(thermalDPTemp - ambDPTemp) - 1) / ((1.1)^(ambTemp - ambDPTemp)-1) ]
                    // Thermal velocity:
                    //      Increases with warmer or dryer thermal compared to ambient air
                    //      Decreases with dryer ambient air
                    thermalVelocity = liftParameters.thermalVelocityConstant * sqrt( (pow(1.1, thermalDPTempToAmbientDPTempDiff) - 1) / (pow(1.1, ambientTempToAmbientDPTempDiff) - 1))
                    
                    // Adjust thermal velocity if within thermal ramp distance (near the surface)
                    thermalRampTop = surfaceAltitude + liftParameters.thermalRampDistance
                    if thermalRampTop > adjustedPriorAltitude {
                        rampImpactAltitude = min(altitude, thermalRampTop) - adjustedPriorAltitude
                        rampImpactPortion = rampImpactAltitude / (altitude - adjustedPriorAltitude)
                        rampReductionFactor = liftParameters.thermalRampStartPct / 100 * rampImpactPortion
                        thermalVelocity = thermalVelocity * (1 - rampReductionFactor)
                    }
                    
                    // Adjust thermal velocity for glider sink rate
                    thermalVelocity = max( (thermalVelocity - liftParameters.thermalGliderSinkRate ), 0.0)
                    
                    // Adjust down top of usaeable lift if thermalVelocity is less than glider sink rate
                    if thermalVelocity <= 0 {
                        if topOfLiftAltitude > 0 {
                            topOfLiftAltitude = min(altitude, topOfLiftAltitude)
                            topOfLiftTemp = ambientTemp
                        } else {
                            // Set top of lift conservatively to the bottom of the altitude range being evaluated
                            topOfLiftAltitude = adjustedPriorAltitude
                            topOfLiftTemp = ambientTemp     // Should actually be prior ambient temp, which is not available
                        }
                    }
                }
            }
        }
        
        // If logging is turned on, write data for thermal calc troubleshooting
        if logThermalCalcs {
            logToFile(
                "\(siteName)," +
                "\(forecastDate)," +
                "\(forecastTime)," +
                "\(surfaceAltitude)," +
                "\(surfaceTemp)," +
                "\(altitude)," +
                "\(ambientTemp)," +
                "\(ambientDPTemp)," +
                "\(thermalVelocity)," +
                "\(thermalTriggerReachedForDay)," +
                "\(topOfLiftAltitude)," +
                "\(cloudbaseAltitude)," +
                "\(adjustedPriorAltitude)," +
                "\(altitudeChange)," +
                "\(topOfLiftRatio)," +
                "\(cloudbaseRatio)," +
                "\(priorAmbientDPTemp)," +
                "\(thermalDPTemp)," +
                "\(priorThermalDPTemp)," +
                "\(thermalDPTempToAmbientDPTempDiff)," +
                "\(ambientTempToAmbientDPTempDiff)," +
                "\(ambientDPTempDiff)," +
                "\(priorThermalDPTempToAmbientDPTempDiff)," +
                "\(priorAmbientDPTempToAmbientTempDiff)," +
                "\(thermalRampTop)," +
                "\(rampImpactAltitude)," +
                "\(rampImpactPortion)," +
                "\(rampReductionFactor)," +
                "\(liftParameters.thermalLapseRate)," +
                "\(liftParameters.thermalVelocityConstant)," +
                "\(liftParameters.initialTriggerTempDiff)," +
                "\(liftParameters.ongoingTriggerTempDiff)," +
                "\(liftParameters.thermalRampDistance)," +
                "\(liftParameters.thermalRampStartPct)," +
                "\(liftParameters.cloudbaseLapseRatesDiff)," +
                "\(liftParameters.thermalGliderSinkRate)"
            )
        }
        
        return ThermalResult(
            thermalVelocity: roundToOneDecimal(thermalVelocity),
            thermalDPTemp: thermalDPTemp,
            cloudbaseAltitude: cloudbaseAltitude,
            topOfLiftAltitude: topOfLiftAltitude,
            topOfLiftTemp: topOfLiftTemp,
            thermalTriggerReachedForDay: thermalTriggerReachedForDay
        )
    }
}
import SwiftUI
import Combine

struct WeatherCam: Identifiable {
    let id = UUID()
    let category: String
    let name: String
    let linkURL: String
    let imageURL: String
}

struct WeatherCamGoogleSheetResponse: Codable {
    let values: [[String]]
}

class WeatherCamViewModel: ObservableObject {
    @Published var weatherCams: [WeatherCam] = []
    @Published var groupedWeatherCams: [String: [WeatherCam]] = [:]
    @Published var isLoading: Bool = false
    
    func fetchWeatherCams() {
        DispatchQueue.main.async {
            self.isLoading = true
        }
        
        let rangeName = "WeatherCams"
        
        // Build region sheet URL
        guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
              let regionURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)") else {
            print("Invalid or missing region Google Sheet ID for region: \(RegionManager.shared.activeAppRegion)")
            DispatchQueue.main.async {
                self.isLoading = false
            }
            return
        }

        URLSession.shared.dataTask(with: regionURL) { [weak self] data, response, error in
            guard let self = self else { return }
            
            defer {
                // Always hide the progress indicator when this closure exits
                DispatchQueue.main.async {
                    self.isLoading = false
                }
            }
            
            if let error = error {
                print("Failed to fetch data: \(error.localizedDescription)")
                return
            }
            guard let data = data else {
                print("No data received")
                return
            }
            
            do {
                let response = try JSONDecoder().decode(WeatherCamGoogleSheetResponse.self, from: data)
                
                let skipCondition: ([String]) -> Bool = { row in
                    row.first == "Yes"
                }
                
                let cams: [WeatherCam] = response.values
                    .dropFirst() // skip header row
                    .compactMap { row in
                        guard row.count >= 5 else {
                            print("Skipping malformed row (not enough columns): \(row)")
                            return nil
                        }
                        if skipCondition(row) {
                            return nil
                        }
                        return WeatherCam(
                            category: row[1],
                            name:     row[2],
                            linkURL:  row[3],
                            imageURL: row[4]
                        )
                    }
                
                DispatchQueue.main.async {
                    self.weatherCams = cams
                    self.groupedWeatherCams = Dictionary(grouping: cams, by: \.category)
                    // isLoading will be set to false by the `defer` block above
                }
            } catch {
                print("Failed to decode JSON: \(error)")
            }
        }
        .resume()
    }
}
import Foundation
import MapKit
import Combine

class RainViewerTileOverlay: MKTileOverlay {
    enum OverlayType { case radar, satellite }

    private let radarColorScheme: Int
    private let satelliteColorScheme = 0

    private let smoothing   = 1
    private let snow        = 0
    private let tileSizePx  = 256

    init(
        host: String,
        framePath: String,
        type: OverlayType,
        radarColorScheme: Int
    ) {
        self.radarColorScheme = radarColorScheme

        // pick segment
        let segment = (type == .radar) ? "radar" : "satellite"
        // pick the proper scheme
        let colorScheme = (type == .radar)
            ? self.radarColorScheme
            : self.satelliteColorScheme

        let template = "\(host)/v2/\(segment)/\(framePath)/" +
                       "\(tileSizePx)/{z}/{x}/{y}/" +
                       "\(colorScheme)/\(smoothing)_\(snow).png"

        super.init(urlTemplate: template)
        self.canReplaceMapContent = false
        self.tileSize = CGSize(width: tileSizePx, height: tileSizePx)
    }
}

// JSON models
struct RainViewerResponse: Decodable {
    let host: String
    let radar:   RadarData?
    let satellite: SatelliteData?
}

struct RadarData: Decodable { let past: [Frame]; let nowcast: [Frame]? }
struct SatelliteData: Decodable { let infrared: [Frame] }
struct Frame: Decodable { let time: Int; let path: String }

class RainViewerOverlayProvider {
    private let apiURL = AppURLManager.shared.getAppURL(URLName: "rainviewerAPI") ?? "<Unknown Rainviewer API URL>"

    func getRainViewerOverlays(
        radarColorScheme: Int
    ) -> AnyPublisher<(
        radar: [RainViewerTileOverlay],
        infrared: [RainViewerTileOverlay]
    ), Error> {
        // We’ll fetch metadata only once, then build both overlays from it.
        guard let url = URL(string: apiURL) else {
            return Fail(error: URLError(.badURL)).eraseToAnyPublisher()
        }

        return URLSession.shared.dataTaskPublisher(for: url)
            .map(\.data)
            .decode(type: RainViewerResponse.self, decoder: JSONDecoder())
            .map { resp in
                var radarResult:    [RainViewerTileOverlay] = []
                var infraredResult: [RainViewerTileOverlay] = []

                if let lastRadar = resp.radar?.past.last {
                    radarResult = [
                        RainViewerTileOverlay(
                            host: resp.host,
                            framePath: lastRadar.path,
                            type: .radar,
                            radarColorScheme: radarColorScheme
                        )
                    ]
                }
                if let lastInfra = resp.satellite?.infrared.last {
                    infraredResult = [
                        RainViewerTileOverlay(
                            host: resp.host,
                            framePath: lastInfra.path,
                            type: .satellite,
                            radarColorScheme: radarColorScheme
                        )
                    ]
                }
                return (radar: radarResult, infrared: infraredResult)
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}

class RainViewerOverlayViewModel: ObservableObject {
    @Published var isLoading = false
    @Published var radarOverlays:    [RainViewerTileOverlay] = []
    @Published var infraredOverlays: [RainViewerTileOverlay] = []

    private let provider: RainViewerOverlayProvider
    private var cancellables = Set<AnyCancellable>()

    init(provider: RainViewerOverlayProvider = .init()) {
        self.provider = provider
    }

    func loadOverlays(radarColorScheme: Int) {
        isLoading = true

        provider
            .getRainViewerOverlays(radarColorScheme: radarColorScheme)
            .sink { [weak self] completion in
                // on error or finished, hide loader
                self?.isLoading = false
                if case .failure(let err) = completion {
                    // handle/report the error...
                    print("Failed to load overlays:", err)
                }
            } receiveValue: { [weak self] result in
                // publish the new overlays
                self?.radarOverlays    = result.radar
                self?.infraredOverlays = result.infrared
            }
            .store(in: &cancellables)
    }
}
import SwiftUI
import Combine

// Load weather codes
struct WeatherCode: Identifiable {
    let id = UUID()
    let weatherCode: Int
    let imageName: String
}

struct WeatherCodesResponse: Codable {
    let values: [[String]]
}

class WeatherCodeViewModel: ObservableObject {
    @Published var weatherCodes: [WeatherCode] = []
    private var cancellables = Set<AnyCancellable>()
    let sheetName = "WeatherCodes"
    
    func getWeatherCodes(completion: @escaping () -> Void) {
        let weatherCodesURLString = "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(sheetName)?alt=json&key=\(googleAPIKey)"
        guard let url = URL(string: weatherCodesURLString) else {
            print("Invalid URL for weather codes")
            DispatchQueue.main.async { completion() }
            return
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: WeatherCodesResponse.self, decoder: JSONDecoder())
        
            .map { response in
                response.values.dropFirst().compactMap { row in
                    guard row.count >= 2 else {
                        print("Skipping malformed weather code row: \(row)")
                        return nil
                    }
                    let code = Int(row[0]) ?? 0
                    let imageName = row[1]
                    return WeatherCode(weatherCode: code, imageName: imageName)
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .handleEvents(receiveOutput: { [weak self] codes in
                self?.weatherCodes = codes
            }, receiveCompletion: { _ in
                completion()
            })
            .sink { _ in }
            .store(in: &cancellables)
    }
    
    func weatherCodeImage(weatherCode: Int, cloudcover: Double, precipProbability: Double, tempF: Double) -> String? {
        var weatherCodeImage: String = weatherCodes.first { $0.weatherCode == weatherCode }?.imageName ?? ""
        // Adjust sun/cloud/rain weather code image based on high % precip
        if weatherCodeImage == "cloud.sun.fill" || weatherCodeImage == "sun.max.fill" || weatherCodeImage == "cloud.fill" {
            if precipProbability > 50.0 {
                if tempF < 32.0 {
                    weatherCodeImage = "cloud.snow.fill"
                } else {
                    weatherCodeImage = "cloud.rain.fill"
                }
            } else {
                if cloudcover > 70.0 {
                    weatherCodeImage = "cloud.fill"
                } else if cloudcover > 30.0 {
                    weatherCodeImage = "cloud.sun.fill"
                } else {
                    weatherCodeImage = "sun.max.fill"
                }
            }
        }
        return weatherCodeImage
    }
}
import SwiftUI
import Combine

struct StationLatestReading: Identifiable {
    let id = UUID()
    let stationID: String
    let stationName: String
    let readingsSource: String
    let stationElevation: String
    let stationLatitude: String
    let stationLongitude: String
    let windSpeed: Double?
    let windDirection: Double?
    let windGust: Double?
    let windTime: String?
}

// Structures to parse Mesonet latest readings data
struct MesonetLatestResponse: Codable {
    let station: [MesonetLatestStation]
    
    enum CodingKeys: String, CodingKey {
        case station = "STATION"
    }
}

struct MesonetLatestStation: Codable {
    let id: String
    let stationID: String
    let stationName: String
    let elevation: String
    let latitude: String
    let longitude: String
    let status: String
    let observations: MesonetLatestObservations
    
    enum CodingKeys: String, CodingKey {
        case id = "ID"
        case stationID = "STID"
        case stationName = "NAME"
        case elevation = "ELEVATION"
        case latitude = "LATITUDE"
        case longitude = "LONGITUDE"
        case status = "STATUS"
        case observations = "OBSERVATIONS"
    }
}

struct MesonetLatestObservations: Codable {
    let airTemp: MesonetLatestObservationsValues?
    let windSpeed: MesonetLatestObservationsValues?
    let windDirection: MesonetLatestObservationsValues?
    let windGust: MesonetLatestObservationsValues?
    
    enum CodingKeys: String, CodingKey {
        case airTemp = "air_temp_value_1"
        case windSpeed = "wind_speed_value_1"
        case windDirection = "wind_direction_value_1"
        case windGust = "wind_gust_value_1"
    }
}

struct MesonetLatestObservationsValues: Codable {
    let value: Double?
    let dateTime: String?
    
    enum CodingKeys: String, CodingKey {
        case value
        case dateTime = "date_time"
    }
}

struct CUASAStationData: Codable {
    var id: Int
    var name: String
    var lat: Double
    var lon: Double
}

struct CUASAReadingsData: Codable {
    var ID: String
    var timestamp: Double
    var windspeed: Double
    var windspeed_avg: Double
    var windspeed_max: Double
    var windspeed_min: Double
    var wind_direction: Double
    var wind_direction_avg: Double
    var battery_level: Double?
    var internal_temp: Double?
    var external_temp: Double?
    var current: Double?
    var pwm: Double?
}

// Decoding model for API response
struct RMHPAAPIResponse: Decodable {
    let metadata: RHMPHAMetadata
    let data: [RMHPAReadingData]
}

struct RHMPHAMetadata: Decodable {
    let name: String
    let id: String
    let device_id: String
    let timezone: String
    let lat: Double
    let lon: Double
    let elevation: Int
    let link: String
}

struct RMHPAReadingData: Decodable {
    let timestamp: String
    let absolute: Double?
    let relative: Double?
    let wind_direction: Double?
    let wind_gust: Double?
    let wind_speed: Double?
}

class StationLatestReadingViewModel: ObservableObject {
    @Published var latestSiteReadings: [StationLatestReading] = []
    @Published var latestAllReadings: [StationLatestReading] = []
    @Published var stationParameters: String = ""
    @Published var isLoading = false
    
    private var lastSiteFetchTime: Date? = nil
    private var lastAllFetchTime: Date? = nil
    private var lastFavoriteStationIDs: Set<String> = []    // Used to force a refresh if new favorite stations are added from map page
    
    let siteViewModel: SiteViewModel
    let userSettingsViewModel: UserSettingsViewModel

    init(siteViewModel: SiteViewModel,
         userSettingsViewModel: UserSettingsViewModel) {
        self.siteViewModel = siteViewModel
        self.userSettingsViewModel = userSettingsViewModel
    }
    
    // Allows forced reset when user changes regions, resets metadata, etc.
    func resetLastFetchTimes() {
        lastSiteFetchTime = nil
        lastAllFetchTime = nil
    }
    
    // sitesOnly determines whether to only get Mesonet readings for stations associated with sites (SiteView)
    // or all stations in region (MapView)
    // These are published as separate structures with separate refresh timers
    func getLatestReadingsData(sitesOnly: Bool,
                               completion: @escaping () -> Void) {
        var favoriteStationIDs: Set<String> = []
        if sitesOnly {
            // 1) Gather Mesonet stations from SiteViewModel
            let mesonetStations = siteViewModel.sites
                .filter { $0.readingsSource == "Mesonet" && !$0.readingsStation.isEmpty }
                .map { $0.readingsStation }
            
            // 2) Gather favorite Mesonet stations in current region
            let currentRegion = RegionManager.shared.activeAppRegion
            favoriteStationIDs = Set(
                userSettingsViewModel.userFavoriteSites
                    .filter {
                        $0.appRegion == currentRegion &&
                        $0.favoriteType.lowercased() == "station" &&
                        $0.readingsSource == "Mesonet" &&
                        !$0.stationID.isEmpty
                    }
                    .map { $0.stationID }
            )
            
            let allStations = Set(mesonetStations).union(favoriteStationIDs)
            if allStations.isEmpty {
                print("No Mesonet sites or favorite stations available")
                completion()
                return
            }
            self.stationParameters = allStations
                .map { "&stid=\($0)" }
                .joined()
            if printReadingsURL {
                print("Computed stationParameters: \(self.stationParameters)")
            }
        }
        
        // Check if refresh interval has passed
        let now = Date()
        let lastFetchTime = sitesOnly ? lastSiteFetchTime : lastAllFetchTime
        var shouldForceRefresh = false
        
        if sitesOnly {
            // Compare favoriteStationIDs to last fetched set
            if favoriteStationIDs != lastFavoriteStationIDs {
                shouldForceRefresh = true
                lastFavoriteStationIDs = favoriteStationIDs
            }
        }
        
        if !shouldForceRefresh, let last = lastFetchTime, now.timeIntervalSince(last) < readingsRefreshInterval {
            completion()
            return
        }
        
        // Update last fetch times
        if sitesOnly {
            lastSiteFetchTime = now
        } else {
            lastAllFetchTime = now
        }
        isLoading = true
        
        // Build API call parameters
        let regionCountry = AppRegionManager.shared.getRegionCountry() ?? ""
        let stationParams: String
        if sitesOnly {
            stationParams = self.stationParameters
        } else {
            stationParams = (regionCountry == "US")
            ? "&state=\(RegionManager.shared.activeAppRegion)"
            : "&country=\(regionCountry)"
        }
        
        // Fetch Mesonet, CUASA, RMHPA in parallel
        var combinedReadings: [StationLatestReading] = []
        let group = DispatchGroup()
        
        group.enter()
        getLatestMesonetReadings(stationParameters: stationParams) { readings in
            combinedReadings.append(contentsOf: readings)
            group.leave()
        }
        
        group.enter()
        getLatestCUASAReadings { readings in
            combinedReadings.append(contentsOf: readings)
            group.leave()
        }
        
        group.enter()
        getLatestRMHPAReadings { readings in
            combinedReadings.append(contentsOf: readings)
            group.leave()
        }

        group.notify(queue: .main) {
            if sitesOnly {
                self.latestSiteReadings = combinedReadings
            } else {
                self.latestAllReadings = combinedReadings
            }
            self.isLoading = false
            completion()
        }
    }
    
    func getLatestMesonetReadings(stationParameters: String, completion: @escaping ([StationLatestReading]) -> Void) {
        let readingsLink = AppURLManager.shared.getAppURL(URLName: "mesonetLatestReadingsAPI") ?? "<Unknown Mesonet readings API URL>"
        let updatedReadingsLink = updateURL(url: readingsLink, parameter: "stationlist", value: stationParameters) + synopticsAPIToken
        guard let url = URL(string: updatedReadingsLink) else { return }
        if printReadingsURL {
            print("Latest readings stationParameters: \(stationParameters)")
            print("Latest readings URL: \(url)")
        }
        URLSession.shared.dataTask(with: url) { data, response, error in
            DispatchQueue.main.async {
                guard let data = data, error == nil else { return }
                do {
                    let decodedResponse = try JSONDecoder().decode(MesonetLatestResponse.self, from: data)
                    let latestReadings: [StationLatestReading] = decodedResponse.station.compactMap { station in
                        guard let _ = station.observations.windSpeed?.value,
                              let _ = station.observations.windSpeed?.dateTime
                        else { return nil }
                        return StationLatestReading(
                            stationID:          station.stationID,
                            stationName:        station.stationName,
                            readingsSource:     "Mesonet",
                            stationElevation:   station.elevation,
                            stationLatitude:    station.latitude,
                            stationLongitude:   station.longitude,
                            windSpeed:          station.observations.windSpeed?.value,
                            windDirection:      station.observations.windDirection?.value,
                            windGust:           station.observations.windGust?.value,
                            windTime:           station.observations.windSpeed?.dateTime
                        )
                    }
                    DispatchQueue.main.async {
                        completion(latestReadings)
                    }
                } catch {
                    print("Failed to decode JSON: \(error)")
                    DispatchQueue.main.async {
                        completion([])
                    }
                }
            }
        }.resume()
    }
    
    func getLatestCUASAReadings(completion: @escaping ([StationLatestReading]) -> Void) {
        let CUASAStations = Array(
            Dictionary(grouping: siteViewModel.sites.filter { $0.readingsSource == "CUASA" }, by: { $0.readingsStation })
                .compactMap { $0.value.first }
        )
        guard !CUASAStations.isEmpty else {
            if printReadingsURL {
                print("CUASA stations are empty")
            }
            completion([])
            return
        }

        var collectedReadings: [StationLatestReading] = []
        let group = DispatchGroup()

        let readingInterval: Double = 5 * 60
        let readingEnd = Date().timeIntervalSince1970
        let readingStart = readingEnd - readingInterval

        for station in CUASAStations {
            group.enter()
            let readingsLink = AppURLManager.shared.getAppURL(URLName: "CUASAStationInfoAPI") ?? "<Unknown CUASA station info API URL>"
            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: station.readingsStation)
            if printReadingsURL {
                print("CUASA station info URL: \(updatedReadingsLink)")
            }
            guard let stationInfoURL = URL(string: updatedReadingsLink) else {
                group.leave()
                continue
            }

            URLSession.shared.dataTask(with: stationInfoURL) { data, response, error in
                guard let data = data, error == nil else {
                    DispatchQueue.main.async { group.leave() }
                    return
                }

                do {
                    let CUASAStationInfo = try JSONDecoder().decode(CUASAStationData.self, from: data)
                    let readingsLink = AppURLManager.shared.getAppURL(URLName: "CUASAHistoryReadingsAPI") ?? "<Unknown CUASA readings history API URL>"
                    var updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: station.readingsStation)
                    updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingStart", value: String(readingStart))
                    updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingEnd", value: String(readingEnd))
                    updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingInterval", value: String(readingInterval))
                    guard let readingsURL = URL(string: updatedReadingsLink) else {
                        DispatchQueue.main.async { group.leave() }
                        return
                    }

                    if printReadingsURL {
                        print("Latest CUASA readings URL: \(readingsURL)")
                    }

                    URLSession.shared.dataTask(with: readingsURL) { data, response, error in
                        DispatchQueue.main.async {
                            defer { group.leave() }
                            guard let data = data, error == nil else { return }

                            do {
                                let readingsDataArray = try JSONDecoder().decode([CUASAReadingsData].self, from: data)
                                if let latestData = readingsDataArray.max(by: { $0.timestamp < $1.timestamp }) {
                                    let date = Date(timeIntervalSince1970: latestData.timestamp)
                                    let formatter = DateFormatter()
                                    formatter.dateFormat = "h:mm"
                                    let formattedTime = formatter.string(from: date)

                                    let newReading = StationLatestReading(
                                        stationID: latestData.ID,
                                        stationName: CUASAStationInfo.name,
                                        readingsSource: "CUASA",
                                        stationElevation: station.readingsAlt,
                                        stationLatitude: String(CUASAStationInfo.lat),
                                        stationLongitude: String(CUASAStationInfo.lon),
                                        windSpeed: convertKMToMiles(latestData.windspeed_avg).rounded(),
                                        windDirection: latestData.wind_direction_avg,
                                        windGust: convertKMToMiles(latestData.windspeed_max).rounded(),
                                        windTime: formattedTime
                                    )

                                    collectedReadings.append(newReading)  // Add to local array
                                }
                            } catch {
                                print("Error decoding CUASA readings: \(error)")
                            }
                        }
                    }.resume()
                } catch {
                    print("CUASA station info decoding error: \(error)")
                    DispatchQueue.main.async { group.leave() }
                }
            }.resume()
        }

        group.notify(queue: .main) {
            completion(collectedReadings)  // Return combined array
        }
    }

    func getLatestRMHPAReadings(completion: @escaping ([StationLatestReading]) -> Void) {

        let RMHPAStations = Array(
            Dictionary(grouping: siteViewModel.sites.filter { $0.readingsSource == "RMHPA" }, by: { $0.readingsStation })
                .compactMap { $0.value.first }
        )
        guard !RMHPAStations.isEmpty else {
            if printReadingsURL {
                print("RMHPA stations are empty")
            }
            completion([])
            return
        }

        var collectedReadings: [StationLatestReading] = []
        let group = DispatchGroup()

        for station in RMHPAStations {
            group.enter()
            let readingsLink = AppURLManager.shared.getAppURL(URLName: "RMHPALatestReadingsAPI") ?? "<Unknown RMHPA latest readings API URL>"
            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: station.readingsStation)
            
            if printReadingsURL {
                print("RMHPA latest readings URL: \(updatedReadingsLink)")
            }

            guard let latestReadingsURL = URL(string: updatedReadingsLink) else {
                group.leave()
                continue
            }
            
            var request = URLRequest(url: latestReadingsURL)
            request.httpMethod = "GET"
            request.setValue(RMHPAAPIKey, forHTTPHeaderField: "x-api-key")
            request.setValue("application/json", forHTTPHeaderField: "Accept")

            URLSession.shared.dataTask(with: request) { data, response, error in
                DispatchQueue.main.async {
                    defer { group.leave() }
                    guard
                        let data = data,
                        let apiResponse = try? JSONDecoder().decode(RMHPAAPIResponse.self, from: data),
                        let reading = apiResponse.data.first
                    else {
                        print("Error getting valid RMHPA response for station: \(station.readingsStation); error: \(String(describing: error))")
                        return
                    }
                    let metadata = apiResponse.metadata

                    // Get time from data in format: "2025-07-31T05:45:00.000"
                    var formattedTime = ""
                    let inputFormatter = DateFormatter()
                    inputFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
                    inputFormatter.timeZone = TimeZone(secondsFromGMT: 0) // 'Z' means UTC

                    let outputFormatter = DateFormatter()
                    outputFormatter.dateFormat = "h:mm"
                    if let date = inputFormatter.date(from: reading.timestamp) {
                        formattedTime = outputFormatter.string(from: date)
                    }
                    
                    let newReading = StationLatestReading(
                        stationID:          metadata.device_id,
                        stationName:        metadata.name,
                        readingsSource:     "RMHPA",
                        stationElevation:   String(metadata.elevation),
                        stationLatitude:    String(metadata.lat),
                        stationLongitude:   String(metadata.lon),
                        windSpeed:          reading.wind_speed,         // Provided in mph
                        windDirection:      reading.wind_direction,
                        windGust:           reading.wind_gust,          // Provided in mph
                        windTime:           formattedTime
                    )
                    collectedReadings.append(newReading)
                }
            }.resume()
        }
        
        group.notify(queue: .main) {
            completion(collectedReadings)  // Return combined array
        }
 
    }
}
import SwiftUI
import Combine

struct DailyForecastData: Codable {
    var elevation: Double
    var daily: Daily
}

struct Daily: Codable {
    let time: [String]
    let weather_code: [Int]
    let temperature_2m_max: [Double]
    let temperature_2m_min: [Double]
    let precipitation_sum: [Double]
    let precipitation_probability_max: [Int]
    let wind_speed_10m_mean: [Double]
    let wind_gusts_10m_mean: [Double]
    let wind_direction_10m_dominant: [Int]
    let cloud_cover_mean: [Int]
    let cloud_cover_max: [Int]
    let cloud_cover_min: [Int]
    var forecastDay: [String]?
    var forecastDate: [String]?
    var weatherCodeImage: [String]?
    var formattedMinTemp: [String]?
    var formattedMaxTemp: [String]?
    var precipImage: [String]?
}

class DailyForecastViewModel: ObservableObject {
    @Published var dailyForecastData: DailyForecastData?
    private var weatherCodesViewModel: WeatherCodeViewModel
    private var cancellable: AnyCancellable?
    
    // Make weather code images available in this view model
    init(weatherCodesViewModel: WeatherCodeViewModel) { self.weatherCodesViewModel = weatherCodesViewModel }

    func fetchDailyWeatherData(latitude: String,
                               longitude: String) {
        
        let encodedTimezone = AppRegionManager.shared.getRegionEncodedTimezone() ?? ""
        let baseDailyForecastURL = AppURLManager.shared.getAppURL(URLName: "dailyForecastURL") ?? "<Unknown daily forecast URL>"
        var updatedDailyForecastURL = updateURL(url: baseDailyForecastURL, parameter: "latitude", value: latitude)
        updatedDailyForecastURL = updateURL(url: updatedDailyForecastURL, parameter: "longitude", value: longitude)
        updatedDailyForecastURL = updateURL(url: updatedDailyForecastURL, parameter: "encodedTimezone", value: encodedTimezone)
        if printForecastURL { print(updatedDailyForecastURL) }
        guard let dailyForecastURL = URL(string: updatedDailyForecastURL) else { return }
        URLSession.shared.dataTask(with: dailyForecastURL) { [weak self] data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                // Remove occasional value of null in the results
                let modifiedData = replaceNullsInJSON(data: data)
                // Uses the original data as the default if the removal of nulls failed
                if let dailyForecastData = try? decoder.decode(DailyForecastData.self, from: modifiedData ?? data) {
                    DispatchQueue.main.async {
                        let dateFormatter = DateFormatter()
                        dateFormatter.dateFormat = "yyyy-MM-dd"
                        let dayFormatter = DateFormatter()
                        dayFormatter.dateFormat = "E"
                        let shortDateFormatter = DateFormatter()
                        shortDateFormatter.dateFormat = "M/d"
                        
                        // Initialize optional data arrays
                        var forecastDay = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        var forecastDate = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        var weatherCodeImage = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        var formattedMaxTemp = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        var formattedMinTemp = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        var precipImage = [String](repeating: "", count: dailyForecastData.daily.time.count)
                        
                        for index in 0..<dailyForecastData.daily.time.count {
                            let date = dateFormatter.date(from: dailyForecastData.daily.time[index])
                            forecastDay[index] = dayFormatter.string(from: date ?? Date())
                            forecastDate[index] = shortDateFormatter.string(from: date ?? Date())
                            formattedMaxTemp[index] = String(Int(dailyForecastData.daily.temperature_2m_max[index].rounded()))
                            formattedMinTemp[index] = String(Int(dailyForecastData.daily.temperature_2m_min[index].rounded()))
                            
                            // Set weather code image
                            weatherCodeImage[index] = self?.weatherCodesViewModel.weatherCodeImage (
                                weatherCode: Int(dailyForecastData.daily.weather_code[index]),
                                cloudcover: Double(dailyForecastData.daily.cloud_cover_mean[index]),
                                precipProbability: Double(dailyForecastData.daily.precipitation_probability_max[index]),
                                tempF: (dailyForecastData.daily.temperature_2m_max[index])
                            ) ?? ""

                            // Set precip image
                            precipImage[index] = "drop.fill"
                            if Int(dailyForecastData.daily.temperature_2m_max[index].rounded()) <= 32 {
                                precipImage[index] = "snowflake"
                            }
                        }
                        
                        // Assign the initialized arrays to the dailyForecastData
                        var updatedDaily = dailyForecastData.daily
                        updatedDaily.forecastDay = forecastDay
                        updatedDaily.forecastDate = forecastDate
                        updatedDaily.weatherCodeImage = weatherCodeImage
                        updatedDaily.formattedMaxTemp = formattedMaxTemp
                        updatedDaily.formattedMinTemp = formattedMinTemp
                        updatedDaily.precipImage = precipImage
                        self?.dailyForecastData = DailyForecastData(elevation: dailyForecastData.elevation, daily: updatedDaily)
                    }
                } else {
                    print("JSON decode failed for forecast")
                }
            }
        }.resume()
    }
}
import SwiftUI
import Combine

// Note:  Use the globally available function calls in AppRegionManager to access data

struct AppRegion {
    let appRegion: String                   // Two digit code for U.S. states (used in Synoptics station map call)
                                            // AppRegion must be unique (without appCountry); so do not use US states for other regions
    let appCountry: String                  // Two or three digit country code (US, CA, MX, NZ, etc.) (used in Synoptics station map call)
    let appRegionName: String
    let appRegionGoogleSheetID: String
    let timezone: String                    // Use TZ Identifier values from: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    let sunriseLatitude: Double
    let sunriseLongitude: Double
    let mapInitLatitude: Double             // Center point for map on initial opening
    let mapInitLongitude: Double
    let mapInitLatitudeSpan: Double         // Size of map on initial opening
    let mapInitLongitudeSpan: Double        // mapInitLatitudeSpan * 1.5
    let mapDefaultZoomLevel: Double
    let appRegionStatus: String             // "Development" or blank
}

struct AppRegionResponse: Codable {
    let values: [[String]]
}

class AppRegionViewModel: ObservableObject {
    @Published var appRegions: [AppRegion] = []
    private var cancellables = Set<AnyCancellable>()
    let sheetName = "Regions"
    
    func getAppRegions(completion: @escaping () -> Void) {
        let appRegionsURLString = "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(sheetName)?alt=json&key=\(googleAPIKey)"
        guard let url = URL(string: appRegionsURLString) else {
            print("Invalid URL for app regions")
            DispatchQueue.main.async { completion() }
            return
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: AppRegionResponse.self, decoder: JSONDecoder())
        
            .map { response -> [AppRegion] in
                response.values.dropFirst().compactMap { row in
                    guard row.count >= 5 else {
                        print("Skipping malformed app region row: \(row)")
                        return nil
                    }
                    let appRegion               = row[0]
                    let appCountry              = row[1]
                    let appRegionName           = row[2]
                    let appRegionGoogleSheetID  = row[3]
                    let timezone                = row[4]
                    let sunriseLatitude         = row.count > 5 ? Double(row[5]) ?? 0.0 : 0.0
                    let sunriseLongitude        = row.count > 6 ? Double(row[6]) ?? 0.0 : 0.0
                    let mapInitLatitude         = row.count > 7 ? Double(row[7]) ?? 0.0 : 0.0
                    let mapInitLongitude        = row.count > 8 ? Double(row[8]) ?? 0.0 : 0.0
                    let mapInitLatitudeSpan     = row.count > 9 ? Double(row[9]) ?? 0.0 : 0.0
                    let mapInitLongitudeSpan    = row.count > 10 ? Double(row[10]) ?? 0.0 : 0.0
                    let mapDefaultZoomLevel     = row.count > 11 ? Double(row[11]) ?? 0.0 : 0.0
                    let appRegionStatus         = row.count > 12 ? row[12] : ""
                    
                    // Make sure region, country, name, Google sheet, and time zone are populated
                    guard !appRegion.isEmpty,
                          !appCountry.isEmpty,
                          !appRegionName.isEmpty,
                          !appRegionGoogleSheetID.isEmpty,
                          !timezone.isEmpty else {
                        print("Skipping app region row with missing critical fields: \(row)")
                        return nil
                    }
                    
                    return AppRegion(appRegion:                 appRegion,
                                     appCountry:                appCountry,
                                     appRegionName:             appRegionName,
                                     appRegionGoogleSheetID:    appRegionGoogleSheetID,
                                     timezone:                  timezone,
                                     sunriseLatitude:           sunriseLatitude,
                                     sunriseLongitude:          sunriseLongitude,
                                     mapInitLatitude:           mapInitLatitude,
                                     mapInitLongitude:          mapInitLongitude,
                                     mapInitLatitudeSpan:       mapInitLatitudeSpan,
                                     mapInitLongitudeSpan:      mapInitLongitudeSpan,
                                     mapDefaultZoomLevel:       mapDefaultZoomLevel,
                                     appRegionStatus:           appRegionStatus
                    )
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)

            // Save regions globally so they can be accessed from anywhere in the app
            .handleEvents(receiveOutput: { [weak self] appRegions in
                self?.appRegions = appRegions
                AppRegionManager.shared.setAppRegions(appRegions) // global set
            }, receiveCompletion: { _ in
                completion()
            })
        
            .sink { _ in }
            .store(in: &cancellables)
    }
    
}
import SwiftUI
import Combine
import SwiftJWT

// Get pilots for live tracking
struct Pilot: Codable, Identifiable, Equatable {
    var id = UUID()
    var pilotName: String
    var inactive: Bool
    var trackingShareURL: String
    var trackingFeedURL: String
}

struct PilotsResponse: Codable {
    let values: [[String]]
}

class PilotViewModel: ObservableObject {
    @Published var pilots: [Pilot] = []
    private var cancellables = Set<AnyCancellable>()
    
    func getPilots(completion: @escaping () -> Void) {
        
        let rangeName = "Pilots"
        
        // Build region sheet pilots URL
        guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
              let regionURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)")
        else {
            print("Invalid or missing region Google Sheet ID for region: \(RegionManager.shared.activeAppRegion)")
            DispatchQueue.main.async { completion() }
            return
        }
        
        URLSession.shared.dataTaskPublisher(for: regionURL)
            .map { $0.data }
            .decode(type: PilotsResponse.self, decoder: JSONDecoder())
            .map { response in
                response.values.dropFirst().compactMap { row -> Pilot? in
                    // Skip row if data missing
                    guard row.count >= 2
                    else {
                        print("Skipping malformed pilot row: \(row)")
                        return nil
                    }
                    
                    let pilotName = row[0]
                    let trackingShareURL = row[1]
                    
                    // Set inactive to true if inactive column is populated
                    let inactive = (row.count > 2 && row[2].lowercased() == "yes")
                    
                    // Check for a valid share URL format
                    guard trackingShareURL.contains("https://share.garmin.com/")
                    else {
                        print("Skipping malformed InReach share URL for row: \(row)")
                        return nil
                    }
                    
                    // Extract pilot name from the share URL
                    let pilotNameFromURL = trackingShareURL.components(separatedBy: "/").last ?? ""
                    let trackingFeedURL = "https://share.garmin.com/Feed/Share/\(pilotNameFromURL)"
                    
                    return Pilot(
                        pilotName: pilotName,
                        inactive: inactive,
                        trackingShareURL: trackingShareURL,
                        trackingFeedURL: trackingFeedURL
                    )
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)
            .handleEvents(receiveOutput: { [weak self] pilots in
                self?.pilots = pilots
            }, receiveCompletion: { _ in
                completion()
            })
            .sink { _ in }
            .store(in: &cancellables)
    }
    
    func trackingShareURL(for pilotName: String) -> String? {
        return pilots.first(where: { $0.pilotName == pilotName })?.trackingShareURL
    }

    func addPilot(pilotName: String,
                  trackingShareURL: String) {
        
        // Get an OAuth token
        fetchAccessToken { token in
            guard let token = token
            else {
                DispatchQueue.main.async {
                    print("Failed to get access token")
                }
                return
            }
            
            // Construct append URL
            let range = "Pilots"
            guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
                  let regionURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(range):append?valueInputOption=RAW")
            else {
                print("Cannot append pilot; invalid or missing region Google Sheet ID for region: \(RegionManager.shared.activeAppRegion)")
                return
            }

            // Construct append data
            let values = [[ pilotName, trackingShareURL ]]
            let body: [String: Any] = ["values": values]
            let jsonData = try! JSONSerialization.data(withJSONObject: body)
            
            // Structure API call
            var request = URLRequest(url: regionURL)
            request.httpMethod = "POST"
            request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.httpBody = jsonData
            
            // Perform API call
            URLSession.shared.dataTask(with: request) { _, resp, err in
                DispatchQueue.main.async {
                    if let err = err {
                        print("Error: \(err.localizedDescription)")
                    } else if let code = (resp as? HTTPURLResponse)?.statusCode, code == 200 {
                        // Pilot added successfully
                    } else {
                        print("Failed to add pilot: \(pilotName)")
                        print("Status code: \(String(describing: (resp as? HTTPURLResponse)?.statusCode))")
                        print("Posting to URL: \(regionURL)")
                    }
                }
            }.resume()
        }
    }
    
    func setPilotActiveStatus(pilot: Pilot,
                              isInactive: Bool) {
        
        // Get an OAuth token
        fetchAccessToken { token in
            guard let token = token
            else {
                DispatchQueue.main.async {
                    print("Failed to get access token")
                }
                return
            }

            // Read the existing Pilots sheet to find the row index
            let range = "Pilots"
            guard let regionGoogleSheetID = AppRegionManager.shared.getRegionGoogleSheet(),
                  let readURL = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(range)")
            else {
                print("Cannot get pilot data; invalid or missing region Google Sheet ID for region: \(RegionManager.shared.activeAppRegion)")
                return
            }

            var readReq = URLRequest(url: readURL)
            readReq.httpMethod = "GET"
            readReq.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

            URLSession.shared.dataTask(with: readReq) { data, resp, err in
                guard err == nil,
                      let data = data,
                      let http = resp as? HTTPURLResponse, http.statusCode == 200
                else {
                    DispatchQueue.main.async { print("Failed to read sheet: \(err?.localizedDescription ?? "HTTP \( (resp as? HTTPURLResponse)?.statusCode ?? -1 )")") }
                    return
                }

                // Decode into a simple ValuesResponse
                struct ValuesResponse: Decodable { let values: [[String]] }
                guard let sheet = try? JSONDecoder().decode(ValuesResponse.self, from: data) else {
                    DispatchQueue.main.async { print("Couldn't decode sheet values") }
                    return
                }

                // Find the one row where column A matches the pilot name
                if let rowIndex = sheet.values.firstIndex(where: { $0.first == pilot.pilotName }) {
                    let sheetRow = rowIndex + 1      // +1 because Sheets rows are 1-based

                    // Update column C ("Inactive") of that row
                    let updateRange = "Pilots!C\(sheetRow)"   // column C = row[2]
                    let updateURLstr = "https://sheets.googleapis.com/v4/spreadsheets/\(regionGoogleSheetID)/values/\(updateRange)?valueInputOption=RAW"
                    guard let updateURL = URL(string: updateURLstr) else { return }

                    // Set inactive status to "Yes" or empty (cleared out)
                    var body: [String: Any] = ["values": [[""]]]    // a single empty string to clear
                    if isInactive {
                        body = ["values": [["Yes"]]]
                    }
                    
                    let jsonData = try! JSONSerialization.data(withJSONObject: body, options: [])

                    var updateReq = URLRequest(url: updateURL)
                    updateReq.httpMethod = "PUT"   // use PUT for updates
                    updateReq.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    updateReq.setValue("application/json", forHTTPHeaderField: "Content-Type")
                    updateReq.httpBody = jsonData

                    URLSession.shared.dataTask(with: updateReq) { _, resp2, err2 in
                        DispatchQueue.main.async {
                            if let err2 = err2 {
                                print("Error updating pilot inactive status: \(err2)")
                            } else if let code = (resp2 as? HTTPURLResponse)?.statusCode, code == 200 {
                                print("Pilot \(pilot.pilotName) inactive status updated")
                            } else {
                                print("Failed to update pilot inactive status row: HTTP \((resp2 as? HTTPURLResponse)?.statusCode ?? -1)")
                            }
                        }
                    }
                    .resume()

                } else {
                    DispatchQueue.main.async {
                        print("Pilot “\(pilot.pilotName)” not found in sheet.")
                    }
                }
            }
            .resume()
        }
    }
    
    // OAuth2 via service accounting using SwiftJWT
    func fetchAccessToken(completion: @escaping (String?) -> Void) {
        guard let sa = loadServiceAccount() else {
            print("Could not load service account")
            return completion(nil)
        }
        
        guard let jwt = makeJWT(serviceAccount: sa) else {
            print("JWT creation failed")
            return completion(nil)
        }
        
        guard let url = URL(string: sa.token_uri) else {
            print("Invalid token URI")
            return completion(nil)
        }
        
        var req = URLRequest(url: url)
        req.httpMethod = "POST"
        let bodyString = "grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer&assertion=\(jwt)"
        req.httpBody = bodyString.data(using: .utf8)
        req.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        
        URLSession.shared.dataTask(with: req) { data, resp, err in
            if let err = err {
                print("HTTP error:", err)
                return completion(nil)
            }
            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data) as? [String:Any],
                  let token = json["access_token"] as? String else {
                print("Invalid token response:", String(data: data ?? Data(), encoding: .utf8) ?? "")
                return completion(nil)
            }
            completion(token)
        }.resume()
    }
    
    func makeJWT(serviceAccount sa: ServiceAccount) -> String? {
        struct GoogleClaims: Claims {
            let iss: String
            let scope: String
            let aud: String
            let iat: Date
            let exp: Date
        }
        
        let now = Date()
        let claims = GoogleClaims(
            iss: sa.client_email,
            scope: "https://www.googleapis.com/auth/spreadsheets",
            aud: sa.token_uri,
            iat: now,
            exp: now.addingTimeInterval(3600)
        )
        
        var jwt = JWT(header: Header(), claims: claims)
        
        // Convert PEM string to Data
        let pemData = Data(sa.private_key.utf8)
        
        // Create a JWTSigner (SwiftJWT 3.x API)
        let signer = JWTSigner.rs256(privateKey: pemData)
        
        // Sign
        return try? jwt.sign(using: signer)
    }
    
    func loadServiceAccount() -> ServiceAccount? {
        guard let url = Bundle.main.url(forResource: "service-account", withExtension: "json"),
              let data = try? Data(contentsOf: url),
              let sa = try? JSONDecoder().decode(ServiceAccount.self, from: data)
        else {
            print("Could not load/parse service-account.json")
            return nil
        }
        return sa
    }
}

struct ServiceAccount: Decodable {
    let client_email: String
    let private_key: String
    let token_uri: String
}

import SwiftUI
import Combine
import Charts

struct ReadingsData: Codable {
    let STATION: [Station]
}

struct Station: Codable {
    let OBSERVATIONS: Observations
}

struct Observations: Codable {
    let date_time: [String]
    let wind_speed_set_1: [Double?]
    let wind_gust_set_1: [Double?]?
    let wind_direction_set_1: [Double]
}

struct ReadingsHistoryData {
    var times: [String]
    var windSpeed: [Double]
    var windGust: [Double?]
    var windDirection: [Double]
    var errorMessage: String?
}

class StationReadingsHistoryDataModel: ObservableObject {
    @Published var readingsHistoryData = ReadingsHistoryData(
        times: [],
        windSpeed: [],
        windGust: [],
        windDirection: [],
        errorMessage: nil
    )
    private var cancellable: AnyCancellable?
    private var cancellables = Set<AnyCancellable>()
    
    func GetReadingsHistoryData(stationID: String, readingsSource: String) {
        switch readingsSource {
        case "Mesonet":
            let readingsLink = AppURLManager.shared.getAppURL(URLName: "mesonetHistoryReadingsAPI") ?? "<Unknown Mesonet readings history API URL>"
            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: stationID) + synopticsAPIToken
            let url = URL(string: updatedReadingsLink)!
            if printReadingsURL { print(url) }
            cancellable = URLSession.shared.dataTaskPublisher(for: url)
                .map { $0.data }
                .map { data in
                    // Convert data to string, replace "null" with "0.0", and convert back to data
                    if var jsonString = String(data: data, encoding: .utf8) {
                        jsonString = jsonString.replacingOccurrences(of: "null", with: "0.0")
                        return Data(jsonString.utf8)
                    }
                    return data
                }
                .decode(type: ReadingsData.self, decoder: JSONDecoder())
                .replaceError(with: ReadingsData(STATION: []))
                .receive(on: DispatchQueue.main)
                .sink { [weak self] data in
                    guard let self = self, let station = data.STATION.first else {
                        print("No valid data found for station: \(stationID)")
                        self?.readingsHistoryData.errorMessage = "No valid data found for station: \(stationID)"
                        return
                    }
                    let recentTimes = Array(station.OBSERVATIONS.date_time.suffix(8))
                    let recentWindSpeed = Array(station.OBSERVATIONS.wind_speed_set_1.suffix(8)).map { $0 ?? 0.0 }
                    let recentWindGust = station.OBSERVATIONS.wind_gust_set_1?.suffix(8).map { $0 ?? 0.0 } ?? Array(repeating: nil, count: 8)
                    let recentWindDirection = Array(station.OBSERVATIONS.wind_direction_set_1.suffix(8))
                    if let latestTimeString = recentTimes.last,
                       let latestTime = ISO8601DateFormatter().date(from: latestTimeString),
                       Date().timeIntervalSince(latestTime) > 2 * 60 * 60 {
                        self.readingsHistoryData.errorMessage = "Station \(stationID) has not updated in the past 2 hours"
                        print("Station \(stationID) has not updated in the past 2 hours")
                    } else {
                        self.readingsHistoryData.times = recentTimes
                        self.readingsHistoryData.windSpeed = recentWindSpeed
                        self.readingsHistoryData.windGust = recentWindGust
                        self.readingsHistoryData.windDirection = recentWindDirection
                        self.readingsHistoryData.errorMessage = nil
                    }
                }

        case "CUASA":
            let readingInterval: Double = 5 * 60 // 5 minutes in seconds
            let readingEnd = Date().timeIntervalSince1970 // current timestamp in seconds
            let readingStart = readingEnd - (readingInterval * 10) // to ensure >= 8 readings
            let readingsLink = AppURLManager.shared.getAppURL(URLName: "CUASAHistoryReadingsAPI") ?? "<Unknown CUASA readings history API URL>"
            var updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: stationID)
            updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingStart", value: String(readingStart))
            updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingEnd", value: String(readingEnd))
            updatedReadingsLink = updateURL(url: updatedReadingsLink, parameter: "readingInterval", value: String(readingInterval))

            guard let url = URL(string: updatedReadingsLink) else {
                self.readingsHistoryData.errorMessage = "Invalid CUASA readings URL"
                print("Invalid CUASA readings URL")
                return
            }
            if printReadingsURL { print(url) }
            URLSession.shared.dataTaskPublisher(for: url)
                .map { $0.data }
                .decode(type: [CUASAReadingsData].self, decoder: JSONDecoder())
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { completion in
                    switch completion {
                    case .failure(let error):
                        self.readingsHistoryData.errorMessage = error.localizedDescription
                        print("Error fetching CUASA data: \(error.localizedDescription)")
                    case .finished:
                        break
                    }
                }, receiveValue: { [weak self] readingsHistoryDataArray in
                    self?.processCUASAReadingsHistoryData(readingsHistoryDataArray)
                })
                .store(in: &cancellables)

        case "RMHPA":
            let readingsLink = AppURLManager.shared.getAppURL(URLName: "RMHPAHistoryReadingsAPI") ?? "<Unknown RMHPA readings history API URL>"
            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: stationID)
            guard let url = URL(string: updatedReadingsLink) else {
                self.readingsHistoryData.errorMessage = "Invalid RMHPA readings URL"
                print("Invalid RMHPA readings URL")
                return
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "GET"
            request.setValue(RMHPAAPIKey, forHTTPHeaderField: "x-api-key")
            request.setValue("application/json", forHTTPHeaderField: "Accept")

            if printReadingsURL { print(url) }
            URLSession.shared.dataTaskPublisher(for: request)
                .map { $0.data }
                .decode(type: RMHPAAPIResponse.self, decoder: JSONDecoder())
                .receive(on: DispatchQueue.main)
                .sink(receiveCompletion: { completion in
                    switch completion {
                    case .failure(let error):
                        self.readingsHistoryData.errorMessage = error.localizedDescription
                        print("Error fetching RMHPA data: \(error.localizedDescription)")
                    case .finished:
                        break
                    }
                }, receiveValue: { [weak self] response in
                    self?.processRMHPAReadingHistoryData(response.data)
                })
                .store(in: &cancellables)
        default:
            print("Invalid readings source for station: \(stationID)")
        }
    }
    
    private func processCUASAReadingsHistoryData(_ readingsHistoryDataArray: [CUASAReadingsData]) {
        guard let latestEntry = readingsHistoryDataArray.last else {
            self.readingsHistoryData.errorMessage = "No data available"
            print("No data available from CUASA")
            return
        }
        let currentTime = Date().timeIntervalSince1970
        let twoHoursInSeconds: Double = 2 * 60 * 60
        if currentTime - latestEntry.timestamp > twoHoursInSeconds {
            self.readingsHistoryData.errorMessage = "Station has not updated in the past 2 hours"
            print("Station has not updated in the past 2 hours")
            return
        }
        let recentEntries = Array(readingsHistoryDataArray.suffix(8))
        updateCUASAReadingsHistory(with: recentEntries)
    }
    
    private func processRMHPAReadingHistoryData(_ readingsHistoryDataArray: [RMHPAReadingData]) {

        guard let latestEntry = readingsHistoryDataArray.last else {
            self.readingsHistoryData.errorMessage = "No data available"
            print("No data available from RMHPA")
            return
        }

        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
        formatter.timeZone = TimeZone(secondsFromGMT: 0) // 'Z' means UTC

        // Make sure there is a recent reading
        let twoHoursInSeconds: Double = 2 * 60 * 60
        if let latestReadingTimestamp = formatter.date(from: latestEntry.timestamp) {
            if Date().timeIntervalSince(latestReadingTimestamp) > twoHoursInSeconds {
                self.readingsHistoryData.errorMessage = "Station has not updated in the past 2 hours"
                print("Station has not updated in the past 2 hours")
                return
            }
        } else {
            self.readingsHistoryData.errorMessage = "Could not parse timestamp: \(latestEntry.timestamp)"
            print("Failed to parse timestamp")
            return
        }
        let recentEntries = Array(readingsHistoryDataArray.suffix(8))
        updateRMHPAReadingHistory(with: recentEntries)
    }

    
    private func updateCUASAReadingsHistory(with readingsHistoryDataArray: [CUASAReadingsData]) {
        var times = [String]()
        var windSpeed = [Double]()
        var windGust = [Double?]()
        var windDirection = [Double]()
        for data in readingsHistoryDataArray {
            let date = Date(timeIntervalSince1970: data.timestamp)
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "H:mm"
            times.append(dateFormatter.string(from: date))
            windSpeed.append(convertKMToMiles(data.windspeed_avg))
            windGust.append(convertKMToMiles(data.windspeed_max))
            windDirection.append(data.wind_direction_avg)
        }
        self.readingsHistoryData = ReadingsHistoryData(
            times: times,
            windSpeed: windSpeed,
            windGust: windGust,
            windDirection: windDirection,
            errorMessage: nil
        )
    }
    
    private func updateRMHPAReadingHistory(with readingsHistoryDataArray: [RMHPAReadingData]) {
        var times = [String]()
        var windSpeed = [Double]()
        var windGust = [Double?]()
        var windDirection = [Double]()
        for data in readingsHistoryDataArray {
            
            // Get time from data in format: "2025-07-31T05:45:00.000"
            var formattedTime = ""
            let inputFormatter = DateFormatter()
            inputFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
            inputFormatter.timeZone = TimeZone(secondsFromGMT: 0) // 'Z' means UTC
            let outputFormatter = DateFormatter()
            outputFormatter.dateFormat = "h:mm"
            if let date = inputFormatter.date(from: data.timestamp) {
                formattedTime = outputFormatter.string(from: date)
            }
            
            // Append data for each history reading
            times.append(formattedTime)
            windSpeed.append(data.wind_speed ?? 0.0)
            windGust.append(data.wind_gust)
            windDirection.append(data.wind_direction ?? 0.0)
        }
        self.readingsHistoryData = ReadingsHistoryData(
            times: times,
            windSpeed: windSpeed,
            windGust: windGust,
            windDirection: windDirection,
            errorMessage: nil
        )
    }

}
import SwiftUI
import Combine

// "Basic" Soaring Forecast and Sounding for locations that do not use summer/winter soaring forecasts

struct SoaringForecastBasic: Identifiable {
    let id = UUID()
    let date: String
    let soaringForecastFormat: String
    let basicSoaringForecastData: [BasicSoaringForecastData]
    let basicLiftData: [BasicLiftData]
    let basicSoundingData: [BasicSoundingData]
    let forecastMaxTemp: Int
}

struct BasicSoaringForecastData: Identifiable {
    let id = UUID()
    let heading: String
    let value: String?
}
    
struct BasicLiftData: Identifiable {
    let id = UUID()
    let altitude: String
    let thermalIndex: Double
    let tempOfConvection: Int       // Fahrenheit
    let liftRate: Double            // Converted to m/s
}
    
struct BasicSoundingData: Identifiable {
    let id = UUID()
    let altitude: String
    let amWindDirection: Int
    let amWindSpeed: Int            // converted to mph
    let pmWindDirection: Int
    let pmWindSpeed: Int            // converted to mph
}
    
struct BasicModelData: Identifiable {
    let id = UUID()
    let value: String
}

class SoaringForecastBasicViewModel: ObservableObject {
    @Published var soaringForecastBasic: SoaringForecastBasic?
    @Published var isLoading = false
    
    func fetchSoaringForecast(airportCode: String) {
        isLoading = true
        
        // Get base URL, update parameters, and format into URL format
        guard let baseURL = AppURLManager.shared.getAppURL(URLName: "soaringForecastBasic") else {
            print("Could not find basic soaring forecast URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        let updatedURL = updateURL(url: baseURL, parameter: "airportcode", value: airportCode)
        
        // Format URL
        guard let URL = URL(string: updatedURL) else {
            print("Invalid basic soaring forecast URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }

        // Process URL query
        URLSession.shared.dataTask(with: URL) { [weak self] data, response, error in
            guard let self = self else { return }
            guard let data = data, error == nil else {
                DispatchQueue.main.async { self.isLoading = false }
                return
            }
            if let content = String(data: data, encoding: .utf8) {
                self.parseBasicSoaringForecast(content: content)
            }
        }.resume()
    }
    
    
    func parseModelData(_ input: String) -> [ModelData] {
        let lines = input.split(separator: "\n")
        var dataRows: [ModelData] = []
        for line in lines {
            dataRows.append(ModelData(value: String(line)))
        }
        return dataRows
    }
    
    // Winter soaring forecast with limited data
    func parseBasicSoaringForecast(content: String) {
        let start = "SOARING FORECAST FOR "
        let datePrefix = "DATE..."
        let liftPrefix = "HEIGHT      |   TI   | TOC  |  POTENTIAL LIFT"
        let soaringPrefix = "HEIGHT OF THE "
        let soaringSuffix = "UPPER LEVEL WINDS"
        let soundingPrefix = "Morning  ####  Afternoon"
        let endPrefix = "IT IS EMPHASIZED"
        
        guard let startRange = content.range(of: start)
        else {
            print("Basic soaring forecast: could not parse start date (e.g., no row for \(start))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let dateRange = content.range(of: datePrefix, range: startRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: could not parse date range (e.g., no row for \(datePrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let liftRange = content.range(of: liftPrefix, range: dateRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: could not parse lift range (e.g., no row for \(liftPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soaringRange = content.range(of: soaringPrefix, range: liftRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: could not parse soaring forecast range (e.g., no row for \(soaringPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soaringRangeEnd = content.range(of: soaringSuffix, range: soaringRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: could not parse soaring forecast range (e.g., no row for \(soaringPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soundingRange = content.range(of: soundingPrefix, range: soaringRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: could not parse sounding data range (e.g., no row for \(soundingPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let endRange = content.range(of: endPrefix, range: soundingRange.upperBound..<content.endIndex)
        else {
            print("Basic soaring forecast: Could not parse end range (e.g., no row for \(endPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        
        let date = String(content[dateRange.upperBound...].prefix(9)).trimmingCharacters(in: .whitespacesAndNewlines)
        
        let liftDataString = removeExtraBlankLines(String(content[liftRange.upperBound..<soaringRange.lowerBound]))
        let liftData = parseBasicLiftData(liftDataString)
        
        let soaringDataString = removeExtraBlankLines(String(content[soaringRange.upperBound..<soaringRangeEnd.lowerBound]))
        let soaringForecast = parseBasicSoaringForecastData(soaringDataString)
        
        let soundingDataString = removeExtraBlankLines(String(content[soundingRange.upperBound..<endRange.lowerBound]))
        let soundingData = parseBasicSoundingData(soundingDataString)
        
        // Find forecast max temp to use in skew-T diagarm
        var forecastMaxTemp: Int = 0
        let pattern = "MAX TEMPERATURE FORECAST\\s+\\.+\\d+\\DEGREES F)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let nsString = soaringDataString as NSString
        let results = regex?.matches(in: soaringDataString, options: [], range: NSRange(location: 0, length: nsString.length))
        if let match = results?.first, let range = Range(match.range(at: 1), in: soaringDataString) {
            forecastMaxTemp = Int(soaringDataString[range]) ?? 0
        }
        
        DispatchQueue.main.async {
            self.isLoading = false
            self.soaringForecastBasic = SoaringForecastBasic(date:                      date,
                                                             soaringForecastFormat:     "Basic",
                                                             basicSoaringForecastData:  soaringForecast,
                                                             basicLiftData:             liftData.reversed(),
                                                             basicSoundingData:         soundingData.reversed(),
                                                             forecastMaxTemp:           forecastMaxTemp)
        }
    }
    
    func parseBasicLiftData(_ input: String) -> [BasicLiftData] {
        let formattedInput = input
            .replacingOccurrences(of: "FT ASL", with: "")
            .replacingOccurrences(of: " ", with: "")
            .trimmingCharacters(in: .whitespacesAndNewlines)
        let lines = formattedInput.split(separator: "\n")
        var basicLiftData: [BasicLiftData] = []
        for line in lines { // Header rows parsed out above; otherwise use .dropFirst()
            let columns = line.split(separator: "|", omittingEmptySubsequences: true)
            if columns.count >= 4 {
                let altitude = String(columns[0])
                let thermalIndex = Double(extractNumber(from: String(columns[1])) ?? 0.0)
                let tempOfConvection = Int(extractNumber(from: String(columns[2])) ?? 0)
                let liftRate = Int(extractNumber(from: String(columns[3])) ?? 0)
                let liftRateMSec = convertFtMinToMSec(Double(liftRate))
                let dataRow = BasicLiftData(
                    altitude:           altitude,
                    thermalIndex:       thermalIndex,
                    tempOfConvection:   tempOfConvection,
                    liftRate:           liftRateMSec
                )
                basicLiftData.append(dataRow)
                    
            }
        }
        return basicLiftData
    }
    
    func parseBasicSoaringForecastData(_ input: String) -> [BasicSoaringForecastData] {
        var formattedInput = input
            .replacingOccurrences(of: "TEMPERATURE", with: "TEMP")
            .replacingOccurrences(of: "ASL", with: "")
            .replacingOccurrences(of: "DEGREES ", with: "°")
            .replacingOccurrences(of: "GREAT BASIN SOARING INDEX", with: "")
            .replacingOccurrences(of: "(", with: "")
            .replacingOccurrences(of: ")", with: "")
        
        // Convert max lift to m/s
        let pattern = #"(\d+)\sFT/MIN"#
        let regex = try! NSRegularExpression(pattern: pattern)
        let input = formattedInput

        if let match = regex.firstMatch(in: input, range: NSRange(input.startIndex..., in: input)),
           let numberRange = Range(match.range(at: 1), in: input),
           let fullRange = Range(match.range, in: input) {

            let numberStr = String(input[numberRange])
            if let ftMin = Double(numberStr) {
                let mSec = convertFtMinToMSec(ftMin)
                formattedInput = input.replacingCharacters(in: fullRange, with: String(format: "%.2f m/s", mSec))
            }
        }
        
        formattedInput = formatNumbersInString(formattedInput)
            .capitalized
            .replacingOccurrences(of: "M/S", with: "m/s")
            .replacingOccurrences(of: "Ft", with: "ft")
        let lines = formattedInput.split(separator: "\n")
        var dataRows: [BasicSoaringForecastData] = []
        for line in lines {
            let components = line.split(separator: ".", omittingEmptySubsequences: true)
            if components.count > 1 {
                let heading = components[0].trimmingCharacters(in: .whitespacesAndNewlines)
                let value = components.dropFirst().joined(separator: ".").trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(BasicSoaringForecastData(heading: heading, value: value))
            } else {
                let heading = line.trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(BasicSoaringForecastData(heading: heading, value: nil))
            }
        }
        return dataRows
    }

    func parseBasicSoundingData(_ input: String) -> [BasicSoundingData] {
        let lines = input.split(separator: "\n")
        var basicSoundingData: [BasicSoundingData] = []
        for line in lines { // Header rows parsed out above; otherwise use .dropFirst(3)
            let columns = line.split(separator: " ", omittingEmptySubsequences: true)
            if columns.count >= 5, let altitude = Int(columns[0]), altitude <= 18000 {
                let amWindDirection = Int(columns[1]) ?? 0
                let amWindSpeedKt = Int(columns[2]) ?? 0
                // Ignore column 3; it contains #### as a separator
                let pmWindDirection = Int(columns[4]) ?? 0
                let pmWindSpeedKt = Int(columns[5]) ?? 0
                
                let amWindSpeed = convertKnotsToMPH(amWindSpeedKt)
                let pmWindSpeed = convertKnotsToMPH(pmWindSpeedKt)

                let dataRow = BasicSoundingData(altitude:           String(altitude),
                                                amWindDirection:    amWindDirection,
                                                amWindSpeed:        amWindSpeed,
                                                pmWindDirection:    pmWindDirection,
                                                pmWindSpeed:        pmWindSpeed)
                basicSoundingData.append(dataRow)
            }
        }
        return basicSoundingData
    }

}
import SwiftUI
import Foundation
import SafariServices
import UIKit
import MapKit

// Common utility functions
func tempColor(_ tempF: Int?) -> Color {
    guard let tempF = tempF else {
        return .clear
    }

    switch tempF {
        case ...32:     return displayValueBlue
        case 33...59:   return displayValueTeal
        case 60...79:   return displayValueGreen
        case 80...89:   return displayValueYellow
        case 90...99:   return displayValueOrange
        case 100...:    return displayValueRed
        default:        return .clear
    }
}

func cloudCoverColor(_ cloudCoverPct: Int?) -> Color {
    guard let cloudCoverPct = cloudCoverPct else {
        return .clear
    }

    switch cloudCoverPct {
        case ...39:     return displayValueGreen
        case 40...59:   return displayValueYellow
        case 60...79:   return displayValueOrange
        case 80...:     return displayValueRed
        default:        return .clear
    }
}

func precipColor(_ precipPct: Int?) -> Color {
    guard let precipPct = precipPct else {
        return .clear
    }

    switch precipPct {
        case ...19:     return displayValueGreen
        case 20...39:   return displayValueYellow
        case 40...59:   return displayValueOrange
        case 60...:     return displayValueRed
        default:        return .clear
    }
}

func CAPEColor(_ CAPEvalue: Int?) -> Color {
    guard let CAPEvalue = CAPEvalue else {
        return .clear
    }

    switch CAPEvalue {
        case 0...299:   return displayValueGreen
        case 300...599: return displayValueYellow
        case 600...799: return displayValueOrange
        case 800...:    return displayValueRed
        default:        return .clear
    }
}

func windSpeedColor(windSpeed: Int?, siteType: String) -> Color {
    guard let windSpeed = windSpeed else {
        return .clear
    }

    switch siteType {
    case "Aloft", "Mountain":
        switch windSpeed {
            case 0...11:    return displayValueGreen
            case 12...17:   return displayValueYellow
            case 18...23:   return displayValueOrange
            case 24...:     return displayValueRed
            default:        return .clear
        }
    case "Soaring":
        switch windSpeed {
            case 0...8:     return displayValueLime
            case 9...19:    return displayValueGreen
            case 20...24:   return displayValueYellow
            case 25...29:   return displayValueOrange
            case 30...:     return displayValueRed
            default:        return .clear
        }
    default:
        switch windSpeed {
            case 0...11:    return displayValueGreen
            case 12...17:   return displayValueYellow
            case 18...23:   return displayValueOrange
            case 24...:     return displayValueRed
            default:        return .clear
        }
    }
}

func thermalColor(_ thermalVelocity: Double?) -> Color {
    guard let thermalVelocity = thermalVelocity else {
        return .clear
    }
    
    // Assumes thermalVelocity already rounded to nearest tenth
    switch thermalVelocity {
        case ...0.9:    return displayValueWhite
        case 1.0...1.9: return displayValueLime
        case 2.0...3.9: return displayValueGreen
        case 4.0...4.9: return displayValueYellow
        case 5.0...5.9: return displayValueOrange
        case 6.0...:    return displayValueRed
        default:        return .clear
    }
}

func gustFactorColor(_ gustFactor: Int?) -> Color {
    guard let gustFactor = gustFactor else {
        return .clear
    }
    switch gustFactor {
        case 0...5:     return displayValueGreen
        case 6...7:     return displayValueYellow
        case 8...9:     return displayValueOrange
        case 10...:     return displayValueRed
        default:        return .clear
    }
}

func windDirectionColor(siteWindDirection: SiteWindDirection,
                        siteType: String,
                        windDirection: Int?,
                        windSpeed: Int?,
                        windGust: Int?) -> Color {
    guard let windDirection = windDirection else {
        return .clear
    }
    
    // Check the wind direction
    var windDirectionQuality: String
    switch headingForWindDirection(windDirection: windDirection) {
        case "N":   windDirectionQuality = siteWindDirection.N
        case "NE":  windDirectionQuality = siteWindDirection.NE
        case "E":   windDirectionQuality = siteWindDirection.E
        case "SE":  windDirectionQuality = siteWindDirection.SE
        case "S":   windDirectionQuality = siteWindDirection.S
        case "SW":  windDirectionQuality = siteWindDirection.SW
        case "W":   windDirectionQuality = siteWindDirection.W
        case "NW":  windDirectionQuality = siteWindDirection.NW
        default:    windDirectionQuality = ""
    }
    
    // If the wind direction is not "Good", check the wind and gust speed
    // If light and variable (5 mph or less) for a mountain (non-soaring) site, then consider "Ok" rather than "Marginal" or "Bad"
    if windDirectionQuality != "Good" && windSpeed ?? 0 <= 5 && windGust ?? 0 <= 5 && siteType == "Mountain" {
        windDirectionQuality = "Ok"
    }
    
    switch windDirectionQuality {
        case "Good":        return displayValueGreen
        // "Ok" used for light and variable but not an ideal direction
        case "Ok":          return displayValueLime
        case "Marginal":    return displayValueYellow
        default:            return displayValueRed
    }
}

// Color values for potential forecast ratings
enum FlyingPotentialColor: Int {
    case white  = 0
    case lime   = 1
    case green  = 2
    case yellow = 3
    case orange = 4
    case red    = 5
    var color: Color {
        switch self {
        case .white : return displayValueWhite
        case .lime  : return displayValueLime
        case .green : return displayValueGreen
        case .yellow: return displayValueYellow
        case .orange: return displayValueOrange
        case .red   : return displayValueRed
        }
    }
    static func color(for value: Int) -> Color {
        return FlyingPotentialColor(rawValue: value)?.color ?? .clear
    }
    
    // Converts a color to a value
    static func value(for color: Color) -> Int {
        for value in FlyingPotentialColor.allCases {
            if value.color.description == color.description {
                return value.rawValue
            }
        }
        return -1
    }
}
extension FlyingPotentialColor: CaseIterable {}

func FlyingPotentialImageSize (_ color: Color) -> CGFloat {
    switch color {
        case displayValueWhite:     return 12
        case displayValueLime:      return 16
        case displayValueGreen:     return 20
        case displayValueYellow:    return 16
        case displayValueOrange:    return 12
        case displayValueRed:       return 8
        default:                    return 20
    }

}

func getDividerColor (_ newDateFlag: Bool) -> Color {
    if newDateFlag {
        return tableMajorDividerColor
    } else {
        return tableMinorDividerColor
    }
}

func roundToOneDecimal(_ value: Double) -> Double {
    return (value * 10).rounded() / 10
}

func convertKnotsToMPH(_ knots: Int) -> Int {
    let mph = Int((Double(knots) * 1.15078).rounded())
    return mph
}

func convertCelsiusToFahrenheit(_ celsius: Int) -> Int {
    return Int(((Double(celsius) * 9/5) + 32).rounded())
}

func convertMetersToFeet(_ meters: Double) -> Int {
    return Int((meters * 3.28084).rounded())
}

func convertFeetToMeters(_ feet: Double) -> Double {
    return (feet / 3.28084).rounded()
}

func convertKMToMiles(_ km: Double) -> Double {
    return (km * 0.621371).rounded()
}

func convertFtMinToMSec(_ ftMin: Double) -> Double {
    let mSec = ftMin * 0.00508
    let mSecRounded = (mSec * 10).rounded() / 10
    return (mSecRounded)
}


func formatAltitude(_ altitudeData: String) -> String {
    let numberFormatter = NumberFormatter()
    numberFormatter.numberStyle = .decimal
    numberFormatter.maximumFractionDigits = 0
    numberFormatter.minimumFractionDigits = 0
    let altitude = altitudeData.replacingOccurrences(of: ",", with: "")
    let altitudeInt = Int(Double(altitude) ?? 0.0)
    if let formattedAltitude = numberFormatter.string(from: NSNumber(value: altitudeInt)) {
        return "\(formattedAltitude) ft"
    } else {
         return altitudeData
    }
}

func buildReferenceNote(Alt: String, Note: String) -> String {
    var NoteString: String = ""
    if Alt != "" {
        let formattedAlt = formatAltitude(Alt)
        NoteString = "At \(formattedAlt)"
    }
    if Note != "" {
        NoteString = NoteString + " (\(Note))"
    }
    return NoteString
}

func extractSection(from data: Substring, start: String, end: String) -> String? {
    guard let startRange = data.range(of: start)?.upperBound,
          let endRange = data.range(of: end, range: startRange..<data.endIndex)?.lowerBound else { return nil }
    return String(data[startRange..<endRange])
}

func updateURL(url: String, parameter: String, value: String) -> String {
    let placeholder = "{\(parameter)}"
    return url.replacingOccurrences(of: placeholder, with: value)
}

func collapseTextLines(_ text: String?) -> String {
    // Set default if input is nil
    let nonOptionalText = text ?? ""
    var cleanedText = removeExtraBlankLines(nonOptionalText)
    // Replace single line returns with a space, keep double line returns
    cleanedText = cleanedText.replacingOccurrences(of: "(?<!\n)\n(?!\n)", with: " ", options: .regularExpression)
    return cleanedText.trimmingCharacters(in: .whitespacesAndNewlines)
}

func removeExtraBlankLines(_ text: String?) -> String {
    // Set default if input is nil
    let nonOptionalText = text ?? ""
    // Remove leading spaces, tabs, and dots at the beginning of text lines
    var cleanedText = nonOptionalText.replacingOccurrences(of: "(?m)^[ \t.]+", with: "", options: .regularExpression)
    // Remove leading line returns on the first line
    cleanedText = cleanedText.replacingOccurrences(of: "^\n+", with: "", options: .regularExpression)
    // Remove trailing line returns on the last line
    cleanedText = cleanedText.replacingOccurrences(of: "\n+$", with: "", options: .regularExpression)
    return cleanedText.trimmingCharacters(in: .whitespacesAndNewlines)
}

func formatNumbersInString(_ input: String) -> String {
    let numberPattern = "\\d+"
    let timePattern = "\\b\\d{1,2}:\\d{2}\\b" // matches HH:MM or H:MM
    
    let numberRegex = try! NSRegularExpression(pattern: numberPattern)
    let timeRegex = try! NSRegularExpression(pattern: timePattern)
    
    let fullRange = NSRange(location: 0, length: input.utf16.count)
    let timeMatches = timeRegex.matches(in: input, options: [], range: fullRange)
    
    // Collect ranges of times to skip
    let timeRanges = timeMatches.map { $0.range }
    
    var formattedString = input as NSString
    let numberMatches = numberRegex.matches(in: input, options: [], range: fullRange)
    
    for match in numberMatches.reversed() {
        // Check if this number is inside a time match (skip if so)
        if timeRanges.contains(where: { NSIntersectionRange($0, match.range).length > 0 }) {
            continue
        }
        let numberString = formattedString.substring(with: match.range)
        if let number = Int(numberString) {
            let numberFormatter = NumberFormatter()
            numberFormatter.numberStyle = .decimal
            if let formattedNumberString = numberFormatter.string(from: NSNumber(value: number)) {
                formattedString = formattedString.replacingCharacters(in: match.range, with: formattedNumberString) as NSString
            }
        }
    }
    
    return formattedString as String
}

func removeTextInParentheses(_ text: String?) -> String {
    // Set default if input is nil
    let nonOptionalText = text ?? ""
    let pattern = "\\([^()]*\\)"
    return nonOptionalText.replacingOccurrences(of: pattern, with: "", options: .regularExpression)
        .trimmingCharacters(in: .whitespacesAndNewlines)
}

// Function to look for two strings, and when found, remove everything in the data string from openingString through closingString
// For example, passing " [" and "]" will change "data [including bracketed data] here" to "data here"
func removeTextFromOpenToClose(_ data: String, open: String, close: String) -> String {
    let pattern = "\(NSRegularExpression.escapedPattern(for: open)).*?\(NSRegularExpression.escapedPattern(for: close))"
    let regex = try! NSRegularExpression(pattern: pattern, options: [])
    let range = NSRange(location: 0, length: data.utf16.count)
    let updatedData = regex.stringByReplacingMatches(in: data, options: [], range: range, withTemplate: "")
    return updatedData
}

func formatTimeinString(from string: String) -> String {
    let pattern = "\\b(\\d{1,4})\\s?(MDT|MST)\\b"
    let regex = try! NSRegularExpression(pattern: pattern)
    let nsString = string as NSString
    let matches = regex.matches(in: string, range: NSRange(location: 0, length: nsString.length))
    
    var resultString = string
    
    for match in matches.reversed() {
        let numberRange = match.range(at: 1)
        let timezoneRange = match.range(at: 2)
        
        let timeSubstring = nsString.substring(with: numberRange)
        let timezone = nsString.substring(with: timezoneRange)
        
        if let number = Int(timeSubstring) {
            let hours = number / 100
            let minutes = number % 100
            
            // This line ensures both hours and minutes are 2-digit padded
            let formattedTime = String(format: "%02d:%02d", hours, minutes)
            let replacement = "\(formattedTime) \(timezone)"
            
            let fullMatchRange = match.range(at: 0)
            resultString = (resultString as NSString).replacingCharacters(in: fullMatchRange, with: replacement)
        }
    }
    
    return resultString
}

// Convert all numbers with decimal components to integers
func roundNumbersInString (in data: String) -> String {
    // Regular expression to find numbers with decimal digits
    let pattern = "\\d+\\.\\d+"
    let regex = try! NSRegularExpression(pattern: pattern, options: [])
    let range = NSRange(location: 0, length: data.utf16.count)
    // Use the matches to find and replace each decimal number
    let matches = regex.matches(in: data, options: [], range: range)
    var newString = data
    for match in matches.reversed() {
        if let matchRange = Range(match.range, in: data) {
            let numberString = String(data[matchRange])
            if let number = Double(numberString) {
                let roundedNumber = Int(round(number))
                newString.replaceSubrange(matchRange, with: "\(roundedNumber)")
            }
        }
    }
    return newString
}

// Extracts the first number (integer or decimal) from a string
func extractNumber(from input: String) -> Double? {
    let pattern = #"(\d+(\.\d+)?)"#
    guard let regex = try? NSRegularExpression(pattern: pattern) else { return nil }
    let range = NSRange(input.startIndex..., in: input)
    if let match = regex.firstMatch(in: input, range: range),
       let numberRange = Range(match.range(at: 1), in: input) {
        return Double(input[numberRange])
    }
    return nil
}

// Created for site forecast results that occassionally contain null for a weather code
func replaceNullsInJSON(data: Data) -> Data? {
    // Convert Data to String
    guard let dataString = String(data: data, encoding: .utf8) else {
        print("Failed to convert Data to String.")
        return nil
    }
    // Replace all occurrences of "null" with "0"
    let modifiedString = dataString.replacingOccurrences(of: "null", with: "0")
    // Convert String back to Data
    guard let modifiedData = modifiedString.data(using: .utf8) else {
        print("Failed to convert modified String back to Data.")
        return nil
    }
    return modifiedData
}

// Function to open links using Safari in app window
struct SafariView: UIViewControllerRepresentable {
    let url: URL
    func makeUIViewController(context: Context) -> SFSafariViewController {
        return SFSafariViewController(url: url)
    }
    func updateUIViewController(_ uiViewController: SFSafariViewController, context: Context) {
        // No updates needed
    }
}

// Convert ISO dates to local time zone and extract hh:mm portion
func convertISODateToLocalTime(isoDateString: String) -> String {
    let isoDateFormatter = ISO8601DateFormatter()
    isoDateFormatter.formatOptions = [.withInternetDateTime, .withColonSeparatorInTimeZone]

    guard let date = isoDateFormatter.date(from: isoDateString) else {
        print("Invalid ISO date string:" + isoDateString)
        return ""
    }

    let localDateFormatter = DateFormatter()
    localDateFormatter.dateFormat = "h:mm"
    localDateFormatter.timeZone = TimeZone.current

    let localTimeString = localDateFormatter.string(from: date)
    return localTimeString
}

func getFormattedTimefromDate(_ date: Date) -> String {
    let formatter = DateFormatter()
    formatter.dateFormat = "h:mm"
    return formatter.string(from: date)
}
func getDateForDays(days: Double) -> Date {
    // Get date string based on "days" value:
    // Days = 1, today
    // Days = 2, today and yesterday
    // Days = 3, today, yesterday, and prior day
    let dateFormatter = ISO8601DateFormatter()
    dateFormatter.formatOptions = [.withInternetDateTime]
    var calendar = Calendar.current
    calendar.timeZone = TimeZone.current
    // Set the base date to today at 12:01 AM, then subtract (days - 1)
    let baseDate = calendar.date(bySettingHour: 0, minute: 1, second: 0, of: Date()) ?? Date()
    let targetDate = calendar.date(byAdding: .day, value: -(Int(days) - 1), to: baseDate)!
    return targetDate
}

// Function to determine distinct values from an array
extension Array where Element: Hashable {
    func unique() -> [Element] {
        var seen: Set<Element> = []
        return filter { seen.insert($0).inserted }
    }
}

// Scale UI Image for map display
extension UIImage {
    func scaled(toWidth newWidth: CGFloat) -> UIImage? {
        let aspectRatio = size.height / size.width
        let newHeight = newWidth * aspectRatio
        let newSize = CGSize(width: newWidth, height: newHeight)
        UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0)
        draw(in: CGRect(origin: .zero, size: newSize))
        let scaledImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return scaledImage
    }
}

// Set color for UI Images
func tintedImage(_ image: UIImage, color: UIColor) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(image.size, false, image.scale)
    color.set()
    image.draw(in: CGRect(origin: .zero, size: image.size))
    let tinted = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return tinted ?? image
}

// Calculate bearing based on two points (used for pilot tracks)
func bearing(from: CLLocationCoordinate2D, to: CLLocationCoordinate2D) -> CLLocationDirection {
    let deltaLon = to.longitude - from.longitude
    let y = sin(deltaLon * .pi/180) * cos(to.latitude * .pi/180)
    let x = cos(from.latitude * .pi/180) * sin(to.latitude * .pi/180) -
            sin(from.latitude * .pi/180) * cos(to.latitude * .pi/180) * cos(deltaLon * .pi/180)
    return atan2(y, x) * 180 / .pi
}

// Determine 6, 12, or 24 hour cycle for winds aloft readings based on the current time
func windsAloftCycle() -> String {
    let hour = Calendar.current.component(.hour, from: Date())
    switch hour {
    case 3...13:
        return "12"
    case 14...18:
        return "6"
    default:
        return "24"
    }
}

// Used to convert color name (string) to color.
// Colors need to be stored as strings in the site forecast HourlyData structure for it to remain Codable.
extension Color {
    static func from(name: String) -> Color {
        switch name.lowercased() {
        case "white"    : return .white
        case "blue"     : return .displayValueBlue
        case "teal"     : return .displayValueTeal
        case "lime"     : return .displayValueLime
        case "green"    : return .displayValueGreen
        case "yellow"   : return .displayValueYellow
        case "orange"   : return .displayValueOrange
        case "red"      : return .displayValueRed
        case "clear"    : return .clear
        default         : return .gray // fallback
        }
    }
}

func headingForWindDirection(windDirection: Int?) -> String {
    guard let windDirection = windDirection else {
        return ""
    }
    
    switch windDirection {
    case 0...22, 338...359  : return "N"
    case 23...67            : return "NE"
    case 68...112           : return "E"
    case 113...157          : return "SE"
    case 158...202          : return "S"
    case 203...247          : return "SW"
    case 248...292          : return "W"
    case 293...337          : return "NW"
    default                 : return ""
    }
}

func degreeRangeForHeading(_ heading: String) -> (start: Int, end: Int)? {
    switch heading.uppercased() {
    case "N"                : return (338, 22) // Wraps around 0°
    case "NE"               : return (23, 67)
    case "E"                : return (68, 112)
    case "SE"               : return (113, 157)
    case "S"                : return (158, 202)
    case "SW"               : return (203, 247)
    case "W"                : return (248, 292)
    case "NW"               : return (293, 337)
    default                 : return nil        // Invalid input
    }
}

func windDirectionRanges(from siteWindDirection: SiteWindDirection)
    -> (goodRanges: [(Double, Double)], marginalRanges: [(Double, Double)])
{
    var goodRanges: [(Double, Double)] = []
    var marginalRanges: [(Double, Double)] = []
    let directionMap: [(keyPath: KeyPath<SiteWindDirection, String>, label: String)] = [
        (\.N,  "N"),
        (\.NE, "NE"),
        (\.E,  "E"),
        (\.SE, "SE"),
        (\.S,  "S"),
        (\.SW, "SW"),
        (\.W,  "W"),
        (\.NW, "NW")
    ]
    for (keyPath, label) in directionMap {
        let value = siteWindDirection[keyPath: keyPath].trimmingCharacters(in: .whitespacesAndNewlines)
        guard let (start, end) = degreeRangeForHeading(label) else { continue }
        let range = (Double(start), Double(end))
        if value.caseInsensitiveCompare("Good") == .orderedSame {
            goodRanges.append(range)
        } else if value.caseInsensitiveCompare("Marginal") == .orderedSame {
            marginalRanges.append(range)
        }
    }
    return (goodRanges, marginalRanges)
}
import SwiftUI
import Foundation

// Forecast logging to optimize thermal calculations
struct LogData: Codable {
    // Core data based on site and forecast API call results
    var site: String
    var date: String
    var time: String
    var surfaceAltitude: Double
    var surfaceTemp: Double
    // Forecast API call results for a specific pressure altitude
    var altitude: Double
    var ambientTemp: Double
    var ambientDPTemp: Double
    // Data calculated within forecast functions
    var liftRate: Double
    var thermalTriggerReachedForDay: Bool
    var topOfLiftAltitude: Double
    var cloudbaseAltitude: Double
    var adjustedPriorAltitude: Double
    var altitudeChange: Double
    var topOfLiftRatio: Double
    var cloudbaseRatio: Double
    var priorAmbientDPTemp: Double
    var thermalDPTemp: Double
    var priorThermalDPTemp: Double
    var thermalDPTempToAmbientDPTempDiff: Double
    var ambientTempToAmbientDPTempDiff: Double
    var ambientDPTempDiff: Double
    var priorThermalDPTempToAmbientDPTempDiff: Double
    var priorAmbientDPTempToAmbientTempDiff: Double
    var thermalRampTop: Double
    var rampImpactAltitude: Double
    var rampImpactPortion: Double
    var rampReductionFactor: Double
    // Thermal parameters captured when app is started
    var thermalLapseRate: Double
    var thermalVelocityConstant: Double
    var initialTriggerTempDiff: Double
    var ongoingTriggerTempDiff: Double
    var thermalRampDistance: Double
    var thermalRampStartPct: Double
    var cloudbaseLapseRatesDiff: Double
    var thermalGliderSinkRate: Double
}

// For development logging
// Format to call logging:
//                          logToFile("Text to output")
func deleteLogFile() {
    let fileURL = getLogFileURL()
    
    if FileManager.default.fileExists(atPath: fileURL.path) {
        do {
            try FileManager.default.removeItem(at: fileURL)
            print("Log file deleted successfully.")
        } catch {
            print("Failed to delete log file: \(error)")
        }
    }
}

func logToFile(_ message: String) {
    let fileURL = getLogFileURL()
    
    do {
        let timestamp = Date().description(with: .current)
        let logMessage = "[\(timestamp)] \(message)\n"
        if FileManager.default.fileExists(atPath: fileURL.path) {
            let fileHandle = try FileHandle(forWritingTo: fileURL)
            fileHandle.seekToEndOfFile()
            if let data = logMessage.data(using: .utf8) {
                fileHandle.write(data)
            }
            fileHandle.closeFile()
        } else {
            try logMessage.write(to: fileURL, atomically: true, encoding: .utf8)
        }
    } catch {
        print("Failed to write to log file: \(error)")
    }
}

func getLogFileURL() -> URL {
    let fileManager = FileManager.default
    let urls = fileManager.urls(for: .documentDirectory, in: .userDomainMask)
    let documentDirectory = urls[0]
    return documentDirectory.appendingPathComponent("app.log")
}

// Call this function when the app launches
func initializeLoggingFile() {
    
    deleteLogFile()

    // If logging is turned on, write header row for thermal calc troubleshooting
    if logThermalCalcs {
        logToFile(  "site, " +
                    "date, " +
                    "time," +
                    "surface Altitude," +
                    "surface Temp," +
                    "altitude," +
                    "ambient Temp," +
                    "ambient DP Temp," +
                    "lift Rate," +
                    "thermal Trigger Reached For Day, " +
                    "top Of Lift Altitude," +
                    "cloudbase Altitude," +
                    "adjusted Prior Altitude," +
                    "altitude Change," +
                    "top Of Lift Ratio," +
                    "cloudbase Ratio," +
                    "prior Ambient DP Temp," +
                    "thermal DP Temp," +
                    "prior Thermal DP Temp," +
                    "thermal DP Temp To Ambient DP Temp Diff," +
                    "ambient Temp To Ambient DP Temp Diff," +
                    "ambient DP Temp Diff," +
                    "prior Thermal DP Temp To Ambient DP Temp Diff," +
                    "prior Ambient DP Temp To Ambient Temp Diff," +
                    "thermal Ramp Top," +
                    "ramp Impact Altitude," +
                    "ramp Impact Portion," +
                    "ramp Reduction Factor," +
                    "thermal Lapse Rate," +
                    "thermal Velocity Constant," +
                    "initial Trigger Temp Diff," +
                    "ongoing Trigger Temp Diff," +
                    "thermal Ramp Distance," +
                    "thermal Ramp Start Pct," +
                    "cloudbase Lapse Rates Diff," +
                    "thermal Glider Sink Rate"
                    )
    }
}
import Foundation

// appRegion functions are available globally (without injecting view model each time)
// To call these functions, use this format:
//      AppRegionCodesManager.shared.getRegionCountry()

final class AppRegionCodesManager {
    static let shared = AppRegionCodesManager()
    
    private init() {}
    
    private(set) var appRegionCodes: [AppRegionCode] = []
    
    func setAppRegionCodes(_ regionCodes: [AppRegionCode]) {
        self.appRegionCodes = regionCodes
    }
    
    func getWeatherAlertCodes() -> [(name: String, code: String)] {
        return appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.weatherAlerts.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.weatherAlerts == "Yes" ? code.airportCode : code.weatherAlerts
                return (name: code.name, code: resultCode)
            }
    }

    
    func getAFDCodes() -> [(name: String, code: String)] {
        return appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.AFD.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.AFD == "Yes" ? code.airportCode : code.AFD
                return (name: code.name, code: resultCode)
            }
    }

    func getSoaringForecastCodes() -> [(name: String, forecastType: String, code: String)] {
        let richCodes = appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.soaringForecastRichSimple.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.soaringForecastRichSimple == "Yes" ? code.airportCode : code.soaringForecastRichSimple
                return (name: code.name, forecastType: "rich", code: resultCode)
            }
        let basicCodes = appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.soaringForecastBasic.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.soaringForecastBasic == "Yes" ? code.airportCode : code.soaringForecastBasic
                return (name: code.name, forecastType: "basic", code: resultCode)
            }
        return richCodes + basicCodes
    }
    
    func getWindsAloftCodes() -> [(name: String, code: String)] {
        return appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.windsAloft.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.windsAloft == "Yes" ? code.airportCode : code.windsAloft
                return (name: code.name, code: resultCode)
            }
    }

    func getSoundingModelCodes() -> [(name: String, code: String)] {
        return appRegionCodes
            .filter { code in
                code.appRegion == RegionManager.shared.activeAppRegion && !code.soundingModel.trimmingCharacters(in: .whitespaces).isEmpty
            }
            .map { code in
                let resultCode = code.soundingModel == "Yes" ? code.stationCode : code.soundingModel
                return (name: code.name, code: resultCode)
            }
    }


}
import SwiftUI
import Combine
import MapKit

struct UDOTCameraData: Codable, Identifiable {
    let id: Int
    let source: String
    let sourceId: String
    let roadway: String
    let direction: String
    let latitude: Double
    let longitude: Double
    let location: String
    let sortOrder: Int
    let views: [UDOTCameraViewData]
     
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case source = "Source"
        case sourceId = "SourceId"
        case roadway = "Roadway"
        case direction = "Direction"
        case latitude = "Latitude"
        case longitude = "Longitude"
        case location = "Location"
        case sortOrder = "SortOrder"
        case views = "Views"
    }
}

struct UDOTCameraViewData: Codable {
    let viewId: Int
    let viewURL: String
    let status: String
    let description: String

    enum CodingKeys: String, CodingKey {
        case viewId = "Id"
        case viewURL = "Url"
        case status = "Status"
        case description = "Description"
    }
}

class UDOTCamerasViewModel: ObservableObject {
    @Published var cameras: [UDOTCameraData] = []
    @Published var clusteredCameras: [UDOTCameraData] = []

    func fetchCameras() {
        guard let url = URL(string: uDOTCamerasAPI) else {
            print("Invalid URL")
            return
        }

        URLSession.shared.dataTask(with: url) { [weak self] data, _, error in
            guard let data = data, error == nil else {
                print("Error fetching data: \(error?.localizedDescription ?? "Unknown error")")
                return
            }

            do {
                let decodedData = try JSONDecoder().decode([UDOTCameraData].self, from: data)
                DispatchQueue.main.async {
                    self?.cameras = decodedData
                    self?.updateClusters(mapRegionSpan: MKCoordinateSpan(latitudeDelta: mapDefaultLatitudeSpan, longitudeDelta: mapDefaultLongitudeSpan))
                }
            } catch {
                print("Error decoding JSON: \(error)")
            }
        }.resume()
    }

    func updateClusters(mapRegionSpan: MKCoordinateSpan) {
        let thresholdDistance = max(mapRegionSpan.latitudeDelta, mapRegionSpan.longitudeDelta) * mapClusterThresholdFactor
        clusteredCameras = []

        for camera in cameras {
            if clusteredCameras.allSatisfy({ existingCamera in
                let distance = sqrt(pow(camera.latitude - existingCamera.latitude, 2) + pow(camera.longitude - existingCamera.longitude, 2))
                return distance > thresholdDistance
            }) {
                clusteredCameras.append(camera)
            }
        }
    }
}
import Foundation

// activeAppRegion is a globally available variable for the user selected appRegion
//
// Usage:   RegionManager.shared.activeAppRegion
// (except in BaseAppView, which is set to observe the RegionManager, so doesn't need .shared.

import Combine
import Foundation

class RegionManager: ObservableObject {
    static let shared = RegionManager()
    private init() {
        // Initialize from UserDefaults if available
        self.activeAppRegion = UserDefaults.standard.string(forKey: key) ?? ""
    }

    private let key = "activeAppRegion"

    @Published var activeAppRegion: String {
        didSet {
            UserDefaults.standard.set(activeAppRegion, forKey: key)
        }
    }
}
import SwiftUI
import Combine

// Get sunrise/sunset times for common use
// Sunrise and sunset URL fetch response structure
struct SunriseSunsetResponse: Codable {
    let results: Results
    let status: String
}
// Sunrise and sunset JSON decode for Results portion of URL response
struct Results: Codable {
    let sunrise: String
    let sunset: String
}
// Published view model structure
struct SunriseSunset: Codable {
    var sunrise: String
    var sunset: String
}
class SunriseSunsetViewModel: ObservableObject {
    @Published var sunriseSunset: SunriseSunset?
    
    // Get sunrise / sunset for region
    func getSunriseSunset(completion: @escaping () -> Void) {
        var sunriseSunset: SunriseSunset = .init(sunrise: "", sunset: "")
        
        // Get coordinates for region
        guard let coords = AppRegionManager.shared.getRegionSunriseCoordinates() else {
            print("Region not found fetching sunrise coordinates: \(RegionManager.shared.activeAppRegion)")
            return
        }
        
        let baseURL = AppURLManager.shared.getAppURL(URLName: "sunriseSunsetAPI") ?? "<Unknown sunrise/sunset URL>"
        var updatedURL = updateURL(url: baseURL, parameter: "latitude", value: String(coords.latitude))
        updatedURL = updateURL(url: updatedURL, parameter: "longitude", value: String(coords.longitude))
        guard let url = URL(string: updatedURL) else {
            print("Invalid URL for sunrise and sunset times")
            DispatchQueue.main.async { completion() }
            return
        }
        URLSession.shared.dataTask(with: url) { [weak self] data, response, error in
            if let error = error {
                print("Error for sunrise and sunset times: \(error.localizedDescription)")
                DispatchQueue.main.async { completion() }
                return
            }
            guard let data = data else {
                print("No data received for sunrise and sunset times")
                DispatchQueue.main.async { completion() }
                return
            }
            let decoder = JSONDecoder()
            if let decodedResponse = try? decoder.decode(SunriseSunsetResponse.self, from: data) {
                DispatchQueue.main.async {
                    sunriseSunset.sunrise = convertISODateToLocalTime(isoDateString: decodedResponse.results.sunrise)
                    sunriseSunset.sunset = convertISODateToLocalTime(isoDateString: decodedResponse.results.sunset)
                    self?.sunriseSunset = sunriseSunset
                    completion()
                }
            } else {
                DispatchQueue.main.async { completion() }
            }
        }.resume()
    }
}
import SwiftUI
import UIKit
typealias PlatformColor = UIColor

// Title bar colors
let backgroundColor                 : Color = .black
let sunImageColor                   : Color = .sunshine
let sunFontColor                    : Color = .titanium
let titleFontColor                  : Color = .white
let titlebarSeparatorColor          : Color = .darksky2

// Tool bar colors
let toolbarBackgroundColor          : Color = .darksky2
let toolbarImageColor               : Color = .sky
let toolbarFontColor                : Color = .sky
let toolbarActiveImageColor         : Color = .white
let toolbarActiveFontColor          : Color = .white

// Navigation bar (e.g., next/back nodes on pilot track detail)
let navigationBackgroundColor       : Color = .darksky

// View page colors
let sectionHeaderColor              : Color = .white
let rowHeaderColor                  : Color = .sky
let rowTextColor                    : Color = .white
let infoFontColor                   : Color = .titanium
let warningFontColor                : Color = .warning
let attributionBackgroundColor      : Color = .black
let attributionSheetBackgroundColor : Color = Color(.systemBackground)

// Skew-T chart colors
let skewTDALRColor                  : Color = .moodygray
let skewTDewpointColor              : Color = .displayValueGreen
let skewTTempColor                  : Color = .displayValueRed
let skewTGridBorderColor            : Color = .grayslime
let skewTGridLineColor              : Color = .grayslime
let skewTAxisLabelColor             : Color = .titanium
let skewTButtonBackgroundColor      : Color = .darksky2
let skewTButtonTextColor            : Color = .white

// Table and chart colors
let tableBackgroundColor            : Color = .gunmetal
let tableSectionDividerColor        : Color = .grayslime
let tableLabelFontColor             : Color = .white  // table data color is white, and changed based on conditional formatting
let tableMajorDividerColor          : Color = .titanium
let tableMinorDividerColor          : Color = tableBackgroundColor
let chartGradientStartColor         : Color = Color(.darkgray)
let chartGradientEndColor           : Color = Color(.darkgray)
let chartLineColor                  : Color = .sky
let chartCurrentNodeColor           : Color = .white
let sectionBackgroundColor          : Color = .gunmetal       // To emulate color scheme used in sheets
let potentialChartBackgroundColor   : Color = .potentialchartgray
let repeatDateTimeColor             : Color = .titanium

// Colors of forecast and reading values
let displayValueWhite               : Color = .displayValueWhite
let displayValueLime                : Color = .displayValueLime
let displayValueBlue                : Color = .displayValueBlue
let displayValueTeal                : Color = .displayValueTeal
let displayValueGreen               : Color = .displayValueGreen
let displayValueYellow              : Color = .displayValueYellow
let displayValueOrange              : Color = .displayValueOrange
let displayValueRed                 : Color = .displayValueRed
let displayValueClear               : Color = .clear

// Map page colors
let layersIconColor                 : Color = .sky
let layersTextColor                 : Color = .sky
let layersIconBackgroundColor       : Color = .black
let loadingBarBackgroundColor       : Color = .gunmetal
let loadingBarTextColor             : Color = .titanium
let cameraAnnotationColor           : Color = .white
let cameraAnnotationTextColor       : Color = cameraAnnotationColor
//  siteAnnotationColor not defined here; it is established by the image
let siteAnnotationTextColor         : UIColor = UIColor(.white)
//  pilotNodeAnnotationColor not defined here; it is established by pilot track colors
let pilotLabelNameTextColor         : Color = .white
let pilotLabelDateTextColor         : Color = .titanium
let pilotLabelAltTextColor          : Color = .sky
let pilotEmergencyAnnotationColor   : Color = .red
let pilotEmergencyAnnotationTextColor: Color = .poppy
let pilotTrackColor                 : Color = .white
let defaultAnnotationColor          : Color = .black
let defaultAnnotationTextColor      : Color = .white

// Pilot listing colors
let pilotActiveFontColor: Color = .white
let pilotInactiveFontColor: Color = .titanium

// Images
let windArrow                       : String = "arrow.up"
let sortImage                       : String = "arrow.up.arrow.down"
let checkmarkImage                  : String = "checkmark"
let layersImage                     : String = "square.3.layers.3d"
let playImage                       : String = "play.fill"
let pauseImage                      : String = "pause.fill"
let cameraAnnotationImage           : String = "camera.circle"
let defaultAnnotationImage          :  String = "questionmark"
let siteAnnotationImage             : UIImage = UIImage(imageLiteralResourceName: "roundPGicon")
let pilotLaunchAnnotationImage      : UIImage = UIImage(systemName: "play.fill")!   // Could use "dot.circle", "paperplane.fill",
                                                                                    // "arrow.up.right.circle.fill"
let pilotLatestAnnotationImage      : UIImage = UIImage(imageLiteralResourceName: "PGIconNoBorder") // or systemName: "flag.checkered")!
let pilotMessageAnnotationImage     : UIImage = UIImage(systemName: "envelope.fill")! // Could use "bubble.fill"
let pilotInEmergencyAnnotationImage : UIImage = UIImage(systemName: "exclamationmark.triangle.fill")!
let flyingPotentialImage            : String = "circle.fill"

// Pilot track log colors
// (assigned dynamically to differentiate pilot tracks on map)
let pilotColorPalette: [PlatformColor] = [
    PlatformColor(.electric),
    PlatformColor(.champion),
    PlatformColor(.apple),
    PlatformColor(.poppy),
    PlatformColor(.periwinkle),
    PlatformColor(.orangetheme),
    PlatformColor(.magentatheme),
    PlatformColor(.bubblegum),
    PlatformColor(.slime),
    PlatformColor(.buttercup),
    PlatformColor(.tealtheme),
    PlatformColor(.jolt),
    PlatformColor(.brightlime),
    PlatformColor(.bluesky),
    PlatformColor(.purplerain),
    PlatformColor(.barbi)
]
import SwiftUI
import Combine

// Note:  Use the globally available function calls in AppRegionManager to access data

struct AppRegionCode {
    let appRegion: String
    let airportCode: String
    let stationCode: String
    let name: String
    let AFD: String
    let soundingModel: String
    let windsAloft: String
    let soaringForecastRichSimple: String
    let soaringForecastBasic: String
    let weatherAlerts: String
}

struct AppRegionCodesResponse: Codable {
    let values: [[String]]
}

class AppRegionCodesViewModel: ObservableObject {
    @Published var appRegionCodes: [AppRegionCode] = []
    private var cancellables = Set<AnyCancellable>()
    let sheetName = "RegionCodes"
    
    func getAppRegionCodes(completion: @escaping () -> Void) {
        let appRegionCodesURLString = "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(sheetName)?alt=json&key=\(googleAPIKey)"
        guard let url = URL(string: appRegionCodesURLString) else {
            print("Invalid URL for app region codes")
            DispatchQueue.main.async { completion() }
            return
        }
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: AppRegionCodesResponse.self, decoder: JSONDecoder())
        
            .map { response -> [AppRegionCode] in
                // Skip first three header rows
                response.values.dropFirst(3).compactMap { row in
                    guard row.count >= 2 else {
                        print("Skipping malformed app region code row: \(row)")
                        return nil
                    }
                    let appRegion = row[0]
                    let airportCode = row[1]
                    let stationCode = row.count > 2 ? row[2] : ""
                    let name = row.count > 3 ? row[3] : ""
                    let AFD = row.count > 4 ? row[4] : ""
                    let soundingModel = row.count > 5 ? row[5] : ""
                    let windsAloft = row.count > 6 ? row[6] : ""
                    let soaringForecastRichSimple = row.count > 7 ? row[7] : ""
                    let soaringForecastBasic = row.count > 8 ? row[8] : ""
                    let weatherAlerts = row.count > 9 ? row[9] : ""
                    
                    // Make sure region, airport code are populated
                    guard !appRegion.isEmpty,
                          !airportCode.isEmpty else {
                        print("Skipping app region code row with missing critical fields: \(row)")
                        return nil
                    }
                    
                    return AppRegionCode(appRegion: appRegion,
                                     airportCode: airportCode,
                                     stationCode: stationCode,
                                     name: name,
                                     AFD: AFD,
                                     soundingModel: soundingModel,
                                     windsAloft: windsAloft,
                                     soaringForecastRichSimple: soaringForecastRichSimple,
                                     soaringForecastBasic: soaringForecastBasic,
                                     weatherAlerts: weatherAlerts
                    )
                }
            }
            .replaceError(with: [])
            .receive(on: DispatchQueue.main)

            // Save region codess globally so they can be accessed from anywhere in the app
            .handleEvents(receiveOutput: { [weak self] appRegionCodes in
                self?.appRegionCodes = appRegionCodes
                AppRegionCodesManager.shared.setAppRegionCodes(appRegionCodes) // global set
            }, receiveCompletion: { _ in
                completion()
            })
        
            .sink { _ in }
            .store(in: &cancellables)
    }
    
}
import SwiftUI
import Combine

// Summer ("rich") and Winter ("simple") Soaring Forecast and Sounding

struct SoaringForecast: Identifiable {
    let id = UUID()
    let date: String
    let soaringForecastFormat: String
    let triggerTempData: String
    let soaringForecastData: [SoaringForecastData]
    let soundingData: [SoundingData]
    let richSoundingData: [RichSoundingData]
    let modelData: [ModelData]
    let forecastMaxTemp: Int
}
struct SoaringForecastData: Identifiable {
    let id = UUID()
    let heading: String
    let value: String?
}
struct SoundingData: Identifiable {
    let id = UUID()
    let altitude: String
    let windDirection: Int
    let windSpeed: Int
}
struct RichSoundingData: Identifiable {
    let id = UUID()
    let altitude: Int
    let temperatureF: Double
    let windDirection: Int
    let windSpeedKt: Int
    let thermalIndex: Double
    let liftRateMs: Double
    var windSpeedMph: Double {return Double(windSpeedKt) * 1.15078}
}
struct ModelData: Identifiable {
    let id = UUID()
    let value: String
}

class SoaringForecastViewModel: ObservableObject {
    @Published var soaringForecast: SoaringForecast?
    @Published var isLoading = false
    
    func fetchSoaringForecast(airportCode: String) {
        isLoading = true
        
        // Get base URL, update parameters, and format into URL format
        guard let baseURL = AppURLManager.shared.getAppURL(URLName: "soaringForecastRichSimple") else {
            print("Could not find rich/simple soaring forecast URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        let updatedURL = updateURL(url: baseURL, parameter: "airportcode", value: airportCode)
        
        // Format URL
        guard let URL = URL(string: updatedURL)
        else {
            print("Invalid rich/simple soaring forecast URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        
        // Process URL query
        URLSession.shared.dataTask(with: URL) { [weak self] data, response, error in
            guard let self = self else { return }
            guard let data = data, error == nil else {
                DispatchQueue.main.async { self.isLoading = false }
                return
            }
            if let content = String(data: data, encoding: .utf8) {
                
                // Check if the output is formatted using the summer (rich) forecast
                if content.contains("Soaring Forecast") {
                    self.parseRichSoaringForecast(content: content)
                }
                // The winter (simple) version should contain "SOARING FORECAST" instead
                else {
                    self.parseSimpleSoaringForecast(content: content)
                }
                
            }
        }.resume()
    }
    
    // Summer soaring forecast with additional data
    func parseRichSoaringForecast(content: String) {
        let start = "National Weather Service"
        let datePrefix = "This forecast is for "
        let triggerTempPrefix = ":"
        let soaringForecastPrefix = "...then"
        let remarksPrefix = "Remarks..."
        // let soundingSummaryPrefix = "Upper air data from rawinsonde observation taken on "
        // Prefix below skips header rows on sounding table data
        let soundingPrefix = "--------------------------------------------------------------------------------"
        let modelPrefix = "* * * * * * Numerical weather prediction model forecast data valid * * * * * *"
        var endPrefix = "This product is issued"
        guard let startRange = content.range(of: start)
        else {
            print("Soaring forecast: could not parse start date (e.g., no row for \(start))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let dateRange = content.range(of: datePrefix, range: startRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse date range (e.g., no row for \(datePrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let triggerTempRange = content.range(of: triggerTempPrefix, range: dateRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse soaring forecast data range (e.g., no row for \(soaringForecastPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soaringForecastRange = content.range(of: soaringForecastPrefix, range: triggerTempRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse soaring forecast data range (e.g., no row for \(soaringForecastPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let remarksRange = content.range(of: remarksPrefix, range: soaringForecastRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse remarks data range (e.g., no row for \(remarksPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soundingRange = content.range(of: soundingPrefix, range: remarksRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse sounding data range (e.g., no row for \(soundingPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let modelRange = content.range(of: modelPrefix, range: soundingRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse model forecast data range (e.g., no row for \(soundingPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        // Forecast had typos on 5/8/2025; added code to fix for this scenario
        if (content.range(of: endPrefix, range: modelRange.upperBound..<content.endIndex) == nil) {
            endPrefix = "s product is issued"
        }
        guard let endRange = content.range(of: endPrefix, range: modelRange.upperBound..<content.endIndex)
        else {
            print("Could not parse end range (e.g., no row for \(endPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        
        // Process soaring forecast date
        let date = removeExtraBlankLines(String(content[dateRange.upperBound..<triggerTempRange.lowerBound]))
        
        // Process trigger temp statement
        var triggerTempString = removeExtraBlankLines(String(content[triggerTempRange.upperBound..<soaringForecastRange.lowerBound])) + ":"
        triggerTempString = triggerTempString
            .replacingOccurrences(of: "the ", with: "")
            .replacingOccurrences(of: "temperature", with: "temp")
        triggerTempString = removeTextFromOpenToClose(triggerTempString, open: "/", close: "C")     // Remove max temp in Celsius
        triggerTempString = roundNumbersInString(in: triggerTempString)
        
        // Process soaring forecast
        let soaringForecastDataString = removeExtraBlankLines(String(content[soaringForecastRange.upperBound..<remarksRange.lowerBound]))
        let soaringForecast = parseRichSoaringForecastData(soaringForecastDataString)
        // Note:  remarks section is ignored
        
        // Process rich sounding data
        let soundingDataString = removeExtraBlankLines(String(content[soundingRange.upperBound..<modelRange.lowerBound]))
        let richSoundingData = parseRichSoundingData(soundingDataString)
        
        // Set default for simple sounding data (rich sounding data above used instead)
        var soundingData: [SoundingData] = []
        soundingData.append(SoundingData(altitude: "0", windDirection: 0, windSpeed: 0))
        
        // Process numerical model data
        let modelDataString = String(content[modelRange.upperBound..<endRange.lowerBound])
        let modelData = parseModelData(modelDataString)
        
        // Get forecast max temp for use in morning sounding diagram
        var forecastMaxTemp = 0
        let maxTempRange = soaringForecastDataString.lowercased().range(of: "forecast maximum temperature")
        if maxTempRange != nil {
            let substringAfterKeyword = soaringForecastDataString[maxTempRange!.upperBound... ]
            let maxTempPattern = "\\d+"
            if let maxTempMatch = substringAfterKeyword.range(of: maxTempPattern, options: .regularExpression) {
                forecastMaxTemp = Int(substringAfterKeyword[maxTempMatch]) ?? 0
            }
        }
        
        DispatchQueue.main.async {
            self.isLoading = false
            self.soaringForecast = SoaringForecast(date: date, soaringForecastFormat: "rich", triggerTempData: triggerTempString, soaringForecastData: soaringForecast, soundingData: soundingData, richSoundingData: richSoundingData, modelData: modelData, forecastMaxTemp: forecastMaxTemp)
        }
    }
    
    // Winter soaring forecast with limited data
    func parseSimpleSoaringForecast(content: String) {
        let start = "SOARING FORECAST FOR SALT LAKE CITY"
        let datePrefix = "DATE..."
        let soaringForecastPrefix = "THERMAL INDEX..."
        let soundingPrefix = "UPPER LEVEL WINDS AT SALT LAKE CITY"
        let endPrefix = "20000 FT"
        guard let startRange = content.range(of: start)
        else {
            print("Soaring forecast: could not parse start date (e.g., no row for \(start))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let dateRange = content.range(of: datePrefix, range: startRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse date range (e.g., no row for \(datePrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soaringForecastRange = content.range(of: soaringForecastPrefix, range: dateRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse soaring forecast data range (e.g., no row for \(soaringForecastPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let soundingRange = content.range(of: soundingPrefix, range: soaringForecastRange.upperBound..<content.endIndex)
        else {
            print("Soaring forecast: could not parse sounding data range (e.g., no row for \(soundingPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        guard let endRange = content.range(of: endPrefix, range: soundingRange.upperBound..<content.endIndex)
        else {
            print("Could not parse end range (e.g., no row for \(endPrefix))")
            DispatchQueue.main.async { self.isLoading = false }
            return
        }
        let modelData: [ModelData] = []     // Not used in this forecast
        let date = String(content[dateRange.upperBound...].prefix(9)).trimmingCharacters(in: .whitespacesAndNewlines)
        let soaringForecastDataString = removeExtraBlankLines(String(content[soaringForecastRange.upperBound..<soundingRange.lowerBound]))
        let soaringForecast = parseSimpleSoaringForecastData(soaringForecastDataString)
        let soundingDataString = removeExtraBlankLines(String(content[soundingRange.upperBound..<endRange.lowerBound]))
        let soundingData = soundingDataString
            .replacingOccurrences(of: " FT MSL", with: "")
            .replacingOccurrences(of: ".", with: "")
            .split(separator: "\n")
            .compactMap { line -> SoundingData? in
                let components = line.split(separator: " ")
                guard components.count >= 6,
                      let altitude = components.first,
                      let windDirection = Int(components[1]),
                      let windSpeed = Int(components[4])
                else {
                    return nil }
                let windSpeedMph = convertKnotsToMPH(Int(windSpeed))
                let altitudeString = formatAltitude(String(altitude))
                return SoundingData(altitude: altitudeString, windDirection: windDirection, windSpeed: windSpeedMph)
            }
        
        // pass back default for rich sounding data (not used)
        var richSoundingData: [RichSoundingData] = []
        richSoundingData.append(RichSoundingData(altitude: 0, temperatureF: 0.0, windDirection: 0, windSpeedKt: 0, thermalIndex: 0.0, liftRateMs: 0.0))
        
        // Find forecast max temp to use in skew-T diagarm
        var forecastMaxTemp: Int = 0
        let pattern = "forecast max temp\\s+(\\d+\\.?\\d*)"
        let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)
        let nsString = soaringForecastDataString as NSString
        let results = regex?.matches(in: soaringForecastDataString, options: [], range: NSRange(location: 0, length: nsString.length))
        if let match = results?.first, let range = Range(match.range(at: 1), in: soaringForecastDataString) {
            forecastMaxTemp = Int(soaringForecastDataString[range]) ?? 0
        }
        
        DispatchQueue.main.async {
            self.isLoading = false
            self.soaringForecast = SoaringForecast(date: date,
                                                   soaringForecastFormat:   "Simple",
                                                   triggerTempData:         "",
                                                   soaringForecastData:     soaringForecast,
                                                   soundingData:            soundingData.reversed(),
                                                   richSoundingData:        richSoundingData,
                                                   modelData:               modelData,
                                                   forecastMaxTemp:         forecastMaxTemp)
        }
    }
    
    func parseRichSoaringForecastData(_ input: String) -> [SoaringForecastData] {
        var formattedInput = input
            .replacingOccurrences(of: "Maximum", with: "Max")
            .replacingOccurrences(of: "maximum", with: "max")
            .replacingOccurrences(of: "Temperature", with: "Temp")
            .replacingOccurrences(of: "temperature", with: "temp")
            .replacingOccurrences(of: "MSL", with: "")
            .replacingOccurrences(of: "Degrees", with: "°")
            .replacingOccurrences(of: "Slc", with: "SLC")  // override capitalized for SLC
        formattedInput = removeTextFromOpenToClose(formattedInput, open: "/", close: "C")     // Remove max temp in Celsius
        formattedInput = formatTimeinString(from: formattedInput)
        
        // Remove the max rate of lift containing "# ft/min"
        let patternFtMin = "\\d+ ft/min"
        let regexFtMin = try! NSRegularExpression(pattern: patternFtMin)
        let rangeFtMin = NSRange(location: 0, length: formattedInput.utf16.count)
        formattedInput = regexFtMin.stringByReplacingMatches(in: formattedInput, options: [], range: rangeFtMin, withTemplate: "").trimmingCharacters(in: .whitespaces)
        
        // Remove parentheses around max rate of lift containing "# m/s"
        let patternMsWithParentheses = "\\((\\d+\\.\\d+ m/s)\\)"
        let regexMsWithParentheses = try! NSRegularExpression(pattern: patternMsWithParentheses)
        let rangeMsWithParentheses = NSRange(location: 0, length: formattedInput.utf16.count)
        formattedInput = regexMsWithParentheses.stringByReplacingMatches(in: formattedInput, options: [], range: rangeMsWithParentheses, withTemplate: "$1").trimmingCharacters(in: .whitespaces)
        
        formattedInput = formatNumbersInString(removeTextInParentheses(formattedInput))
        // Removed rounding because I care more about m/s with decimal than removing decimal from temps
        // formattedInput = roundNumbersInString(in: formattedInput)
        let lines = formattedInput.split(separator: "\n")
        var dataRows: [SoaringForecastData] = []
        for line in lines {
            let components = line.split(separator: ".", omittingEmptySubsequences: true)
            if components.count > 1 {
                let heading = components[0].trimmingCharacters(in: .whitespacesAndNewlines)
                let value = components.dropFirst().joined(separator: ".").trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(SoaringForecastData(heading: heading, value: value))
            } else {
                let heading = line.trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(SoaringForecastData(heading: heading, value: nil))
            }
        }
        return dataRows
    }
    
    func parseRichSoundingData(_ input: String) -> [RichSoundingData] {
        let lines = input.split(separator: "\n")
        var richSoundingData: [RichSoundingData] = []
        for line in lines { // Header rows parsed out above; otherwise use .dropFirst(3)
            let columns = line.split(separator: " ", omittingEmptySubsequences: true)
            if columns.count >= 13, let altitude = Int(columns[0]), altitude <= 18000 {
                let temperatureF = Double(columns[2]) ?? 0.0
                let windDirection = Int(columns[3]) ?? 0
                let windSpeedKt = Int(columns[4]) ?? 0
                let thermalIndex = Double(columns[10]) ?? 0.0
                let liftRateMs = Double(columns[12]) ?? 0.0
                
                let dataRow = RichSoundingData(altitude: altitude, temperatureF: temperatureF, windDirection: windDirection, windSpeedKt: windSpeedKt, thermalIndex: thermalIndex, liftRateMs: liftRateMs)
                richSoundingData.append(dataRow)
            }
        }
        return richSoundingData
    }
    
    func parseSimpleSoaringForecastData(_ input: String) -> [SoaringForecastData] {
        let cleanedInput = input
            .replacingOccurrences(of: "MSL", with: "")
            .replacingOccurrences(of: "DEGREES", with: "°")
            .capitalized(with: Locale.current)
            .replacingOccurrences(of: "Slc", with: "SLC")  // override capitalized for SLC
        let lines = cleanedInput.split(separator: "\n")
        var dataRows: [SoaringForecastData] = []
        for line in lines {
            let components = line.split(separator: ".", omittingEmptySubsequences: true)
            if components.count > 1 {
                let heading = components[0].trimmingCharacters(in: .whitespacesAndNewlines)
                let value = components.dropFirst().joined(separator: ".").trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(SoaringForecastData(heading: heading, value: value))
            } else {
                let heading = line.trimmingCharacters(in: .whitespacesAndNewlines)
                dataRows.append(SoaringForecastData(heading: heading, value: nil))
            }
        }
        return dataRows
    }
    
    func parseModelData(_ input: String) -> [ModelData] {
        let lines = input.split(separator: "\n")
        var dataRows: [ModelData] = []
        for line in lines {
            dataRows.append(ModelData(value: String(line)))
        }
        return dataRows
    }
}
import SwiftUI
import Combine
import MapKit

// Pilot live tracking structure
struct PilotTrack: Identifiable, Equatable, Hashable {
    let id: UUID = UUID()
    let pilotName: String   // For consistency, this is set based on pilots.pilotName, not pilot name from InReach data
    let dateTime: Date
    let latitude: Double
    let longitude: Double
    let speed: Double
    let altitude: Double
    let heading: Double
    let inEmergency: Bool
    let message: String?
}

// Listing of pilot live tracks by pilot name and date
// used to determine track groupings for line rendering on track
struct PilotTrackKey: Hashable {
    let pilotName: String
    let date: Date
}

// Annotation for pilot tracks to allow polylines as an overlay on map
class PilotTrackAnnotation: NSObject, MKAnnotation {
    let coordinate: CLLocationCoordinate2D
    let title: String?
    let subtitle: String?
    let annotationType: String
    let pilotTrack: PilotTrack?

    let pilotName: String
    let isFirst: Bool
    let isLast: Bool
    let isEmergency: Bool
    let hasMessage: Bool

    init(coordinate: CLLocationCoordinate2D,
         title: String?,
         subtitle: String?,
         annotationType: String,
         pilotTrack: PilotTrack?,
         pilotName: String,
         isFirst: Bool,
         isLast: Bool,
         isEmergency: Bool,
         hasMessage: Bool
    ) {
        self.coordinate = coordinate
        self.title = title
        self.subtitle = subtitle
        self.annotationType = annotationType
        self.pilotTrack = pilotTrack
        self.pilotName = pilotName
        self.isFirst = isFirst
        self.isLast = isLast
        self.isEmergency = isEmergency
        self.hasMessage = hasMessage
    }
}

@MainActor
class PilotTrackViewModel: ObservableObject {
    @Published private(set) var pilotTracks: [PilotTrack] = []
    @Published var isLoading = false

    private let pilotViewModel: PilotViewModel
    private var cancellables = Set<AnyCancellable>()
    private let session: URLSession

    private let maxConcurrentRequests = 8
    private let maxConnectionsPerHost = 12
    
    // Check for in flight pilot refreshes overlapping with new requests
    private var inflightTasks: [Task<Void, Never>] = []

    // Midnight-of-last-cache build. When the date rolls past this, clear everything.
    private var cacheDate: Date = Calendar.current.startOfDay(for: Date())

    // Per-pilot cache entry
    private struct CacheEntry {
        let urlString: String
        var lastFetch: Date
        var lastDays: Double
        var tracks: [PilotTrack]
    }
    
    // Map from pilotName to cache entry
    private var cache: [String: CacheEntry] = [:]

    init(pilotViewModel: PilotViewModel) {
        self.pilotViewModel = pilotViewModel

        // Tune URLSession
        let cfg = URLSessionConfiguration.ephemeral
//        let cfg = URLSessionConfiguration.default
        cfg.httpMaximumConnectionsPerHost = maxConnectionsPerHost
        self.session = URLSession(configuration: cfg)

        pilotViewModel.$pilots
            .sink { _ in /* no-op: fetch is triggered by view logic */ }
            .store(in: &cancellables)
    }

    func getPilotTracks(
        days: Double,
        selectedPilots: [Pilot],
        completion: @escaping () -> Void
    ) {
        // Roll‐over cache at midnight
        let today = Calendar.current.startOfDay(for: Date())
        if today > cacheDate {
            cache.removeAll()
            cacheDate = today
        }

        // Identify selected pilots (or all)
        let pilotsToConsider = selectedPilots.isEmpty
            ? pilotViewModel.pilots
            : selectedPilots

        isLoading = true
        inflightTasks.forEach { $0.cancel() }
        inflightTasks.removeAll()

        // Kick off a single Task that fetches all selected pilots
        let task = Task { [weak self] in
            guard let self = self else { return }

            // fetchAllTracks will call fetchTracks(for:days:) for each pilot,
            // and each per-pilot call will consult its own URL-based cache.
            let freshTracks = await self.fetchAllTracks(
                pilots: pilotsToConsider,
                days: days
            )

            // Sort + publish results
            let sorted = freshTracks.sorted { $0.dateTime < $1.dateTime }
            self.pilotTracks = sorted
            self.isLoading    = false
            completion()
        }
        inflightTasks.append(task)
    }
    
    // Throttled parallel fetch of multiple pilots
    private func fetchAllTracks(
        pilots: [Pilot],
        days: Double
    ) async -> [PilotTrack] {
        let semaphore = AsyncSemaphore(value: maxConcurrentRequests)
        
        // Log pilot track timings
        let startTime: Date = Date()

        return await withTaskGroup(of: [PilotTrack].self) { group in
            for pilot in pilots {
                group.addTask {
                    await semaphore.wait()
                    defer { Task { await semaphore.signal() } }
                    return await self.fetchTracks(for: pilot, days: days)
                }
            }

            var combined: [PilotTrack] = []
            for await chunk in group {
                combined.append(contentsOf: chunk)
            }
            
            // Log pilot track timings
            if printPilotTracksTimings {
                let endTime = Date()
                let duration = (endTime.timeIntervalSince(startTime) * 100).rounded()/100
                print("Total fetchAllTracks execution time: \(duration) seconds")
            }
            
            return combined
        }
        
    }

    // Single-pilot fetch
    private func fetchTracks(
        for pilot: Pilot,
        days: Double
    ) async -> [PilotTrack] {
        
        // Do not get tracks for inactive pilots
        if pilot.inactive {
            return []
        }
        
        // Log pilot track timings
        let startTime = Date()
        
        // Build URL for pilot
        guard let url = constructURL(
            trackingURL: pilot.trackingFeedURL,
            days: days,
        ) else {
            return []
        }
        let urlStr = url.absoluteString
        
        // Do not re-fetch if we have a cache entry with the same URL, same days, and it’s been fetched recently
        if let entry = cache[pilot.pilotName],
           entry.urlString == urlStr,
           entry.lastDays   == days,
           Date().timeIntervalSince(entry.lastFetch) < pilotTrackRefreshInterval
        {
            // No network call; just return what was previously parsed:
            if printPilotTracksTimings {
                print("Using cached tracks for \(pilot.pilotName)")
            }
            return entry.tracks
        }
        
        // Print tracking feed URL for development
        if printPilotTrackURLs {
            print("Fetching tracks for \(pilot.pilotName): \(url)")
        }

        var request = URLRequest(url: url)
        request.setValue(
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) " +
            "AppleWebKit/537.36 (KHTML, like Gecko) " +
            "Chrome/136.0.0.0 Safari/537.36",
            forHTTPHeaderField: "User-Agent"
        )
        request.setValue(
            "text/html,application/xhtml+xml,application/xml;" +
            "q=0.9,image/avif,image/webp,image/apng,*/*;" +
            "q=0.8,application/signed-exchange;v=b3;q=0.7",
            forHTTPHeaderField: "Accept"
        )
        request.setValue("en-US,en;q=0.9", forHTTPHeaderField: "Accept-Language")
        request.setValue("close", forHTTPHeaderField: "Connection")
//        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("1", forHTTPHeaderField: "DNT")
        request.setValue("document", forHTTPHeaderField: "Sec-Fetch-Dest")
        request.setValue("navigate", forHTTPHeaderField: "Sec-Fetch-Mode")
        request.setValue("none", forHTTPHeaderField: "Sec-Fetch-Site")
        request.setValue("?1", forHTTPHeaderField: "Sec-Fetch-User")
        request.setValue("1", forHTTPHeaderField: "Upgrade-Insecure-Requests")
        request.setValue(
            "\"Chromium\";v=\"136\", \"Google Chrome\";v=\"136\", " +
            "\"Not.A/Brand\";v=\"99\"",
            forHTTPHeaderField: "sec-ch-ua"
        )
        request.setValue("?0", forHTTPHeaderField: "sec-ch-ua-mobile")
        request.setValue("\"macOS\"", forHTTPHeaderField: "sec-ch-ua-platform")
        
        request.timeoutInterval = 10

        do {
            let (data, _) = try await session.data(for: request)
            
            // Log pilot track timings
            if printPilotTracksTimings {
                let endTime = Date()
                let duration = (endTime.timeIntervalSince(startTime) * 100).rounded()/100
                print("Total fetchTracks for \(pilot.pilotName) execution time: \(duration) seconds")
                
            }
            let parsed = parseKML(pilotName: pilot.pilotName, data: data)
            // Store into cache
            cache[pilot.pilotName] = CacheEntry(
                urlString: urlStr,
                lastFetch: Date(),
                lastDays:   days,
                tracks:     parsed
            )
            return parsed
            
        } catch {
            print("Error fetching tracks for \(pilot.pilotName): \(error)")
            return []
        }
        
    }

    private func constructURL(
        trackingURL: String,
        days: Double
    ) -> URL? {
        let date = getDateForDays(days: days)
        let iso = ISO8601DateFormatter()
        iso.formatOptions = [.withInternetDateTime]
        let dateString = iso.string(from: date)
        return URL(string: "\(trackingURL)?d1=\(dateString)")
    }

    private func parseKML(
        pilotName: String,
        data: Data
    ) -> [PilotTrack] {
        guard let xml = String(data: data, encoding: .utf8) else {
            return []
        }
        let placemarks = extractAllValues(
            from: xml,
            using: "<Placemark>",
            endTag: "</Placemark>"
        )
        guard !placemarks.isEmpty else { return [] }

        let formatter = DateFormatter()
        formatter.dateFormat = "M/d/yyyy h:mm:ss a"
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(abbreviation: "UTC")

        return placemarks.compactMap { pm in
            guard
                var name = extractValue(
                    from: pm,
                    using: "<Data name=\"Name\">",
                    endTag: "</Data>"
                ),
                let timeStr = extractValue(
                    from: pm,
                    using: "<Data name=\"Time UTC\">",
                    endTag: "</Data>"
                ),
                let latStr = extractValue(
                    from: pm,
                    using: "<Data name=\"Latitude\">",
                    endTag: "</Data>"
                ),
                let lonStr = extractValue(
                    from: pm,
                    using: "<Data name=\"Longitude\">",
                    endTag: "</Data>"
                )
            else {
                return nil
            }

            // Ignoring track pilot name and using pilots.pilotName for consistency
            /*if name.lowercased() != pilotName.lowercased() {
                name = "\(name) (\(pilotName))"
            } */
            name = pilotName
            
            let dateTime = formatter.date(from: timeStr) ?? Date()
            let speedKM = extractNumber(
                from: extractValue(
                    from: pm,
                    using: "<Data name=\"Velocity\">",
                    endTag: "</Data>"
                ) ?? ""
            ) ?? 0
            let speed = convertKMToMiles(speedKM).rounded()
            let altM = extractNumber(
                from: extractValue(
                    from: pm,
                    using: "<Data name=\"Elevation\">",
                    endTag: "</Data>"
                ) ?? ""
            ) ?? 0
            let altitude = Double(convertMetersToFeet(altM))
            let course = extractNumber(
                from: extractValue(
                    from: pm,
                    using: "<Data name=\"Course\">",
                    endTag: "</Data>"
                ) ?? ""
            ) ?? 0
            let inEmg = Bool(
                extractValue(
                    from: pm,
                    using: "<Data name=\"In Emergency\">",
                    endTag: "</Data>"
                )?.lowercased() ?? "false"
            ) ?? false
            let message = extractValue(
                from: pm,
                using: "<Data name=\"Text\">",
                endTag: "</Data>"
            )

            return PilotTrack(
                pilotName: name,
                dateTime: dateTime,
                latitude: Double(latStr) ?? 0,
                longitude: Double(lonStr) ?? 0,
                speed: speed,
                altitude: altitude,
                heading: course,
                inEmergency: inEmg,
                message: message
            )
        }
    }

    private func extractAllValues(
        from text: String,
        using startTag: String,
        endTag: String
    ) -> [String] {
        var results: [String] = []
        var searchRange: Range<String.Index>? = text.startIndex..<text.endIndex
        while let start = text.range(of: startTag, range: searchRange),
              let end = text.range(of: endTag, range: start.upperBound..<text.endIndex)
        {
            let snippet = String(text[start.upperBound..<end.lowerBound])
            results.append(snippet)
            searchRange = end.upperBound..<text.endIndex
        }
        return results
    }

    private func extractValue(
        from text: String,
        using startTag: String,
        endTag: String
    ) -> String? {
        guard
            let start = text.range(of: startTag),
            let end = text.range(of: endTag, range: start.upperBound..<text.endIndex)
        else {
            return nil
        }
        let tagContents = String(text[start.upperBound..<end.lowerBound])
        guard
            let vStart = tagContents.range(of: "<value>"),
            let vEnd = tagContents.range(of: "</value>", range: vStart.upperBound..<tagContents.endIndex)
        else {
            return nil
        }
        return String(tagContents[vStart.upperBound..<vEnd.lowerBound])
    }

    // Async semaphore that suspends rather than blocks threads.
    actor AsyncSemaphore {
        private var available: Int
        private var waiters: [CheckedContinuation<Void, Never>] = []

        init(value: Int) {
            self.available = value
        }

        func wait() async {
            if available > 0 {
                available -= 1
            } else {
                await withCheckedContinuation { cont in
                    waiters.append(cont)
                }
            }
        }

        func signal() {
            if let cont = waiters.first {
                waiters.removeFirst()
                cont.resume()
            } else {
                available += 1
            }
        }
    }
}
import SwiftUI
import Combine

// Area Forecast Discussion (AFD)
struct AFD: Identifiable {
    let id = UUID()
    let date: String
    let keyMessages: String?    // Used in Colorado, not Utah
    let synopsis: String?
    let discussion: String?     // Sometimes, AFD has a "DISCUSSION" section
    let shortTerm: String?      // and somethines it has "SHORT TERM" and "LONG TERM" sections instead
    let longTerm: String?
    let aviation: String?
}
class AFDViewModel: ObservableObject {
    @Published var AFDvar: AFD?
    @Published var isLoading = false
    private var cancellable: AnyCancellable?

    func fetchAFD(airportCode: String) {
        isLoading = true

        // Get base URL, update parameters, and format into URL format
        guard let baseURL = AppURLManager.shared.getAppURL(URLName: "areaForecastDiscussionURL")
        else {
            print("Could not find AFD URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }
        let updatedURL = updateURL(url: baseURL, parameter: "airportcode", value: airportCode)
        
        // Format URL
        guard let URL = URL(string: updatedURL)
        else {
            print("Invalid AFD URL for appRegion: \(RegionManager.shared.activeAppRegion)")
            isLoading = false
            return
        }

        // Process URL query
        cancellable = URLSession.shared.dataTaskPublisher(for: URL)
            .map { $0.data }
            .map { String(data: $0, encoding: .utf8) }
            .map { $0.flatMap(self.parseAFDData) }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] afd in
                self?.AFDvar     = afd
                self?.isLoading  = false
            }
    }

    private func parseAFDData(_ data: String) -> AFD? {
        guard let startRange = data.range(of: "National Weather Service") else {
            print("Could not parse AFD start range")
            return nil
        }

        let AFDData = data[startRange.upperBound...]

        guard let dateRange = AFDData.range(of: "\\d{3,4} [A-Za-z]{2} [A-Za-z]{3} [A-Za-z]{3} [A-Za-z]{3} \\d{1,2} \\d{4}", options: .regularExpression) else {
            print("Could not parse AFD date range")
            return nil
        }

        let date = String(AFDData[dateRange])
        
        let keyMessages = collapseTextLines(extractSection(from: AFDData, start: ".KEY MESSAGES", end: "&&"))
        let synopsis = collapseTextLines(extractSection(from: AFDData, start: ".SYNOPSIS", end: "&&"))
        let discussion = collapseTextLines(extractSection(from: AFDData, start: ".DISCUSSION", end: "&&"))
        let shortTerm = collapseTextLines(extractSection(from: AFDData, start: ".SHORT TERM", end: ".LONG TERM"))
        let longTerm = collapseTextLines(extractSection(from: AFDData, start: ".LONG TERM", end: "&&"))
        let aviation = collapseTextLines(extractSection(from: AFDData, start: ".AVIATION", end: "&&"))
        
        return AFD(date: date,
                   keyMessages: keyMessages,
                   synopsis: synopsis,
                   discussion: discussion,
                   shortTerm: shortTerm,
                   longTerm: longTerm,
                   aviation: aviation)
    }
}
import SwiftUI
import Combine

// Get lift parameters for common use
struct LiftParameterSource: Codable, Identifiable {
    var id = UUID()
    var parameter: String
    var value: Double
    var notes: String
}
struct LiftParametersResponse: Codable {
    var values: [[String]]
}
// Published view model structure
struct LiftParameters: Codable {
    var thermalLapseRate: Double
    var thermalVelocityConstant: Double
    var initialTriggerTempDiff: Double
    var ongoingTriggerTempDiff: Double
    var thermalRampDistance: Double
    var thermalRampStartPct: Double
    var cloudbaseLapseRatesDiff: Double
    var thermalGliderSinkRate: Double
}
class LiftParametersViewModel: ObservableObject {
    @Published var liftParameters: LiftParameters?
    
    func getLiftParameters(completion: @escaping () -> Void) {
        var liftParameters: LiftParameters = .init(thermalLapseRate: 0, thermalVelocityConstant: 0, initialTriggerTempDiff: 0, ongoingTriggerTempDiff: 0, thermalRampDistance: 0, thermalRampStartPct: 0, cloudbaseLapseRatesDiff: 0, thermalGliderSinkRate: 0)
        let rangeName = "LiftParameters"
        let liftParameterURLString = "https://sheets.googleapis.com/v4/spreadsheets/\(globalGoogleSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)"
        guard let liftParameterURL = URL(string: liftParameterURLString) else {
            print("invalid URL for thermal lift parameters")
            completion() // Call completion even on error
            return
        }
        URLSession.shared.dataTask(with: liftParameterURL) { [weak self] data, response, error in
            if let data = data {
                let decoder = JSONDecoder()
                if let decodedResponse = try? decoder.decode(LiftParametersResponse.self, from: data) {
                    DispatchQueue.main.async {
                        for row in decodedResponse.values.dropFirst() {
                            guard row.count >= 2 else {
                                print("Skipping malformed row (not enough columns): \(row)")
                                continue
                            }
                            guard let value = Double(row[1]) else {
                                print("Skipping row with non-numeric value: \(row)")
                                continue
                            }
                            switch row[0] {
                            case "thermalLapseRate":
                                liftParameters.thermalLapseRate = value
                            case "thermalVelocityConstant":
                                liftParameters.thermalVelocityConstant = value
                            case "initialTriggerTempDiff":
                                liftParameters.initialTriggerTempDiff = value
                            case "ongoingTriggerTempDiff":
                                liftParameters.ongoingTriggerTempDiff = value
                            case "thermalRampDistance":
                                liftParameters.thermalRampDistance = value
                            case "thermalRampStartPct":
                                liftParameters.thermalRampStartPct = value
                            case "cloudbaseLapseRatesDiff":
                                liftParameters.cloudbaseLapseRatesDiff = value
                            case "thermalGliderSinkRate":
                                liftParameters.thermalGliderSinkRate = value
                            case "Parameter":
                                // skip heading row (should have been dropped above)
                                _ = value
                            default:
                                break
                            }
                        }
                        self?.liftParameters = liftParameters
                        completion() // Call completion after updating
                    }
                    return
                }
            }
            // If decoding fails or data is nil, still call completion
            DispatchQueue.main.async {
                completion()
            }
        }.resume()
    }
}
import SwiftUI
import Combine
import Charts

struct SiteDetailView: View {
    var site: Site              // Received from parent view
    var favoriteName: String?   // Override display name if site detail is for a user favorite
    
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    @StateObject var viewModel = StationReadingsHistoryDataModel()
    
    @Environment(\.presentationMode) var presentationMode
    @Environment(\.scenePhase) private var scenePhase
    @Environment(\.openURL) var openURL     // Used to open URL links as an in-app sheet using Safari
    @State private var externalURL: URL?    // Used to open URL links as an in-app sheet using Safari
    @State private var showWebView = false  // Used to open URL links as an in-app sheet using Safari
    @State private var isActive = false
    @State private var historyIsLoading = true
    @State private var isFavorite: Bool = false
        
    var body: some View {
        let displayName = favoriteName ?? site.siteName
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                    }
                }
                Spacer()
                    Text(displayName)
                    .foregroundColor(sectionHeaderColor)
                    .bold()
                Button(action: {
                    if !isFavorite {
                        do {
                            let favoriteType = getFavoriteType(siteType: site.siteType)
                            let favoriteName = favoriteType == "station" ? site.siteName.capitalized : site.siteName
                            try userSettingsViewModel.addFavorite(
                                favoriteType:   favoriteType,
                                favoriteID:     site.siteName,
                                favoriteName:   favoriteName,
                                readingsSource: site.readingsSource,
                                stationID:      site.readingsStation,
                                readingsAlt:    site.readingsAlt,
                                siteLat:        site.siteLat,
                                siteLon:        site.siteLon,
                            )
                        } catch {
                            print("Failed to add favorite: \(error.localizedDescription)")
                        }
                    } else {
                        do {
                            try userSettingsViewModel.removeFavorite(
                                favoriteType: getFavoriteType(siteType: site.siteType),
                                favoriteID: site.siteName
                            )
                        } catch {
                            print("Failed to remove favorite: \(error.localizedDescription)")
                        }
                    }
                }) {
                    Image(systemName: isFavorite ? "star.fill" : "star")
                        .font(.title3)
                        .foregroundColor(isFavorite ? .yellow : .gray)
                }
            }
            .padding()
            .background(toolbarBackgroundColor)
            
            List {
                
                Section(header: Text("Wind Readings")
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    VStack {
                        VStack (alignment: .leading) {
                            Text(buildReferenceNote(Alt: site.readingsAlt, Note: site.readingsNote))
                                .font(.footnote)
                                .foregroundColor(infoFontColor)
                            if historyIsLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.75)
                                    .frame(width: 20, height: 20)
                            } else if let errorMessage = viewModel.readingsHistoryData.errorMessage {
                                Text("Error message:")
                                    .padding(.top, 8)
                                Text(errorMessage)
                            } else if viewModel.readingsHistoryData.times.isEmpty {
                                Text("Station down")
                                    .padding(.top, 8)
                                    .font(.caption)
                                    .foregroundColor(infoFontColor)
                            } else {
                                ReadingsHistoryBarChartView(readingsHistoryData: viewModel.readingsHistoryData, siteType: site.siteType)
                            }
                        }
                        VStack (alignment: .center) {
                            switch site.readingsSource {
                            case "Mesonet":
                                Text("Tap for 2 day readings history")
                                    .font(.caption)
                                    .foregroundColor(infoFontColor)
                                    .padding(.top, 4)
                            case "CUASA":
                                Text("Tap for CUASA live readings site")
                                    .font(.caption)
                                    .foregroundColor(infoFontColor)
                                    .padding(.top, 4)
                            case "RMHPA":
                                Text("Tap for RMHPA live readings site")
                                    .font(.caption)
                                    .foregroundColor(infoFontColor)
                                    .padding(.top, 4)
                            default:
                                Text("Invalid readings source; no history available")
                                    .font(.caption)
                                    .foregroundColor(infoFontColor)
                                    .padding(.top, 4)
                            }
                        }
                    }
                    .contentShape(Rectangle()) // Makes entire area tappable
                    .onTapGesture {
                        switch site.readingsSource {
                        case "Mesonet":
                            let readingsLink = AppURLManager.shared.getAppURL(URLName: "mesonetHistoryReadingsLink") ?? "<Unknown Mesonet readings history URL>"
                            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: site.readingsStation)
                            if let url = URL(string: updatedReadingsLink) {
                                openLink(url)
                            }
                        case "CUASA":
                            let readingsLink = AppURLManager.shared.getAppURL(URLName: "CUASAHistoryReadingsLink") ?? "<Unknown CUASA readings history URL>"
                            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: site.readingsStation)
                            if let url = URL(string: updatedReadingsLink) {
                                openLink(url)
                            }
                        case "RMHPA":
                            // Allow for different links based on Ecowitt and Holfuy stations based on length of station name
                            let urlName: String = site.readingsStation.count < 10 ? "RMHPAHolfuyReadingsLink" : "RMHPAEcowittReadingsLink"
                            let readingsLink = AppURLManager.shared.getAppURL(URLName: urlName) ?? "<Unknown RMHPA readings history URL>"
                            let updatedReadingsLink = updateURL(url: readingsLink, parameter: "station", value: site.readingsStation)
                            if let url = URL(string: updatedReadingsLink) {
                                openLink(url)
                            }

                        default:
                            print ("Invalid readings source")
                        }
                    }
                }
                
                Section(header: Text("Daily Forecast")
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    SiteDailyForecastView (
                        weatherCodesViewModel: weatherCodesViewModel,
                        siteLat: site.siteLat,
                        siteLon: site.siteLon,
                        forecastNote: site.forecastNote,
                        siteName: site.siteName,
                        siteType: site.siteType )
                }
                
                Section(header: Text("Detailed Forecast")
                    .font(.subheadline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    SiteForecastView(
                        siteLat: site.siteLat,
                        siteLon: site.siteLon,
                        forecastNote: site.forecastNote,
                        siteName: site.siteName,
                        siteType: site.siteType,
                        siteWindDirection: site.windDirection
                    )
                    .environmentObject(SiteForecastViewModel(
                        liftParametersViewModel: liftParametersViewModel,
                        sunriseSunsetViewModel: sunriseSunsetViewModel,
                        weatherCodesViewModel: weatherCodesViewModel)
                    )
                }
                
                VStack(alignment: .leading) {
                    if site.readingsSource == "Mesonet" {
                        Text("Readings data aggregated by Synoptic")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                        Text("https://synopticdata.com")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                            .padding(.bottom, 8)
                    }
                    if site.readingsSource == "CUASA" {
                        Text("Readings data aggregated by CUASA")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                        Text("https://sierragliding.us/cuasa")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                            .padding(.bottom, 8)
                    }
                    Text("Forecast data provided by Open-meteo")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                    Text("https://open-meteo.com")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                        .padding(.bottom, 8)
                    Text("Station ID: \(site.readingsStation) from \(site.readingsSource) at \(site.readingsAlt) ft")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                }
                .listRowBackground(attributionSheetBackgroundColor)
            }
            Spacer() // Push the content to the top of the sheet
        }
        .onAppear {
            updateIsFavorite()
            viewModel.GetReadingsHistoryData(stationID: site.readingsStation, readingsSource: site.readingsSource)
            isActive = true
            historyIsLoading = true
            startTimer()
        }
        .onReceive(viewModel.$readingsHistoryData) { newData in
            historyIsLoading = false
        }
        .onDisappear {
            isActive = false
        }
        .onChange(of: scenePhase) { oldValue, newValue in
            if newValue == .active {
                viewModel.GetReadingsHistoryData(stationID: site.readingsStation, readingsSource: site.readingsSource)
            } else {
                isActive = false
            }
        }
        .onChange(of: userSettingsViewModel.userFavoriteSites) {
            updateIsFavorite()
        }
        .sheet(isPresented: $showWebView) { if let url = externalURL { SafariView(url: url) } }
    }

    // Used to open URL links as an in-app sheet using Safari
    func openLink(_ url: URL) { externalURL = url; showWebView = true }
    
    // Reload readings data when page is active for a time interval
    private func startTimer() {
        DispatchQueue.main.asyncAfter(deadline: .now() + readingsRefreshInterval) {
            if isActive {
                viewModel.GetReadingsHistoryData(stationID: site.readingsStation, readingsSource: site.readingsSource)
                startTimer() // Continue the timer loop
            }
        }
    }
    
    // Check if site is in favorites
    private func updateIsFavorite() {
        isFavorite = userSettingsViewModel.userFavoriteSites.contains {
            $0.favoriteType == getFavoriteType(siteType: site.siteType) &&
            $0.favoriteID == site.siteName
        }
    }
    
    private func getFavoriteType (siteType: String) -> String {
        var favoriteType: String = "site"
        if siteType == "station" {
            favoriteType = "station"
        }
        return favoriteType
    }

}

struct ReadingsHistoryBarChartView: View {
    var readingsHistoryData: ReadingsHistoryData
    var siteType: String

    var body: some View {
        let count = min(readingsHistoryData.times.count, 10)
        let dataRange = (readingsHistoryData.times.count - count)..<readingsHistoryData.times.count
        
        Chart {
            ForEach(dataRange, id: \.self) { index in
                let windSpeed = readingsHistoryData.windSpeed[index].rounded()
                let windGust = readingsHistoryData.windGust[index]?.rounded() ?? 0.0
                let windDirection = readingsHistoryData.windDirection[index]
                let time = readingsHistoryData.times[index]
                let windColor = windSpeedColor(windSpeed: Int(windSpeed.rounded()), siteType: siteType)
                let gustColor = windSpeedColor(windSpeed: Int(windGust.rounded()), siteType: siteType)
                
                BarMark(
                    x: .value("Time", time),
                    yStart: .value("Wind Speed", 0),
                    yEnd: .value("Wind Speed", windSpeed)
                )
                .foregroundStyle(windColor)
                .annotation(position: .bottom) {
                    VStack {
                        Text("\(Int(windSpeed))")
                            .font(.caption)
                            .foregroundColor(windColor)
                            .bold()
                        Image(systemName: windArrow)
                            .rotationEffect(.degrees(Double(windDirection + 180)))
                            .bold()
                            .font(.footnote)
                        // Replace x-axis values with hh:mm and strip the am/pm
                        Text(String(time).split(separator: " ", maxSplits: 1).first ?? "")
                            .font(.caption)
                    }
                }
                if windGust > 0 {
                    BarMark(
                        x: .value("Time", time),
                        yStart: .value("Wind Speed", windSpeed + 1), // Create a gap
                        yEnd: .value("Wind Gust", windSpeed + windGust + 1)
                    )
                    .foregroundStyle(gustColor)
                    .annotation(position: .top) {
                        HStack(spacing: 4) {
                            Text("g")
                                .font(.caption)
                            Text("\(Int(windGust))")
                                .font(.caption)
                                .foregroundColor(gustColor)
                                .bold()
                        }
                    }
                }
            }
        }
        .chartYAxis(.hidden) // Remove the y-axis values
        .chartXAxis(.hidden)
        .chartXAxis { AxisMarks(stroke: StrokeStyle(lineWidth: 0)) }  // Hide vertical column separators
        .frame(height: 90) // Reduce the chart height
    }
}
import SwiftUI
import Combine

struct SiteSelection: Identifiable, Equatable {
    var id = UUID()
    var site: Site
    var favoriteName: String
}

struct SiteView: View {
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    
    @Environment(\.scenePhase) private var scenePhase
    @State private var selectedSite: SiteSelection?
    @State private var isActive = false
    @State private var isEditingFavorites = false
    @State private var editableFavorites: [UserFavoriteSite] = []
    
    private var favoriteSites: [UserFavoriteSite] {
        userSettingsViewModel.userFavoriteSites
            .filter { $0.appRegion == RegionManager.shared.activeAppRegion }
            .sorted { $0.sortSequence < $1.sortSequence }
    }
    
    var body: some View {
        VStack {
            Text("Tap on a site for readings history and forecast")
                .font(.caption)
                .foregroundColor(infoFontColor)
                .padding(.top, 8)
            
            List {
                // Show any favorites first
                if !editableFavorites.isEmpty || isEditingFavorites {
                    FavoritesSection(
                        favorites: $editableFavorites,
                        isEditingFavorites: $isEditingFavorites,
                        siteViewModel: siteViewModel,
                        onSelect: openSiteDetail
                    )
                }
                
                // Show standard sites
                let groupedSites = Dictionary(grouping: siteViewModel.sites) { $0.area }
                let sortedGroupedSites: [(String, [Site])] = siteViewModel.areaOrder.compactMap { areaName in
                    guard let sitesInArea = groupedSites[areaName] else { return nil }
                    return (areaName, sitesInArea)
                }
                ForEach(sortedGroupedSites, id: \.0) { pair in
                    let area = pair.0
                    let areaSites = pair.1

                    Section(header:
                        Text(area)
                            .font(.subheadline)
                            .foregroundColor(sectionHeaderColor)
                            .bold()
                    ) {
                        ForEach(areaSites) { site in
                            SiteRow(site: site, onSelect: openSiteDetail)
                        }
                    }
                }
                VStack (alignment: .leading) {
                    Text("Readings data aggregated by Synoptic")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                    Text("https://synopticdata.com")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                }
                .listRowBackground(attributionBackgroundColor)
            }
            .environment(\.editMode, .constant(isEditingFavorites ? .active : .inactive))
        }
        
        .onAppear {
            isActive = true
            editableFavorites = favoriteSites
            startTimer()
            guard !siteViewModel.sites.isEmpty else { return }
            stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: true) {}
        }
        
        .onDisappear {
            isActive = false
            
            // Save reordered favorites back to user settings
            persistFavoriteReordering()
        }
        
        .sheet(
            item: $selectedSite,
            onDismiss: {
                guard !siteViewModel.sites.isEmpty else { return }
                // Skipping getLatestReadingsData - sites not yet loaded
                stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: true) {}
            }
        ) { selection in
            SiteDetailView(site: selection.site, favoriteName: selection.favoriteName)
                .environmentObject(SiteForecastViewModel(
                    liftParametersViewModel: liftParametersViewModel,
                    sunriseSunsetViewModel: sunriseSunsetViewModel,
                    weatherCodesViewModel: weatherCodesViewModel)
                )
        }
        
        .onChange(of: scenePhase) { oldValue, newValue in
            if newValue == .active {
                isActive = true
                startTimer()
                guard !siteViewModel.sites.isEmpty else {
                    // Skipping getLatestReadingsData - sites not yet loaded
                    return
                }
                stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: true) {}
            } else {
                isActive = false
            }
            
        }
        
        .onChange(of: isEditingFavorites) { _, newValue in
            if newValue == false {
                persistFavoriteReordering()
            }
        }
        
        // Get external changes (e.g., adding/removing favorites from site detail sheet)
        .onChange(of: userSettingsViewModel.userFavoriteSites) { oldValue, newValue in
            editableFavorites = favoriteSites
        }
        
        .onChange(of: RegionManager.shared.activeAppRegion) { _, _ in
            editableFavorites = favoriteSites
        }
    }
    
    private func persistFavoriteReordering() {
        let currentRegion = RegionManager.shared.activeAppRegion
        var updatedFavorites = userSettingsViewModel.userFavoriteSites.filter { $0.appRegion != currentRegion }
        updatedFavorites.append(contentsOf: editableFavorites)
        userSettingsViewModel.userFavoriteSites = updatedFavorites
        userSettingsViewModel.saveToStorage()
    }
    
    private func openSiteDetail(_ site: Site) {
        let matchedFavorite = editableFavorites.first {
            ($0.favoriteType == "site" && $0.favoriteID == site.siteName) ||
            ($0.favoriteType == "station" && $0.stationID == site.readingsStation)
        }

        let favoriteName = matchedFavorite?.favoriteName ?? site.siteName
        selectedSite = SiteSelection(site: site, favoriteName: favoriteName)
    }
    
    private func startTimer() {
        DispatchQueue.main.asyncAfter(deadline: .now() + readingsRefreshInterval) {
            if isActive {
                startTimer()
                guard !siteViewModel.sites.isEmpty else {
                    // Skipping getLatestReadingsData - sites not yet loaded
                    return
                }
                stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: true) {}
            }
        }
    }
}

struct FavoritesSection: View {
    @Binding var favorites: [UserFavoriteSite]
    @Binding var isEditingFavorites: Bool
    @State private var renamingFavoriteID: String?

    let siteViewModel: SiteViewModel
    let onSelect: (Site) -> Void

    var body: some View {
        Section(
            header:
                HStack {
                    Text("Favorites")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold()
                    Spacer()
                    Button {
                        isEditingFavorites.toggle()
                    } label: {
                        if isEditingFavorites {
                            Image(systemName: checkmarkImage)
                                .imageScale(.medium)
                                .foregroundStyle(toolbarActiveImageColor)
                        } else {
                            Image(systemName: sortImage)
                                .imageScale(.medium)
                                .foregroundStyle(toolbarImageColor)
                        }
                    }
                    .buttonStyle(BorderlessButtonStyle())
                }
        ) {
            ForEach(favorites, id: \.id) { favorite in
                let binding = bindingForFavorite(favorite)
                if let (site, displayName) = siteFromFavorite(favorite) {
                    FavoriteRow(
                        favorite: binding,
                        site: site,
                        displayName: displayName,
                        onSelect: onSelect,
                        renamingFavoriteID: $renamingFavoriteID,
                        myID: favorite.id
                    )
                } else {
                    EmptyView()
                }
            }
            .onMove { from, to in
                withTransaction(Transaction(animation: nil)) {
                    moveFavorite(from: from, to: to)
                }
            }
        }
    }

    private func siteFromFavorite(_ fav: UserFavoriteSite) -> (Site, String)? {
        let display = fav.favoriteName.isEmpty ? fav.favoriteID : fav.favoriteName
        switch fav.favoriteType {
        case "site":
            if let match = siteViewModel.sites.first(where: { $0.siteName == fav.favoriteID }) {
                return (match, display)
            }
        case "station":
            let windDirection = SiteWindDirection( N:  "", NE: "", E:  "", SE: "", S:  "", SW: "", W:  "", NW: "" )
            
            return (Site(
                area:               "Favorites",
                siteName:           fav.favoriteID,
                readingsNote:       "",
                forecastNote:       "",
                siteType:           "station",
                readingsAlt:        fav.readingsAlt,
                readingsSource:     fav.readingsSource,
                readingsStation:    fav.stationID,
                pressureZoneReadingTime: "",
                siteLat:            fav.siteLat,
                siteLon:            fav.siteLon,
                sheetRow:           0,
                windDirection:      windDirection
            ), display)
        default:
            return nil
        }
        return nil
    }

    private func bindingForFavorite(_ favorite: UserFavoriteSite) -> Binding<UserFavoriteSite> {
        guard let idx = favorites.firstIndex(where: { $0.id == favorite.id }) else {
            fatalError("Favorite not found")
        }
        return $favorites[idx]
    }

    private func moveFavorite(from source: IndexSet, to destination: Int) {
        // 1. Reorder the array in-place:
        favorites.move(fromOffsets: source, toOffset: destination)
        
        // 2. Update sortSequence to match the new order:
        for (newIndex, _) in favorites.enumerated() {
            favorites[newIndex].sortSequence = newIndex
        }
    }
}

struct SiteRow: View {
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    var site: Site
    var displayName: String? = nil
    var onSelect: (Site) -> Void

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Text(displayName ?? site.siteName) // Use (favorite) display name if present
                    .font(.subheadline)
                    .foregroundColor(rowHeaderColor)
                if site.readingsAlt != "" {
                    Text(formatAltitude(site.readingsAlt))
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                        .lineLimit(1)
                        .fixedSize(horizontal: true, vertical: false)
                }
                Spacer()
                
                if stationLatestReadingViewModel.isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.75)
                        .frame(width: 20, height: 20)
                }
                else if let latestReading = stationLatestReadingViewModel.latestSiteReadings.first (where: { $0.stationID == site.readingsStation }) {
                    if let windTime = latestReading.windTime {
                        // Split keeps hh:mm and strips the trailing "  %p" the JSON parser is creating
                        let windTimeParts = windTime.split(separator: " ", maxSplits: 1)
                        let windTimeText = windTimeParts.first.map(String.init) ?? windTime
                        Text(windTimeText)
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                            .lineLimit(1)
                            .fixedSize(horizontal: true, vertical: false)
                    }
                    
                    if let windSpeed = latestReading.windSpeed {
                        if windSpeed == 0 {
                            Text("calm")
                                .font(.subheadline)
                                .lineLimit(1)
                                .fixedSize(horizontal: true, vertical: false)
                        } else {
                            Text(String(Int(windSpeed.rounded())))
                                .font(.subheadline)
                                .foregroundColor(windSpeedColor(windSpeed: Int(windSpeed.rounded()), siteType: site.siteType))
                                .lineLimit(1)
                                .fixedSize(horizontal: true, vertical: false)
                        }
                    } else {
                        Text ("Station down")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                            .lineLimit(1)
                            .fixedSize(horizontal: true, vertical: false)
                    }
                    
                    if let windGust = latestReading.windGust {
                        if windGust > 0 {
                            HStack {
                                Text("g")
                                    .font(.subheadline)
                                    .foregroundColor(infoFontColor)
                                    .lineLimit(1)
                                    .fixedSize(horizontal: true, vertical: false)
                                Text(String(Int(windGust.rounded())))
                                    .font(.subheadline)
                                    .foregroundColor(windSpeedColor(windSpeed: Int(windGust.rounded()), siteType: site.siteType))
                                    .lineLimit(1)
                                    .fixedSize(horizontal: true, vertical: false)
                            }
                        }
                    }
                    
                    if let windDirection = latestReading.windDirection {
                        Image(systemName: windArrow)
                            .rotationEffect(.degrees(windDirection - 180))
                            .font(.footnote)
                    }
                    
                } else {
                    Text ("Station down")
                        .font(.caption)
                        .foregroundColor(infoFontColor)
                        .lineLimit(1)
                        .fixedSize(horizontal: true, vertical: false)
                }
            }
            .contentShape(Rectangle()) // Makes entire area tappable
            .onTapGesture {
                onSelect(site)
            }
        }
    }
}

struct FavoriteRow: View {
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @Binding var favorite: UserFavoriteSite
    var site: Site?
    var displayName: String?
    var onSelect: (Site) -> Void

    @Binding var renamingFavoriteID: String?
    let myID: String

    @FocusState private var isTextFieldFocused: Bool
    private var isRenaming: Bool { renamingFavoriteID == myID }

    var body: some View {
        Group {
            if isRenaming {
                HStack {
                    TextField("Favorite Name", text: $favorite.favoriteName)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .font(.subheadline)
                        .focused($isTextFieldFocused)
                        .onSubmit { endRenaming() }
                    Spacer()
                }
                .padding(.vertical, 4)
            } else {
                if let site = site {
                    SiteRow(site: site, displayName: displayName, onSelect: onSelect)
                        .contextMenu {
                            Button("Rename") {
                                renamingFavoriteID = myID
                            }
                            .font(.caption)
                            .buttonStyle(BorderlessButtonStyle())
                        }
                        .onLongPressGesture {
                            renamingFavoriteID = myID
                        }
                } else {
                    EmptyView()
                }
            }
        }
        .onChange(of: isRenaming) {oldValue, newValue in
            if newValue {
                // small delay so the field is actually in the hierarchy
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                    isTextFieldFocused = true
                }
            }
        }
    }

    private func endRenaming() {
        favorite.favoriteName = favorite.favoriteName.trimmingCharacters(in: .whitespacesAndNewlines)
        if favorite.favoriteName.isEmpty {
            favorite.favoriteName = ""
        }
        userSettingsViewModel.saveToStorage()
        renamingFavoriteID = nil
    }

}

// Extension to rename a Site without mutating the original
private extension Site {
    func renamed(to newName: String) -> Site {
        var copy = self
        copy.siteName = newName
        return copy
    }
}
import SwiftUI
import MapKit

// Allows initial select of global variable appRegion on app load
// (appRegion can also be changed in AboutView).

struct AppRegionView: View {
    @EnvironmentObject var appRegionViewModel: AppRegionViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack {
                
                Text("Cloudbase")
                    .bold()
                    .foregroundColor(titleFontColor)
                    .padding()

                List {
                    Section(header: Text("Select a region")
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        ForEach(appRegionViewModel.appRegions.filter {
                            $0.appRegionStatus.isEmpty
                        }, id: \.appRegion) { region in
                            Button(action: {
                                RegionManager.shared.activeAppRegion = region.appRegion
                                userSettingsViewModel.mapRegion = MKCoordinateRegion(
                                    center: CLLocationCoordinate2D(
                                        latitude: region.mapInitLatitude,
                                        longitude: region.mapInitLongitude
                                    ),
                                    span: MKCoordinateSpan(
                                        latitudeDelta: region.mapInitLatitudeSpan,
                                        longitudeDelta: region.mapInitLongitudeSpan
                                    )
                                )
                                userSettingsViewModel.zoomLevel = region.mapDefaultZoomLevel
                                userSettingsViewModel.saveToStorage()
                                dismiss()
                            }) {
                                HStack {
                                    Text(region.appRegionName)
                                        .font(.subheadline)
                                        .foregroundColor(toolbarActiveFontColor)
                                    Spacer()
                                    if RegionManager.shared.activeAppRegion == region.appRegion {
                                        Image(systemName: "checkmark")
                                            .font(.subheadline)
                                            .foregroundColor(toolbarActiveImageColor)
                                    }
                                }
                            }
                            .contentShape(Rectangle())
                        }
                        
                    }
                }
            }
        }
    }
}
import SwiftUI
import Combine
import Charts

// For top of lift area chart
struct TopOfLiftDataPoint: Identifiable {
    var id = UUID()
    var index: Int
    var altitude: Double
}

// Simplify view creation for thermal forecast
struct ThermalCell: View {
    let value: Double
    let text: String
    let newDateFlag: Bool
    
    let dataWidth: CGFloat
    let dataHeight: CGFloat
    let dividerWidth: CGFloat
    let dividerColor: Color
    
    var body: some View {
        Text(text)
            .font(.caption)
            .foregroundStyle(thermalColor(value))
            .frame(width: dataWidth)
            .overlay(
                Divider()
                    .frame(width: dividerWidth, height: dataHeight)
                    .background(dividerColor),
                alignment: .leading
            )
    }
}

struct SiteForecastView: View {
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    
    let siteLat:            String
    let siteLon:            String
    let forecastNote:       String
    let siteName:           String
    let siteType:           String
    let siteWindDirection:  SiteWindDirection

    var body: some View {
        VStack (alignment: .leading) {
            if let forecastData = siteForecastViewModel.forecastData {
                VStack(alignment: .leading) {
                    let topOfChartAltitude = 18000.0
                    let surfaceAltitude = convertMetersToFeet(forecastData.elevation)
                    Text(buildReferenceNote(Alt: String(surfaceAltitude), Note: forecastNote))
                        .font(.footnote)
                        .foregroundColor(infoFontColor)
                        .padding(.bottom, 5)
                    
                    let maxPressureReading = siteForecastViewModel.maxPressureReading
                    let dataWidth: CGFloat = 44                                     // Width for each data column
                    let dataRows: Int = forecastData.hourly.dateTime?.count ?? 0    // Total count of data rows returned
                    let dataFrameWidth: CGFloat = CGFloat(dataRows) * (dataWidth)   // Width for all data tables and charts

                    // Create separate grids for each section to enable area graphs to overlay a section
                    let weatherGridItems: [GridItem] = {
                        var weatherItems = Array(repeating: GridItem(.fixed(headingHeight), spacing: 0), count: 1)     // Day
                        weatherItems += Array(repeating: GridItem(.fixed(headingHeight), spacing: 0), count: 1)        // Date
                        weatherItems += Array(repeating: GridItem(.fixed(headingHeight), spacing: 0), count: 1)        // Time
                        weatherItems += Array(repeating: GridItem(.fixed(imageHeight), spacing: 0), count: 1)          // Skies
                        weatherItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)           // ToL Temp
                        weatherItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)           // Surf Temp
                        weatherItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)           // Cloud %
                        weatherItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)           // Precip %
                        weatherItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)           // CAPE
                        weatherItems += Array(repeating: GridItem(.fixed(labelHeight), spacing: 0), count: 1)          // Wind label
                        return weatherItems
                    } ()
                    let windGridItems: [GridItem] = {
                        var windItems = [] as [GridItem]
                        if maxPressureReading >= 500 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 550 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 600 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 650 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 700 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 750 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 800 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 850 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        if maxPressureReading >= 900 { windItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1) }
                        return windItems
                    } ()
                    let surfaceGridItems: [GridItem] = {
                        var surfaceItems = Array(repeating: GridItem(.fixed(doubleHeight), spacing: 0), count: 1)   // Surface wind
                        surfaceItems += Array(repeating: GridItem(.fixed(labelHeight), spacing: 0), count: 1)       // Thermal label
                        surfaceItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)        // Top of lift
                        return surfaceItems
                    } ()
                    let thermalGridItems: [GridItem] = {
                        var thermalItems: [GridItem] = []
                        if maxPressureReading >= 500 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 550 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 600 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 650 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 700 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 750 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 800 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 850 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        if maxPressureReading >= 900 {
                            thermalItems += Array(repeating: GridItem(.fixed(dataHeight), spacing: 0), count: 1)
                            areaChartHeight += dataHeight + areaChartPaddingHeight
                        }
                        return thermalItems
                    } ()
                    HStack(alignment: .top) {
                        VStack (spacing: 0) {
                            // Create header column from grid sections
                            LazyHGrid(rows: weatherGridItems) {
                                Group {
                                    Text(" ")
                                        .font(.caption)
                                        .padding(.top, 8)
                                    Text(" ")
                                        .font(.caption)
                                        .padding(.top, 4)
                                    Text(" ")
                                        .font(.caption)
                                    Text(" ")
                                        .font(.caption)
                                    Text("ToL Temp")
                                        .font(.caption)
                                    Text("Surf Temp")
                                        .font(.caption)
                                    Text("Cloud %")
                                        .font(.caption)
                                    Text("Precip %")
                                        .font(.caption)
                                    Text("CAPE")
                                        .font(.caption)
                                    Text("Wind")
                                        .font(.caption)
                                        .foregroundColor(infoFontColor)
                                }
                            }
                            LazyHGrid(rows: windGridItems) {
                                Group {
                                    if maxPressureReading >= 500 { Text("\(Int(forecastData.hourly.geopotential_height_500hPa.first ?? 500))k ft").font(.caption) }
                                    if maxPressureReading >= 550 { Text("\(Int(forecastData.hourly.geopotential_height_550hPa.first ?? 550))k ft").font(.caption) }
                                    if maxPressureReading >= 600 { Text("\(Int(forecastData.hourly.geopotential_height_600hPa.first ?? 600))k ft").font(.caption) }
                                    if maxPressureReading >= 650 { Text("\(Int(forecastData.hourly.geopotential_height_650hPa.first ?? 650))k ft").font(.caption) }
                                    if maxPressureReading >= 700 { Text("\(Int(forecastData.hourly.geopotential_height_700hPa.first ?? 700))k ft").font(.caption) }
                                    if maxPressureReading >= 750 { Text("\(Int(forecastData.hourly.geopotential_height_750hPa.first ?? 750))k ft").font(.caption) }
                                    if maxPressureReading >= 800 { Text("\(Int(forecastData.hourly.geopotential_height_800hPa.first ?? 800))k ft").font(.caption) }
                                    if maxPressureReading >= 850 { Text("\(Int(forecastData.hourly.geopotential_height_850hPa.first ?? 850))k ft").font(.caption) }
                                    if maxPressureReading >= 900 { Text("\(Int(forecastData.hourly.geopotential_height_900hPa.first ?? 900))k ft").font(.caption) }
                                }
                            }
                            LazyHGrid(rows: surfaceGridItems) {
                                Group {
                                    Text("Surface")
                                        .font(.caption)
                                    Text("Lift")
                                        .font(.caption)
                                        .foregroundColor(infoFontColor)
                                    Text("Top of Lift")
                                        .font(.caption)
                                }
                            }
                            LazyHGrid(rows: thermalGridItems) {
                                Group {
                                    if maxPressureReading >= 500 { Text("\(Int(forecastData.hourly.geopotential_height_500hPa.first ?? 500))k ft").font(.caption) }
                                    if maxPressureReading >= 550 { Text("\(Int(forecastData.hourly.geopotential_height_550hPa.first ?? 550))k ft").font(.caption) }
                                    if maxPressureReading >= 600 { Text("\(Int(forecastData.hourly.geopotential_height_600hPa.first ?? 600))k ft").font(.caption) }
                                    if maxPressureReading >= 650 { Text("\(Int(forecastData.hourly.geopotential_height_650hPa.first ?? 650))k ft").font(.caption) }
                                    if maxPressureReading >= 700 { Text("\(Int(forecastData.hourly.geopotential_height_700hPa.first ?? 700))k ft").font(.caption) }
                                    if maxPressureReading >= 750 { Text("\(Int(forecastData.hourly.geopotential_height_750hPa.first ?? 750))k ft").font(.caption) }
                                    if maxPressureReading >= 800 { Text("\(Int(forecastData.hourly.geopotential_height_800hPa.first ?? 800))k ft").font(.caption) }
                                    if maxPressureReading >= 850 { Text("\(Int(forecastData.hourly.geopotential_height_850hPa.first ?? 850))k ft").font(.caption) }
                                    if maxPressureReading >= 900 { Text("\(Int(forecastData.hourly.geopotential_height_900hPa.first ?? 900))k ft").font(.caption) }
                                }
                            }
                        }
                        .padding(.vertical, 0)
                        ScrollView(.horizontal) {
                            VStack (spacing: 0) {

                                // Header and weather rows
                                LazyHGrid(rows: weatherGridItems, spacing: 0) {
                                    ForEach(forecastData.hourly.dateTime?.indices ?? 0..<0, id: \.self) { index in
                                        Group {
                                            if forecastData.hourly.newDateFlag?[index] ?? true {
                                                Text(forecastData.hourly.formattedDay?[index] ?? "")
                                                    .font(.caption)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 8)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: headingHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                                Text(forecastData.hourly.formattedDate?[index] ?? "")
                                                    .font(.caption)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 4)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: headingHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            } else {
                                                Text(forecastData.hourly.formattedDay?[index] ?? "")
                                                    .font(.caption)
                                                    .foregroundColor(repeatDateTimeColor)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 8)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: headingHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                                Text(forecastData.hourly.formattedDate?[index] ?? "")
                                                    .font(.caption)
                                                    .foregroundColor(repeatDateTimeColor)
                                                    .frame(width: dataWidth)
                                                    .padding(.top, 4)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: headingHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            Text(forecastData.hourly.formattedTime?[index] ?? "")
                                                .font(.caption)
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: headingHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Image(systemName: forecastData.hourly.weatherCodeImage?[index] ?? "questionmark")
                                                .renderingMode(.original) // Use .multicolor for multicolor rendering
                                                .resizable()
                                                .scaledToFit()
                                                .frame(width: dataWidth * imageScalingFactor, height: imageHeight)
                                                // Display divider when date changes
                                                .frame(width: dataWidth)
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: imageHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(forecastData.hourly.formattedTopOfLiftTemp?[index] ?? "") //formattedTopOfLiftTemperature?[index] ?? "")
                                                    .font(.caption)
                                                    .foregroundStyle(tempColor(Int(forecastData.hourly.topOfLiftTemp?[index] ?? -999)))
                                                    .frame(width: dataWidth)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(forecastData.hourly.formattedSurfaceTemp?[index] ?? "")
                                                .font(.caption)
                                                .foregroundStyle(tempColor(Int(forecastData.hourly.temperature_2m[index])))
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(forecastData.hourly.formattedCloudCover?[index] ?? "")
                                                .font(.caption)
                                                .foregroundStyle(cloudCoverColor(Int(forecastData.hourly.cloudcover[index])))
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(forecastData.hourly.formattedPrecipProbability?[index] ?? "")
                                                .font(.caption)
                                                .foregroundStyle(precipColor(Int(forecastData.hourly.precipitation_probability[index])))
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(forecastData.hourly.formattedCAPE?[index] ?? "")
                                                .font(.caption)
                                                .foregroundStyle(CAPEColor(Int(forecastData.hourly.cape[index])))
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(" ")
                                                .font(.caption)
                                                .frame(width: dataWidth)
                                                .overlay(
                                                    Rectangle()
                                                        .frame(height: 1)
                                                        .foregroundColor(tableSectionDividerColor),
                                                    alignment: .center)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                        }
                                    }
                                }
                                .frame(width: dataFrameWidth)
                                .background(tableBackgroundColor)

                                // Winds aloft forecast table
                                LazyHGrid(rows: windGridItems, spacing: 0) {
                                    ForEach(forecastData.hourly.dateTime?.indices ?? 0..<0, id: \.self) { index in
                                        Group {
                                            if maxPressureReading >= 500 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_500hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_500hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_500hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 550 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_550hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_550hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_550hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 600 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_600hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_600hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_600hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 650 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_650hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_650hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_650hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 700 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_700hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_700hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_700hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 750 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_750hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_750hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_750hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 800 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_800hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_800hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_800hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 850 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_850hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_850hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_850hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                            if maxPressureReading >= 900 {
                                                HStack (spacing: windArrowSpacing) {
                                                    Text("\(Int(forecastData.hourly.windspeed_900hPa[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_900hPa[index]), siteType: siteType))
                                                    Image(systemName: windArrow)
                                                        .rotationEffect(.degrees(forecastData.hourly.winddirection_900hPa[index] - 180))
                                                        .font(.footnote)
                                                }
                                                .frame(width: dataWidth)
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                        }
                                    }
                                }
                                .background(
                                    areaChartBackground(forecastData: forecastData, surfaceAltitude: surfaceAltitude, topOfChartAltitude: topOfChartAltitude)
                                        .opacity(areaChartOpacity)
                                )
                                .background(tableBackgroundColor)

                                // Surface wind and Top of Lift forecast table
                                LazyHGrid(rows: surfaceGridItems, spacing: 0) {
                                    ForEach(forecastData.hourly.dateTime?.indices ?? 0..<0, id: \.self) { index in
                                        Group {
                                            HStack(spacing: windArrowSpacing) {
                                                VStack(alignment: .trailing, spacing: 1) {
                                                    Text("\(Int(forecastData.hourly.windspeed_10m[index]))")
                                                        .font(.caption)
                                                        .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windspeed_10m[index]), siteType: siteType))
                                                    HStack (spacing: 1) {
                                                        Text("g")
                                                            .font(.caption2)
                                                        Text("\(Int(forecastData.hourly.windgusts_10m[index]))")
                                                            .font(.caption)
                                                            .foregroundStyle(windSpeedColor(windSpeed: Int(forecastData.hourly.windgusts_10m[index]), siteType: siteType))
                                                    }                                                    
                                                }
                                                .padding(.vertical, 0)
                                                Image(systemName: windArrow)
                                                    .rotationEffect(.degrees(forecastData.hourly.winddirection_10m[index] - 180))
                                                    .font(.footnote)
                                            }
                                            .padding(.vertical, 0)
                                            .frame(width: dataWidth)
                                            // Display divider when date changes
                                            .overlay ( Divider() .frame(width: dateChangeDividerSize, height: doubleHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            Text(" ")
                                                .font(.caption)
                                                .frame(width: dataWidth)
                                                .overlay(
                                                    Rectangle()
                                                        .frame(height: 1)
                                                        .foregroundColor(tableSectionDividerColor),
                                                    alignment: .center )
                                                // Display divider when date changes
                                                .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            if forecastData.hourly.formattedTopOfLiftAltitude?[index] ?? "" == "rocket" {
                                                Image("rocket")
                                                    .renderingMode(.original) // Use .multicolor for multicolor rendering
                                                    .resizable()
                                                    .scaledToFit()
                                                    .frame(width: dataWidth) // * imageScalingFactor)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            } else {
                                                Text(forecastData.hourly.formattedTopOfLiftAltitude?[index] ?? "")
                                                    .font(.caption)
                                                    .frame(width: dataWidth)
                                                    // Display divider when date changes
                                                    .overlay ( Divider() .frame(width: dateChangeDividerSize, height: dataHeight) .background(getDividerColor(forecastData.hourly.newDateFlag?[index] ?? true)), alignment: .leading )
                                            }
                                        }
                                    }
                                }
                                .frame(width: dataFrameWidth)
                                .background(tableBackgroundColor)

                                // Thermal lift table
                                LazyHGrid(rows: thermalGridItems, spacing: 0) {
                                    ForEach(forecastData.hourly.dateTime?.indices ?? 0..<0, id: \.self) { index in
                                        Group {
                                            if maxPressureReading >= 500 {
                                                let value = forecastData.hourly.thermalVelocity_500hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 550 {
                                                let value = forecastData.hourly.thermalVelocity_550hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 600 {
                                                let value = forecastData.hourly.thermalVelocity_600hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 650 {
                                                let value = forecastData.hourly.thermalVelocity_650hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 700 {
                                                let value = forecastData.hourly.thermalVelocity_700hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 750 {
                                                let value = forecastData.hourly.thermalVelocity_750hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 800 {
                                                let value = forecastData.hourly.thermalVelocity_800hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 850 {
                                                let value = forecastData.hourly.thermalVelocity_850hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                            if maxPressureReading >= 900 {
                                                let value = forecastData.hourly.thermalVelocity_900hPa?[index] ?? 0
                                                let str = value == 0 ? "" : "\(value)"
                                                let flag = forecastData.hourly.newDateFlag?[index] ?? false
                                                ThermalCell(
                                                    value:          value,
                                                    text:           str,
                                                    newDateFlag:    flag,
                                                    dataWidth:      dataWidth,
                                                    dataHeight:     dataHeight,
                                                    dividerWidth:   dateChangeDividerSize,
                                                    dividerColor:   getDividerColor(flag)
                                                )
                                            }
                                        }
                                    }
                                }
                                .padding(.vertical, 0)
                                .frame(width: dataFrameWidth)
                                .background(
                                    areaChartBackground(forecastData: forecastData, surfaceAltitude: surfaceAltitude, topOfChartAltitude: topOfChartAltitude)
                                        .opacity(areaChartOpacity)
                                .background(tableBackgroundColor)       // Used to hide overrun from wind aloft background area table
                                )
                            }
                            .padding(.bottom, 8)
                            .backgroundStyle(tableBackgroundColor)
                            .cornerRadius(10)
                        }
                    }
                }
            }
        }
        .onAppear { siteForecastViewModel.fetchForecast(siteName:           siteName,
                                                        latitude:           siteLat,
                                                        longitude:          siteLon,
                                                        siteType:           siteType,
                                                        siteWindDirection:  siteWindDirection)
        }
    }
    
    @ViewBuilder
    func areaChartBackground(forecastData: ForecastData, surfaceAltitude: Int, topOfChartAltitude: Double) -> some View {
        if let dateTime = forecastData.hourly.dateTime, let topOfLiftAltitude = forecastData.hourly.topOfLiftAltitude {
            let data = zip(dateTime.indices, topOfLiftAltitude).map { TopOfLiftDataPoint(index: $0.0, altitude: $0.1) }
            Chart(data) { item in
                AreaMark(
                    x: .value("Index", item.index),
                    y: .value("Altitude", item.altitude)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(.linearGradient(colors: [chartGradientStartColor, chartGradientEndColor], startPoint: .bottom, endPoint: .top))
                LineMark(
                    x: .value("Index", item.index),
                    y: .value("Altitude", item.altitude)
                )
                .interpolationMethod(.catmullRom)
                .foregroundStyle(chartLineColor)

            }
            .chartYAxis(.hidden) // Remove the y-axis values
            .chartXAxis(.hidden)
            .chartXAxis { AxisMarks(stroke: StrokeStyle(lineWidth: 0)) }  // Hide vertical column separators
            .chartYAxis { AxisMarks(stroke: StrokeStyle(lineWidth: 0)) }  // Hide horizontal column separators
            .chartYScale(domain: (Double(surfaceAltitude) - 200)...topOfChartAltitude)
        } else {
            Text("No data available")
        }
    }

}
import SwiftUI
import MapKit
import Combine
import UIKit

struct RadarColorScheme: Identifiable {
    let id: Int
    let title: String
}

// This view uses temporary variables while the sheet is open, then publishes when the sheet is closed.
// This is done to prevent lag on this sheet each time a view item is changed.
struct MapSettingsView: View {
    @Binding var selectedMapType: CustomMapStyle
    @Binding var pilotTrackDays: Double
    @Binding var mapDisplayMode: MapDisplayMode
    @Binding var showSites: Bool
    @Binding var showStations: Bool
    @Binding var showRadar: Bool
    @Binding var showInfrared: Bool
    @Binding var radarColorScheme: Int
    @Binding var selectedPilots: [Pilot]
    
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @Environment(\.presentationMode) var presentationMode

    // Temporary state variables
    @State private var tempSelectedMapType: CustomMapStyle
    @State private var tempPilotTrackDays: Double
    @State private var tempMapDisplayMode: MapDisplayMode
    @State private var tempShowSites: Bool
    @State private var tempShowStations: Bool
    @State private var tempShowRadar: Bool
    @State private var tempShowInfrared: Bool
    @State private var tempRadarColorScheme: Int
    
    // Selected pilot list variables
    @State private var selectedPilotIDs: Set<UUID> = []
    @State private var showSelectionError = false
    @State private var didSeed = false

    // Trigger add pilot / active pilot sheets navigation
    @State private var addPilot = false
    @State private var pilotToActivate: Pilot?
    @State private var activatePilot = false

    init(selectedMapType:   Binding<CustomMapStyle>,
         pilotTrackDays:    Binding<Double>,
         mapDisplayMode:    Binding<MapDisplayMode>,
         showSites:         Binding<Bool>,
         showStations:      Binding<Bool>,
         showRadar:         Binding<Bool>,
         showInfrared:      Binding<Bool>,
         radarColorScheme:  Binding<Int>,
         selectedPilots:    Binding<[Pilot]>
    ) {
        _selectedMapType =  selectedMapType
        _pilotTrackDays =   pilotTrackDays
        _mapDisplayMode =   mapDisplayMode
        _showSites =        showSites
        _showStations =     showStations
        _showRadar =        showRadar
        _showInfrared =     showInfrared
        _radarColorScheme = radarColorScheme
        _selectedPilots =   selectedPilots
        
        // Initialize temporary states with current values
        _tempSelectedMapType =  State(initialValue: selectedMapType.wrappedValue)
        _tempPilotTrackDays =   State(initialValue: pilotTrackDays.wrappedValue)
        _tempMapDisplayMode =   State(initialValue: mapDisplayMode.wrappedValue)
        _tempShowSites =        State(initialValue: showSites.wrappedValue)
        _tempShowStations =     State(initialValue: showStations.wrappedValue)
        _tempShowRadar =        State(initialValue: showRadar.wrappedValue)
        _tempShowInfrared =     State(initialValue: showInfrared.wrappedValue)
        _tempRadarColorScheme = State(initialValue: radarColorScheme.wrappedValue)
    }
    
    // Rainviewer color schemes for radar overlay
    let radarColorSchemes: [RadarColorScheme] = [
//        .init(id: 0, title: "0 – BW Black and White: dBZ values"),
        .init(id: 1, title: "Original"),
        .init(id: 2, title: "Universal Blue"),
        .init(id: 3, title: "TITAN"),
        .init(id: 4, title: "Weather Channel"),
        .init(id: 5, title: "Meteored"),
        .init(id: 6, title: "NEXRAD Level III"),
        .init(id: 7, title: "Rainbow @ SELEX-IS"),
        .init(id: 8, title: "Dark Sky")
    ]
    
    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
// Commented out validation; causing an error if the region doesn't have any pilots available to select
                    // Validate at least one pilot is selected
//                    if selectedPilotIDs.isEmpty {
//                        showSelectionError = true
//                    } else {
                        presentationMode.wrappedValue.dismiss()
//                    }
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                    }
                }
                .padding()
                Spacer()
            }
            .background(Color.blue.opacity(0.2))
            .alert("Select at least one pilot", isPresented: $showSelectionError) {
                Button("OK", role: .cancel) { }
            }

            List {
                
                Section(header: Text("Map type")) {
                    Picker("Map Type", selection: $tempSelectedMapType) {
                        ForEach(CustomMapStyle.allCases, id: \.self) { style in
                            Text(style.rawValue.capitalized)
                        }
                    }
                    .pickerStyle(SegmentedPickerStyle())
                }

                if $tempMapDisplayMode.wrappedValue == .weather {
                    Section(header: Text("Display layers")) {
                        Toggle("Sites", isOn: $tempShowSites)
                        Toggle("Stations", isOn: $tempShowStations)
                        Toggle("Radar (precip)", isOn: $tempShowRadar)
                        Toggle("Satellite (clouds)", isOn: $tempShowInfrared)
                    }
                    
                    if tempShowRadar {
                        Section(header: Text("Radar Color Scheme")) {
                            Picker("Radar colors", selection: $tempRadarColorScheme) {
                                ForEach(radarColorSchemes) { radarColorScheme in
                                    Text(radarColorScheme.title)
                                        .tag(radarColorScheme.id)
                                }
                            }
                            .pickerStyle(.inline)
                        }
                    }

                }
                
                if $tempMapDisplayMode.wrappedValue == .tracking {
                    
                    Section(header: Text("Pilot track days")) {
                        HStack {
                            Text("Days:")
                                .frame(maxWidth: .infinity, alignment: .leading)
                            
                            Picker("Days", selection: $tempPilotTrackDays) {
                                ForEach(1...3, id: \.self) { day in
                                    Text("\(day)")
                                        .tag(Double(day))
                                }
                            }
                            .pickerStyle(SegmentedPickerStyle())
                            .disabled(pilotTrackViewModel.isLoading)              // block while loading
                            .opacity(pilotTrackViewModel.isLoading ? 0.5 : 1)     // grey‐out
                        }
                        .padding(.vertical, 8)
                        .onChange(of: tempPilotTrackDays) { oldDays, newDays in
                            // Build an array of the currently‐selected Pilot objects
                            let selected = pilotViewModel.pilots
                                .filter { selectedPilotIDs.contains($0.id) }
                            
                            // Fire off the reload
                            pilotTrackViewModel.getPilotTracks(
                                days: newDays,
                                selectedPilots: selected
                            ) {}
                        }
                        if pilotTrackViewModel.isLoading {
                            HStack(spacing: 8) {
                                Spacer()
                                Text("Updating pilot track data")
                                    .font(.subheadline)
                                    .foregroundStyle(loadingBarTextColor)

                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle())
                                    .scaleEffect(0.75)
                                    .padding(.horizontal, 8)
                                    // force a fresh ProgressView each time `isLoading` toggles:
                                    .id(UUID())
                            }
                            .padding(.vertical, 4)
                        }
                    }
                    
                    Section(header: Text("Pilots to display")) {
                        VStack(spacing: 12) {
                            // Add Pilot Button
                            HStack {
                                Spacer()
                                Button(action: {
                                    addPilot = true
                                }) {
                                    Text("Add Pilot")
                                        .foregroundColor(skewTButtonTextColor)
                                        .padding(8)
                                }
                                .frame(width: skewTButtonWidth)
                                .background(skewTButtonBackgroundColor)
                                .cornerRadius(8)
                                .buttonStyle(BorderlessButtonStyle())
                                Spacer()
                            }
                            Divider()

                            // All / None Buttons
                            HStack {
                                Button(action: {
                                    selectedPilotIDs = Set(pilotViewModel.pilots.map(\.id))
                                }) {
                                    Text("All")
                                        .frame(maxWidth: .infinity)
                                }
                                .buttonStyle(BorderlessButtonStyle())

                                Button(action: {
                                    selectedPilotIDs.removeAll()
                                }) {
                                    Text("None")
                                        .frame(maxWidth: .infinity)
                                }
                                .buttonStyle(BorderlessButtonStyle())
                            }

                            // Pilot checkboxes
                            ForEach(pilotViewModel.pilots.sorted { $0.pilotName.localizedCaseInsensitiveCompare($1.pilotName) == .orderedAscending }) { pilot in
                                
                                // determine if this pilot has any tracks
                                let hasTrack = pilotTrackViewModel.pilotTracks.contains { $0.pilotName == pilot.pilotName }
                                
                                HStack {
                                    
                                    // Checkbox (only for active pilots)
                                    if !pilot.inactive {
                                        Button(action: {
                                            if selectedPilotIDs.contains(pilot.id) {
                                                selectedPilotIDs.remove(pilot.id)
                                            } else {
                                                selectedPilotIDs.insert(pilot.id)
                                            }
                                        }) {
                                            Image(systemName: selectedPilotIDs.contains(pilot.id) ? "checkmark.square" : "square")
                                                .foregroundColor(hasTrack ? pilotActiveFontColor : pilotInactiveFontColor)
                                        }
                                        .buttonStyle(PlainButtonStyle())
                                    } else {
                                        
                                        // Empty spacer to align names
                                        Image(systemName: "square")
                                            .opacity(0) // invisible but keeps layout aligned
                                    }

                                    // Pilot name
                                    Text(pilot.pilotName)
                                        .foregroundColor(hasTrack ? pilotActiveFontColor : pilotInactiveFontColor)
                                    // … inside ForEach HStack

                                    Spacer()

                                    if pilot.inactive {
                                        Button("Activate Pilot") {
                                            pilotToActivate = pilot
                                            activatePilot = true
                                        }
                                        .font(.caption)
                                        .buttonStyle(BorderlessButtonStyle())
                                    }
                                }
                            }
                        }
                        .padding(.vertical, 0)
                    }
                    VStack (alignment: .leading) {
                        Text("Readings data aggregated by Synoptic")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                        Text("https://synopticdata.com")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                            .padding(.bottom, 8)
                        Text("Radar/satellite data provided by Rain Viewer")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                        Text("https://www.rainviewer.com")
                            .font(.caption)
                            .foregroundColor(infoFontColor)
                    }
                    .listRowBackground(attributionSheetBackgroundColor)
                }
            }
            .padding(.horizontal)
            .padding(.vertical, 12)
            .background(Color(UIColor.systemBackground))
            .clipShape(RoundedRectangle(cornerRadius: 12))
        }
        
        .onReceive(pilotViewModel.$pilots) { _ in
            resyncSelectedPilotIDs()
        }
        
        .onAppear() {
            
            if $tempMapDisplayMode.wrappedValue == .tracking {
                // Reload pilot list with all available tracks (in case user had previously selected pilots,
                // which would have created a filtered list)
                pilotTrackViewModel.getPilotTracks(days: pilotTrackDays,
                                                   selectedPilots: []) {}
            }
        }
        
        .onDisappear {
            // Update the main state variables when the sheet is dismissed
            selectedMapType     = tempSelectedMapType
            pilotTrackDays      = tempPilotTrackDays
            mapDisplayMode      = tempMapDisplayMode
            showSites           = tempShowSites
            showStations        = tempShowStations
            showRadar           = tempShowRadar
            showInfrared        = tempShowInfrared
            radarColorScheme    = tempRadarColorScheme
            selectedPilots      = pilotViewModel.pilots.filter { selectedPilotIDs.contains($0.id) }
            
        }
        
        .sheet(isPresented: $addPilot, onDismiss: {
            pilotViewModel.getPilots() {
                resyncSelectedPilotIDs()
            }
        }) {
            PilotAppendView()
                .interactiveDismissDisabled(true)
        }
        
        .sheet(isPresented: $activatePilot, onDismiss: {
            pilotViewModel.getPilots() {
                resyncSelectedPilotIDs()
            }
        }) {
            PilotActivateView(pilot: pilotToActivate!)
                .interactiveDismissDisabled(true)
        }
    }
    
    private func resyncSelectedPilotIDs() {
      // If the parent binding was empty, default to “all” again:
      if selectedPilots.isEmpty {
        selectedPilotIDs = Set(pilotViewModel.pilots.map(\.id))
      } else {
        // Otherwise preserve exactly what the parent had chosen
        selectedPilotIDs = Set(selectedPilots.map(\.id))
      }
    }
}
import SwiftUI

struct SoaringForecastView: View {
    @ObservedObject var richVM:                 SoaringForecastViewModel
    @ObservedObject var basicVM:                SoaringForecastBasicViewModel
    @ObservedObject var userSettingsViewModel:  UserSettingsViewModel
    let codeOptions: [(name: String, forecastType: String, code: String)]
    @Binding var selectedIndex: Int
    let openLink: (URL) -> Void
    
    // Rich forecast sections
    @State private var showForecast             = true
    @State private var showSounding             = true
    @State private var showModelData            = false
    
    // Basic forecast sections
    @State private var showBasicForecast        = true
    @State private var showBasicLiftData        = true
    @State private var showBasicSoundingData    = true
        
    var body: some View {
        Section(header: Text("Soaring Forecast")
            .font(.headline)
            .foregroundColor(sectionHeaderColor)
            .bold()) {

            // Loading
            if richVM.isLoading || basicVM.isLoading {
                ProgressView().scaleEffect(0.75)
            }
            else if codeOptions.isEmpty {
                Text("No soaring forecast found for region")
            }
            else {
                // Picker if multiple sites
                if codeOptions.count > 1 {
                    Picker("Select Location", selection: $selectedIndex) {
                        ForEach(0..<codeOptions.count, id: \.self) { idx in
                            Text(codeOptions[idx].name).tag(idx)
                        }
                    }
                    .pickerStyle(SegmentedPickerStyle())
                    .padding(.vertical, 4)
                    .onChange(of: selectedIndex) { oldIndex, newIndex in
                        let code = codeOptions[newIndex].code
                        if codeOptions[newIndex].forecastType == "rich" {
                            richVM.fetchSoaringForecast(airportCode: code)
                        } else {
                            basicVM.fetchSoaringForecast(airportCode: code)
                        }
                        userSettingsViewModel.updatePickListSelection(pickListName: "soaringForecast", selectedIndex: newIndex)
                    }
                }
                
                if codeOptions[selectedIndex].forecastType == "rich" {

                    Text("Forecast Date: \(richVM.soaringForecast?.date ?? "")")
                        .font(.footnote)

                    // 1) Soaring Forecast content
                    DisclosureGroup(isExpanded: $showForecast) {
                        VStack(alignment: .leading, spacing: 5) {
                            if richVM.soaringForecast?.soaringForecastFormat == "rich" {
                                Text(richVM.soaringForecast?.triggerTempData ?? "")
                                    .font(.subheadline)
                            }
                            ForEach(richVM.soaringForecast?.soaringForecastData ?? []) { row in
                                HStack {
                                    Text(row.heading)
                                        .font(.footnote)
                                        .foregroundColor(infoFontColor)
                                        .multilineTextAlignment(.trailing)
                                        .frame(maxWidth: .infinity, alignment: .trailing)
                                        .padding(.vertical, 1)
                                    Text(row.value ?? "")
                                        .font(.subheadline)
                                        .multilineTextAlignment(.leading)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                }
                            }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastRichSimple"),
                               let url = URL(string: updateURL(url: base,
                                                               parameter: "airportcode",
                                                               value: codeOptions[selectedIndex].code)) {
                                openLink(url)
                            }
                        }
                    } label: {
                        Text("Soaring Forecast").font(.headline).foregroundColor(rowHeaderColor)
                    }
                    
                    // 2) Sounding Data
                    DisclosureGroup(isExpanded: $showSounding) {
                        Group {
                            richSoundingGrid(data: richVM.soaringForecast?.richSoundingData ?? [])
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastRichSimple"),
                               let url = URL(string: updateURL(url: base,
                                                               parameter: "airportcode",
                                                               value: codeOptions[selectedIndex].code)) {
                                openLink(url)
                            }
                        }
                    } label: {
                        Text("Sounding Data").font(.headline).foregroundColor(rowHeaderColor)
                    }
                    
                    // 3) Numerical Model Data (rich only)
                    if richVM.soaringForecast?.soaringForecastFormat == "rich" {
                        DisclosureGroup(isExpanded: $showModelData) {
                            ScrollView(.horizontal) {
                                VStack(alignment: .leading) {
                                    ForEach(richVM.soaringForecast?.modelData ?? []) { row in
                                        Text(row.value)
                                            .font(.system(.subheadline, design: .monospaced))
                                    }
                                }
                            }
                            .contentShape(Rectangle())
                            .onTapGesture {
                                if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastRichSimple"),
                                   let url = URL(string: updateURL(url: base,
                                                                   parameter: "airportcode",
                                                                   value: codeOptions[selectedIndex].code)) {
                                    openLink(url)
                                }
                            }
                        } label: {
                            Text("Numerical Model Data")
                                .font(.headline)
                                .foregroundColor(rowHeaderColor)
                        }
                    }

                } else {
                    // Basic forecast

                    Text("Forecast Date: \(basicVM.soaringForecastBasic?.date ?? "")")
                        .font(.footnote)
                    
                    DisclosureGroup(isExpanded: $showBasicForecast) {
                        VStack(alignment: .leading, spacing: 5) {
                            ForEach(basicVM.soaringForecastBasic?.basicSoaringForecastData ?? []) { row in
                                HStack {
                                    Text(row.heading)
                                        .font(.footnote)
                                        .foregroundColor(infoFontColor)
                                        .multilineTextAlignment(.trailing)
                                        .frame(maxWidth: .infinity, alignment: .trailing)
                                        .padding(.vertical, 1)
                                    Text(row.value ?? "")
                                        .font(.subheadline)
                                        .multilineTextAlignment(.leading)
                                        .frame(maxWidth: .infinity, alignment: .leading)
                                }
                            }
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastBasic"),
                               let url = URL(string: updateURL(url: base,
                                                               parameter: "airportcode",
                                                               value: codeOptions[selectedIndex].code)) {
                                openLink(url)
                            }
                        }
                    } label: {
                        Text("Soaring Forecast").font(.headline).foregroundColor(rowHeaderColor)
                    }
                    
                    DisclosureGroup(isExpanded: $showBasicLiftData) {
                        Group {
                            basicLiftGrid(data: basicVM.soaringForecastBasic?.basicLiftData ?? [])
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastBasic"),
                               let url = URL(string: updateURL(url: base,
                                                               parameter: "airportcode",
                                                               value: codeOptions[selectedIndex].code)) {
                                openLink(url)
                            }
                        }
                    } label: {
                        Text("Lift Data")
                            .font(.headline)
                            .foregroundColor(rowHeaderColor)
                    }
                    
                    DisclosureGroup(isExpanded: $showBasicSoundingData) {
                        Group {
                            basicSoundingGrid(data: basicVM.soaringForecastBasic?.basicSoundingData ?? [])
                        }
                        .contentShape(Rectangle())
                        .onTapGesture {
                            if let base = AppURLManager.shared.getAppURL(URLName: "soaringForecastBasic"),
                               let url = URL(string: updateURL(url: base,
                                                               parameter: "airportcode",
                                                               value: codeOptions[selectedIndex].code)) {
                                openLink(url)
                            }
                        }
                    } label: {
                        Text("Sounding Data")
                            .font(.headline)
                            .foregroundColor(rowHeaderColor)
                    }
                }
            }
        }
    }
    
    private func richSoundingGrid(data: [RichSoundingData]) -> some View {
        LazyVGrid(columns: [
            GridItem(.fixed(64), spacing: 5, alignment: .trailing),
            GridItem(.fixed(52), spacing: 5, alignment: .trailing),
            GridItem(.fixed(52), spacing: 5, alignment: .trailing),
            GridItem(.fixed(56), spacing: 5, alignment: .trailing),
            GridItem(.fixed(52), spacing: 5, alignment: .trailing),
        ], spacing: 6) {
            Text("Altitude").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Temp").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Wind (mph)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Thermal Index").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Lift (m/s)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            
            ForEach(data) { d in
                Text("\(d.altitude) ft")
                    .font(.footnote)
                HStack {
                    Text("\(String(Int(d.temperatureF)))")
                        .font(.caption)
                        .foregroundColor(tempColor(Int(d.temperatureF))) +
                    Text(" ° F")
                        .font(.footnote)
                }
                HStack {
                    Text("\(String(Int(d.windSpeedMph)))")
                        .font(.footnote)
                        .foregroundColor(windSpeedColor(windSpeed: Int(d.windSpeedMph), siteType: ""))
                    Image(systemName: windArrow)
                        .rotationEffect(Angle(degrees: Double(d.windDirection+180)))
                        .font(.caption)
                }
                Text(String(format: "%.1f", d.thermalIndex))
                    .font(.footnote)
                Text(String(format: "%.1f", d.liftRateMs))
                    .font(.footnote)
                    .foregroundStyle(thermalColor(d.liftRateMs))
            }
        }
    }
    
    private func basicLiftGrid(data: [BasicLiftData]) -> some View {
        LazyVGrid(columns: [
            GridItem(.fixed(65), spacing: 5, alignment: .trailing),
            GridItem(.fixed(70), spacing: 5, alignment: .trailing),
            GridItem(.fixed(52), spacing: 5, alignment: .trailing),
            GridItem(.fixed(56), spacing: 5, alignment: .trailing),
        ], spacing: 6) {
            Text("Altitude (ft)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Thermal Index").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("ToC (°F)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("Lift (m/s)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)

            ForEach(data) { d in
                Text("\(d.altitude)")
                    .font(.footnote)
                Text(String(d.thermalIndex))
                    .font(.footnote)
                Text(String(d.tempOfConvection))
                    .font(.footnote)
                Text(String(d.liftRate))
                    .font(.footnote)
                    .foregroundColor(thermalColor(Double(d.liftRate)))
            }
        }
    }
    
    private func basicSoundingGrid(data: [BasicSoundingData]) -> some View {
        LazyVGrid(columns: [
            GridItem(.fixed(65), spacing: 5, alignment: .trailing),
            GridItem(.fixed(70), spacing: 5, alignment: .trailing),
            GridItem(.fixed(70), spacing: 5, alignment: .trailing),
        ], spacing: 6) {
            Text("Altitude (ft)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("am Wind (mph)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)
            Text("pm Wind (mph)").font(.footnote).foregroundColor(infoFontColor).multilineTextAlignment(.trailing)

            ForEach(data) { d in
                Text("\(d.altitude)")
                    .font(.footnote)
                HStack {
                    Text("\(String(Int(d.amWindSpeed)))")
                        .font(.footnote)
                        .foregroundColor(windSpeedColor(windSpeed: Int(d.amWindSpeed), siteType: ""))
                    Image(systemName: windArrow)
                        .rotationEffect(Angle(degrees: Double(d.amWindDirection+180)))
                        .font(.caption)
                }
                HStack {
                    Text("\(String(Int(d.pmWindSpeed)))")
                        .font(.footnote)
                        .foregroundColor(windSpeedColor(windSpeed: Int(d.pmWindSpeed), siteType: ""))
                    Image(systemName: windArrow)
                        .rotationEffect(Angle(degrees: Double(d.pmWindDirection+180)))
                        .font(.caption)
                }
            }
        }
    }
}
import SwiftUI
import Combine

struct FlyingPotentialDetailView: View {
    var site: Site                  // Received from parent view
    var favoriteName: String?       // Override display name if site detail is for a user favorite
    var forecastData: ForecastData  // Forecast by hour format
    var forecastIndex: Int          // Index to use for correct date/hour
    
    @Environment(\.presentationMode) var presentationMode
    @State private var currentForecastIndex: Int = 0

    var body: some View {
        let displayName = favoriteName ?? site.siteName
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                    }
                }
                Spacer()
                Text(displayName)
                    .foregroundColor(sectionHeaderColor)
                    .bold()
            }
            .padding()
            .background(toolbarBackgroundColor)
            
            HStack { //Arrows for navigating track nodes
                Button(action: {
                    currentForecastIndex -= 1
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                    }
                    .padding(.horizontal, 8)
                }
                .id("backButton")
                // Hide and disable the button when it's not applicable
                .opacity(currentForecastIndex > 0 ? 1.0 : 0.0)
                .disabled(currentForecastIndex == 0)

                Spacer()
                
                HStack {
                    Text(forecastData.hourly.formattedDay?[currentForecastIndex] ?? "")
                    Text(forecastData.hourly.formattedDate?[currentForecastIndex] ?? "")
                    Text(forecastData.hourly.formattedTime?[currentForecastIndex] ?? "")
                }
                
                Spacer()

                Button(action: {
                    currentForecastIndex += 1
                }) {
                    HStack {
                        Text("Next")
                            .foregroundColor(toolbarActiveFontColor)
                        Image(systemName: "chevron.right")
                            .foregroundColor(toolbarActiveImageColor)
                    }
                    .padding(.horizontal, 8)
                }
                .id("nextButton")
                // Hide and disable the button when it's not applicable
                .opacity(currentForecastIndex < forecastData.hourly.formattedTime!.count - 1 ? 1.0 : 0.0)
                .disabled(currentForecastIndex >= forecastData.hourly.formattedTime!.count - 1)
            }
            .padding()
            .background(navigationBackgroundColor)

            
            List {
                
                // Combined
                Section()
                {
                    FlyingPotentialDetailRow(
                        label:              "Flying potential",
                        colorValue:         forecastData.hourly.combinedColorValue![currentForecastIndex],
                        valueText:          "",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                }
                
                // Wind
                Section()
                {
                    
                    FlyingPotentialDetailRow(
                        label:              "Wind direction",
                        colorValue:         forecastData.hourly.windDirectionColorValue![currentForecastIndex],
                        valueText:          "",
                        windDirection:      forecastData.hourly.winddirection_10m[currentForecastIndex],
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "Surface wind speed",
                        colorValue:         forecastData.hourly.surfaceWindColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.windspeed_10m[currentForecastIndex])) mph",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "Surface gust speed",
                        colorValue:         forecastData.hourly.surfaceGustColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.windgusts_10m[currentForecastIndex])) mph",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "Surface gust factor",
                        colorValue:         forecastData.hourly.gustFactorColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.gustFactor?[currentForecastIndex] ?? 0)) mph",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )

                    FlyingPotentialDetailRow(
                        label:              "Winds aloft speed",
                        colorValue:         forecastData.hourly.windsAloftColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.windsAloftMax?[currentForecastIndex] ?? 0)) mph",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                }
                .padding(.vertical, 0)
                
                // Weather
                Section()
                {

                    FlyingPotentialDetailRow(
                        label:              "Cloud cover",
                        colorValue:         forecastData.hourly.cloudCoverColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.cloudcover[currentForecastIndex]))%",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "Precipitation probability",
                        colorValue:         forecastData.hourly.precipColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.precipitation_probability[currentForecastIndex]))%",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "CAPE",
                        colorValue:         forecastData.hourly.CAPEColorValue![currentForecastIndex],
                        valueText:          "\(Int(forecastData.hourly.cape[currentForecastIndex])) J/kg",
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )
                    
                    FlyingPotentialDetailRow(
                        label:              "Thermal strength",
                        colorValue:         forecastData.hourly.thermalVelocityColorValue![currentForecastIndex],
                        valueText:          String(format: "%.1f m/s", forecastData.hourly.thermalVelocityMax?[currentForecastIndex] ?? 0),
                        windDirection:      nil,
                        siteWindDirection:  site.windDirection
                    )

                }
                .padding(.vertical, 0)

            }
            .listSectionSpacing(8)
            
            .onAppear {
                currentForecastIndex = forecastIndex
            }
        }
    }
}

struct FlyingPotentialDetailRow: View {
    let label:              String
    let colorValue:         Int
    let valueText:          String
    let windDirection:      Double?
    let siteWindDirection:  SiteWindDirection
    
    let dataWidth:  CGFloat = 44
    let rowHeight:  CGFloat = 32
    let labelWidth: CGFloat = 180

    var body: some View {
        let displayColor = FlyingPotentialColor.color(for: colorValue)
        let imageSize = FlyingPotentialImageSize(displayColor)
        HStack(alignment: .center, spacing: 8) {
            
            Text(label)
                .font(.subheadline)
                .foregroundColor(infoFontColor)
                .frame(width: labelWidth, alignment: .trailing)

            Image(systemName: flyingPotentialImage)
                .resizable()
                .scaledToFit()
                .frame(width: imageSize, height: imageSize)
                .foregroundColor(displayColor)
                .padding(8)
                .frame(width: dataWidth, height: rowHeight)

            if let windDirection {
                HStack {
                    Spacer()
                    WindDirectionIndicator(
                        currentDirection: windDirection,
                        siteWindDirection: siteWindDirection
                    )
                    Spacer()
                }
                .frame(maxWidth: .infinity)
            } else {
                Text(valueText)
                    .font(.subheadline)
                    .frame(maxWidth: .infinity)
            }
        }
    }
}

struct WindDirectionIndicator: View {
    let currentDirection: Double
    let siteWindDirection: SiteWindDirection

    let windDirectionIndicatorSize: CGFloat = 40
    let windDirectionColorWidth: CGFloat = 1

    // Computed properties that pull from siteWindDirection
    private var goodRanges: [(Double, Double)] {
        windDirectionRanges(from: siteWindDirection).goodRanges
    }

    private var marginalRanges: [(Double, Double)] {
        windDirectionRanges(from: siteWindDirection).marginalRanges
    }

    var body: some View {
        let ringRadius = (0.8 * windDirectionIndicatorSize) / 2

        ZStack {
            // Color ring
            ForEach(0..<360, id: \.self) { degree in
                let color = colorForDirection(degree)
                let colorDescription = color.description.lowercased()

                let extraLength: CGFloat = {
                    if colorDescription.contains("green") {
                        return 5
                    } else if colorDescription.contains("yellow") {
                        return 5
                    } else {
                        return 0
                    }
                }()

                let capsuleHeight = windDirectionColorWidth + extraLength
                let offset = -(ringRadius - (windDirectionColorWidth / 2)) + (extraLength / 2)

                Capsule()
                    .fill(color)
                    .frame(width: 2, height: capsuleHeight)
                    .offset(y: offset)
                    .rotationEffect(.degrees(Double(degree)))
            }

            // Triangle pointing inward from wind direction
            let correctedAngle = currentDirection - 90
            let radians = correctedAngle * .pi / 180
            let triangleDistance = ringRadius + 6
            let triangleX = cos(radians) * triangleDistance
            let triangleY = sin(radians) * triangleDistance

            Triangle()
                .fill(Color.white)
                .frame(width: 14, height: 12)
                .rotationEffect(.degrees(currentDirection))
                .offset(x: triangleX, y: triangleY)
        }
        .frame(width: windDirectionIndicatorSize, height: windDirectionIndicatorSize)
        .padding(.vertical, 4)
    }

    private func colorForDirection(_ degree: Int) -> Color {
        for (start, end) in goodRanges {
            if angleInRange(degree, start, end) {
                return .green
            }
        }
        for (start, end) in marginalRanges {
            if angleInRange(degree, start, end) {
                return .yellow
            }
        }
        return .red
    }

    private func angleInRange(_ angle: Int, _ start: Double, _ end: Double) -> Bool {
        if start <= end {
            return Double(angle) >= start && Double(angle) <= end
        } else {
            return Double(angle) >= start || Double(angle) <= end // wraps 360
        }
    }
}

struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: CGPoint(x: rect.midX, y: rect.maxY))       // tip at bottom
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.minY))    // top right
        path.addLine(to: CGPoint(x: rect.minX, y: rect.minY))    // top left
        path.closeSubpath()
        return path
    }
}
import SwiftUI

struct PilotAppendView: View {
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    
    @State private var pilotName = ""
    @State private var inreachURL: String = "https://share.garmin.com/" // Prefilled with default URL prefix
    @State private var statusMessage = ""
    @State private var showValidationError = false
    @State private var duplicatePilotError = false
    @State private var duplicateShareURLError = false
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                        Text("Back")
                        Spacer()
                    }
                }
                .padding()
                Spacer()
            }
            .background(Color.blue.opacity(0.2))
        }
        
        List {
            
            Section(header: Text("Add new pilot")) {
                
                VStack(alignment: .leading) {
                    Text("Pilot name")
                        .font(.subheadline)
                        .padding(.bottom, 0)
                    
                    TextField("Pilot Name", text: $pilotName)
                        .font(.subheadline)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .cornerRadius(8)
                        .padding(.top, 0)
                    
                    if showValidationError && pilotName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        Text("Pilot name is required")
                            .foregroundColor(warningFontColor)
                            .font(.caption)
                    }
                    
                    // Display error for duplicate pilot name
                    if duplicatePilotError {
                        Text("A pilot with this name already exists")
                            .foregroundColor(warningFontColor)
                            .font(.caption)
                    }
                    
                    Text("InReach Share URL")
                        .font(.subheadline)
                        .padding(.top)
                        .padding(.bottom, 0)
                    
                    TextField("https://share.garmin.com/<pilot id>", text: $inreachURL)
                        .font(.subheadline)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .cornerRadius(8)
                        .padding(.top, 0)
                    
                    if showValidationError && !isValidInreachURL(inreachURL) {
                        Text("URL must be in the format:")
                            .foregroundColor(warningFontColor)
                            .font(.caption)
                        Text("https://share.garmin.com/<pilot ID>")
                            .foregroundColor(warningFontColor)
                            .font(.caption)
                    }
                    
                    // Display error for duplicate pilot share URL
                    if duplicateShareURLError {
                        Text("A pilot with this share URL already exists")
                            .foregroundColor(warningFontColor)
                            .font(.caption)
                    }
                    
                    Button(action: {
                        // Clear prior errors
                        statusMessage = ""
                        showValidationError = false
                        duplicatePilotError = false
                        duplicateShareURLError = false
                        
                        // Validate required fields
                        let trimmedName = pilotName.trimmingCharacters(in: .whitespacesAndNewlines)
                        let trimmedURL = inreachURL.trimmingCharacters(in: .whitespacesAndNewlines)
                        
                        if trimmedName.isEmpty || !isValidInreachURL(trimmedURL) {
                            showValidationError = true
                        }
                        
                        // Check for duplicates
                        if pilotViewModel.pilots.contains(where: { $0.pilotName.caseInsensitiveCompare(trimmedName) == .orderedSame }) {
                            duplicatePilotError = true
                        }
                        
                        if pilotViewModel.pilots.contains(where: { $0.trackingShareURL.trimmingCharacters(in: .whitespacesAndNewlines).caseInsensitiveCompare(trimmedURL) == .orderedSame }) {
                            duplicateShareURLError = true
                        }
                        
                        // Return all errors
                        if showValidationError || duplicatePilotError || duplicateShareURLError {
                            return
                        }
                        
                        hideKeyboard()
                        
                        // Add pilot to Google sheets
                        pilotViewModel.addPilot(pilotName: trimmedName,
                                                trackingShareURL: trimmedURL)

                        // Force update to pilot listing
                        pilotViewModel.getPilots() {

                            // Dismiss sheet and return to map settings
                            DispatchQueue.main.async {
                                dismiss()
                            }
                        }

                    }) {
                        Text("Submit")
                            .foregroundColor(skewTButtonTextColor)
                            .padding(8)
                    }
                    .frame(width: skewTButtonWidth)
                    .background(skewTButtonBackgroundColor)
                    .cornerRadius(8)
                    .padding(.vertical)
                    
                    if statusMessage != "" {
                        Text(statusMessage)
                            .foregroundColor(.gray)
                            .padding()
                    }
                }
            }
            
        }
        Spacer()
        
    }
    
    func isValidInreachURL(_ url: String) -> Bool {
        let trimmed = url.trimmingCharacters(in: .whitespacesAndNewlines)
        let prefix = "https://share.garmin.com/"
        return trimmed.hasPrefix(prefix) && trimmed.count > prefix.count
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
    
}
import SwiftUI
import MapKit
import Combine
import Foundation
import Charts

// Splits an array into sub-arrays of at most `size` elements
// (used because elevation API call is limited to 99 elements per call)
private extension Array {
    func chunked(into size: Int) -> [[Element]] {
        guard size > 0, count > 0 else { return [] }
        return stride(from: 0, to: count, by: size).map { start in
            let end = Swift.min(start + size, count)
            return Array(self[start..<end])
        }
    }
}

// Structure to process API call to elevation for a set of coordinates
struct ElevationResponse: Codable {
    let elevation: [Double]
}

struct PilotTrackNodeView: View {
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @Environment(\.presentationMode) var presentationMode

    let originalPilotTrack: PilotTrack
    
    @State private var currentNodeGroundElevation: Int? = 0
    @State private var groundElevations: [Int] = []
    @State private var cancellables = Set<AnyCancellable>()
    @State private var currentTrackIndex: Int = -1      // Set to -1 to force the index change to trigger on appear (fetching altitude)

    // Set a live timer to track time elapsed since the last track update
    @State private var now = Date()
    private let timer = Timer
        .publish(every: 1, on: .main, in: .common)
        .autoconnect()
    
    var body: some View {
        let colWidth: CGFloat = 140
        let rowVerticalPadding: CGFloat = 4

        let calendar = Calendar.current
        let sameDayTracks = pilotTrackViewModel.pilotTracks
            .filter { $0.pilotName == originalPilotTrack.pilotName && calendar.isDate($0.dateTime, inSameDayAs: originalPilotTrack.dateTime) }
            .sorted { $0.dateTime < $1.dateTime }

        let pilotTrack = sameDayTracks[safe: currentTrackIndex] ?? originalPilotTrack

        let (flightStartDateTime, flightLatestDateTime, formattedFlightDuration, startToEndDistance, maxAltitude, totalDistance) = getPilotTrackInfo(pilotTrack: pilotTrack)
        var trackingShareURL: String { pilotViewModel.trackingShareURL(for: pilotTrack.pilotName) ?? "" }

        var formattedNodeDate: String {
            let formatter = DateFormatter()
            formatter.dateFormat = "M/d/yyyy"
            return formatter.string(from: pilotTrack.dateTime)
        }

        var formattedNodeTime: String {
            let formatter = DateFormatter()
            formatter.dateFormat = "h:mm a"
            return formatter.string(from: pilotTrack.dateTime)
        }
        
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                        Spacer()
                        Text(pilotTrack.pilotName)
                            .foregroundColor(sectionHeaderColor)
                            .bold()
                    }
                }
                .padding()
                Spacer()
            }
            .background(toolbarBackgroundColor)

            HStack { //Arrows for navigating track nodes
                Button(action: {
                    currentTrackIndex -= 1
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                    }
                    .padding(.horizontal, 8)
                }
                .id("backButton")
                // Hide and disable the button when it's not applicable
                .opacity(currentTrackIndex > 0 ? 1.0 : 0.0)
                .disabled(currentTrackIndex == 0)

                Spacer()
                
                Text("Track Points")
                
                Spacer()

                Button(action: {
                    currentTrackIndex += 1
                }) {
                    HStack {
                        Text("Next")
                            .foregroundColor(toolbarActiveFontColor)
                        Image(systemName: "chevron.right")
                            .foregroundColor(toolbarActiveImageColor)
                    }
                    .padding(.horizontal, 8)
                }
                .id("nextButton")
                // Hide and disable the button when it's not applicable
                .opacity(currentTrackIndex < sameDayTracks.count - 1 ? 1.0 : 0.0)
                .disabled(currentTrackIndex >= sameDayTracks.count - 1)
            }
            .padding()
            .background(navigationBackgroundColor)
            
            List {
                if pilotTrack.inEmergency {
                    Section(header: Text("Emergency Status")
                        .font(.headline)
                        .foregroundColor(sectionHeaderColor)
                        .bold())
                    {
                        Text("InReach is in emergency status; track points not provided (except to emergency services)")
                            .foregroundColor(warningFontColor)
                            .bold()
                            .padding(.vertical, rowVerticalPadding)
                    }
                }
                
                Section(header: Text("Track")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold()
                    .onReceive(timer) { now = $0 })  // Track current time to calculate elapsed time since track update
                {
                    VStack(alignment: .leading, spacing: 0) {
                        
                        HStack {
                            Text("Track last updated")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            
                            // calculate time interval
                            let interval = now.timeIntervalSince(flightLatestDateTime)
                            let days = Int(interval) / 86_400
                            let hours = (Int(interval) % 86_400) / 3_600
                            let minutes = (Int(interval) % 3_600) / 60
                            let seconds = Int(interval) % 60
                            
                            if days > 0 {
                                Text("\(days) d \(hours):\(String(format: "%02d", minutes)):\(String(format: "%02d", seconds))")
                                    .font(.subheadline)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            } else {
                                Text("\(hours):\(String(format: "%02d", minutes)):\(String(format: "%02d", seconds))")
                                    .font(.subheadline)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Start")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text(flightStartDateTime.formatted())
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("End")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text(flightLatestDateTime.formatted())
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Duration")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text("\(formattedFlightDuration)")
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Max altitude")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text("\(Int(maxAltitude)) ft")
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Distance flown")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text("\(Int(totalDistance)) km")
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Start to end")
                                .multilineTextAlignment(.trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                                .frame(width: colWidth, alignment: .trailing)
                            Text("\(Int(startToEndDistance)) km")
                                .font(.subheadline)
                                .padding(.leading, 2)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                    }
                }
                
                // Elevation chart
                Section(header: Text("Track Elevation Chart")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    if sameDayTracks.count == groundElevations.count {
                        ElevationChartView(
                            tracks: sameDayTracks,
                            groundElevations: groundElevations,
                            selectedTime: pilotTrack.dateTime
                        )
                    }
                }
                
                Section(header: Text("Track point")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    VStack(alignment: .leading, spacing: 0) {
                        
                        HStack {
                            Text("Date")
                                .frame(width: colWidth, alignment: .trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                            Text(formattedNodeDate)
                                .font(.subheadline)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Time")
                                .frame(width: colWidth, alignment: .trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                            Text(formattedNodeTime)
                                .font(.subheadline)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Coordinates")
                                .frame(width: colWidth, alignment: .trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                            Text("\(pilotTrack.latitude), \(pilotTrack.longitude)")
                                .font(.subheadline)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Speed")
                                .frame(width: colWidth, alignment: .trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                            Text("\(Int(pilotTrack.speed.rounded())) mph")
                                .font(.subheadline)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        HStack {
                            Text("Altitude")
                                .frame(width: colWidth, alignment: .trailing)
                                .font(.subheadline)
                                .padding(.trailing, 2)
                                .foregroundColor(infoFontColor)
                            Text("\(Int(pilotTrack.altitude)) ft")
                                .font(.subheadline)
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .padding(.vertical, rowVerticalPadding)
                        
                        if let groundElevation = currentNodeGroundElevation {
                            HStack {
                                Text("Surface")
                                    .frame(width: colWidth, alignment: .trailing)
                                    .font(.subheadline)
                                    .padding(.trailing, 2)
                                    .foregroundColor(infoFontColor)
                                Text("\(groundElevation) ft")
                                    .font(.subheadline)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                            .padding(.vertical, rowVerticalPadding)
                            
                            HStack {
                                Text("Height")
                                    .frame(width: colWidth, alignment: .trailing)
                                    .font(.subheadline)
                                    .padding(.trailing, 2)
                                    .foregroundColor(infoFontColor)
                                Text("\(Int(pilotTrack.altitude) - groundElevation) ft")
                                    .font(.subheadline)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                            .padding(.vertical, rowVerticalPadding)
                        }
                        
                        if let message = pilotTrack.message, !message.isEmpty {
                            HStack {
                                Text("Message")
                                    .frame(width: colWidth, alignment: .trailing)
                                    .font(.subheadline)
                                    .padding(.trailing, 2)
                                    .foregroundColor(infoFontColor)
                                Text(message)
                                    .font(.subheadline)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                            }
                            .padding(.vertical, rowVerticalPadding)
                        }
                    }
                }
                
                Section(header: Text("Links")
                    .font(.headline)
                    .foregroundColor(sectionHeaderColor)
                    .bold())
                {
                    
                    Button(action: {
                        if let url = URL(string: trackingShareURL) {
                            UIApplication.shared.open(url)
                        }
                    }) {
                        Text("InReach share page")
                            .multilineTextAlignment(.trailing)
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                    }
                    Button(action: {
                        UIPasteboard.general.string = "\(pilotTrack.latitude),\(pilotTrack.longitude)"
                    }) {
                        Text("Copy coordinates to clipboard")
                            .multilineTextAlignment(.trailing)
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                    }
                    Button(action: {
                        openGoogleMaps(latitude: pilotTrack.latitude, longitude: pilotTrack.longitude)
                    }) {
                        Text("Open track point in Google Maps")
                            .multilineTextAlignment(.trailing)
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                    }
                    Button(action: {
                        openAppleMaps(latitude: pilotTrack.latitude, longitude: pilotTrack.longitude)
                    }) {
                        Text("Open track point in Apple Maps")
                            .multilineTextAlignment(.trailing)
                            .font(.subheadline)
                            .foregroundColor(rowHeaderColor)
                    }
                }
            }
            .padding(0)
            
            .onAppear {
                if let index = sameDayTracks.firstIndex(where: { $0.id == originalPilotTrack.id }) {
                    currentTrackIndex = index
                }
            }
            // Update ground elevation when the user taps “Next”/“Back”
            // (change is also triggered when sheet is opened and currentTrackIndex is populated)
            .onChange(of: currentTrackIndex) { oldIndex, newIndex in
                // Determine the newly‐visible track node
                let newTrack = sameDayTracks[safe: newIndex] ?? originalPilotTrack
                fetchGroundElevation(latitude: newTrack.latitude,
                                     longitude: newTrack.longitude)
            }
            // Update all ground elevations when the view model publishes a new track array
            // (also executes when sheet is opened)
            .onReceive(pilotTrackViewModel.$pilotTracks) { fullArray in
                // re‐build the same‐day subset and re‐call the batch fetch
                let updatedSameDay = fullArray
                    .filter { $0.pilotName == originalPilotTrack.pilotName
                           && Calendar.current.isDate($0.dateTime,
                                                       inSameDayAs: originalPilotTrack.dateTime) }
                    .sorted { $0.dateTime < $1.dateTime }

                // reset the current index if out‐of‐bounds
                if currentTrackIndex >= updatedSameDay.count {
                    currentTrackIndex = max(0, updatedSameDay.count - 1)
                }

                fetchAllGroundElevations(for: updatedSameDay)
            }
        }
        Spacer()
    }
    
    private func fetchGroundElevation(latitude: Double, longitude: Double) {
        let baseURL = AppURLManager.shared.getAppURL(URLName: "groundElevation") ?? "<Unknown ground elevation URL>"
        var updatedURL = updateURL(url: baseURL, parameter: "latitude", value: String(latitude))
        updatedURL = updateURL(url: updatedURL, parameter: "longitude", value: String(longitude))
        guard let url = URL(string: updatedURL) else { return }
        URLSession.shared.dataTaskPublisher(for: url)
            .map { $0.data }
            .decode(type: ElevationResponse.self, decoder: JSONDecoder())
            .map { $0.elevation.first }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .sink { elevation in
                self.currentNodeGroundElevation = convertMetersToFeet(elevation ?? 0)
            }
            .store(in: &cancellables)
    }
    
    // fetch elevations for array of points in one request
    private func fetchAllGroundElevations(for tracks: [PilotTrack]) {
        struct MultiElevationResponse: Codable {
            let elevation: [Double]
        }

        // elevation API call is limited to 99 coordinates per call,
        // so break break into pages of up to 99 coordinates each
        let pages = tracks.chunked(into: 99)

        // For each page, create a publisher that returns [Int] (feet)
        let elevationPublishers = pages.map { page -> AnyPublisher<[Int], Never> in
            let latList = page.map { "\($0.latitude)" }.joined(separator: ",")
            let lonList = page.map { "\($0.longitude)" }.joined(separator: ",")
            let baseURL = AppURLManager.shared.getAppURL(URLName: "groundElevation") ?? "<Unknown ground elevation URL>"
            var updatedURL = updateURL(url: baseURL, parameter: "latitude", value: latList)
            updatedURL = updateURL(url: updatedURL, parameter: "longitude", value: lonList)
            guard let url = URL(string: updatedURL) else {
                // if URL fails, return an empty array immediately
                return Just([Int]()).eraseToAnyPublisher()
            }

            return URLSession.shared.dataTaskPublisher(for: url)
                .map(\.data)
                .decode(type: MultiElevationResponse.self, decoder: JSONDecoder())
                .map { resp in resp.elevation.map { Int(convertMetersToFeet($0)) } }
                .replaceError(with: [])
                .eraseToAnyPublisher()
        }

        // Merge all pages:  Collect the [ [Int] ] into a single [[Int]], then flatten and assign
        Publishers.MergeMany(elevationPublishers)
            .collect()                           // [[Int]]
            .map { $0.flatMap { $0 } }           // [Int]
            .receive(on: DispatchQueue.main)
            .sink { allElevations in
                self.groundElevations = allElevations
            }
            .store(in: &cancellables)
    }
    
    private func getPilotTrackInfo(pilotTrack: PilotTrack) -> (flightStartDateTime: Date, flightLatestDateTime: Date, formattedFlightDuration: String, startToEndDistance: CLLocationDistance, maxAltitude: Double, totalDistance: CLLocationDistance) {
        // Get the oldest and newest tracks for the same pilot and the same date
        let calendar = Calendar.current
        let targetDate = pilotTrack.dateTime
        let sameDayTracks = pilotTrackViewModel.pilotTracks
            .filter { $0.pilotName == pilotTrack.pilotName && calendar.isDate($0.dateTime, inSameDayAs: targetDate) }

        guard let oldestTrack = sameDayTracks.min(by: { $0.dateTime < $1.dateTime }) else {
            return (Date(), Date(), "", 0, 0, 0)
        }
        guard let latestTrack = sameDayTracks.max(by: { $0.dateTime < $1.dateTime }) else {
            return (Date(), Date(), "", 0, 0, 0)
        }

        let flightStartDateTime = oldestTrack.dateTime
        let flightLatestDateTime = latestTrack.dateTime
        let flightDuration = Int(flightLatestDateTime.timeIntervalSince(flightStartDateTime))
        let flightHours = flightDuration / 3600
        let flightMinutes = (flightDuration % 3600) / 60
        let formattedFlightDuration = String(format: "%d:%02d", flightHours, flightMinutes)
        
        // Calculate start to end distance
        let startCoordinates = CLLocation(latitude: oldestTrack.latitude, longitude: oldestTrack.longitude)
        let latestCoordinates = CLLocation(latitude: latestTrack.latitude, longitude: latestTrack.longitude)
        let startToEndDistance = startCoordinates.distance(from: latestCoordinates) / 1000  // convert m to km

        // Calculate maximum altitude
        let maxAltitude = sameDayTracks.map { $0.altitude }.max() ?? 0.0

        // Calculate total distance flown
        var totalDistance: CLLocationDistance = 0
        for (index, track) in sameDayTracks.enumerated() {
            if index > 0 {
                let previousTrack = sameDayTracks[index - 1]
                let previousCoordinates = CLLocation(latitude: previousTrack.latitude, longitude: previousTrack.longitude)
                let currentCoordinates = CLLocation(latitude: track.latitude, longitude: track.longitude)
                totalDistance += previousCoordinates.distance(from: currentCoordinates)
            }
        }
        totalDistance = totalDistance / 1000 // Convert meters to kilometers

        return (flightStartDateTime, flightLatestDateTime, formattedFlightDuration, startToEndDistance, maxAltitude, totalDistance)
    }
    
    private func openGoogleMaps(latitude: Double, longitude: Double) {
        if let url = URL(string: "https://www.google.com/maps/search/?api=1&query=\(latitude),\(longitude)") {
            UIApplication.shared.open(url)
        }
    }
    
    private func openAppleMaps(latitude: Double, longitude: Double) {
        if let url = URL(string: "https://maps.apple.com/?q=Track&ll=\(latitude),\(longitude)") {
            UIApplication.shared.open(url)
        }
    }
}

struct ElevationChartView: View {
    let tracks: [PilotTrack]         // time‐sorted same-day tracks
    let groundElevations: [Int]       // parallels `tracks`
    let selectedTime: Date
    
    // Compute all Y values (ground + pilot altitudes)
    private var allYValues: [Int] {
        let pilotAltitudes = tracks.map { Int($0.altitude) }
        let all = groundElevations + pilotAltitudes
        return all
    }
    
    // Truncate down to nearest 1,000 ft
    private var yMin: Int {
        let rawMin = allYValues.min() ?? 0
        let m = (rawMin / 1_000) * 1_000
        return m
    }
    
    // Round up to next 1,000 ft
    private var yMax: Int {
        let rawMax = allYValues.max() ?? 0
        let M = ((rawMax + 999) / 1_000) * 1_000
        return M
    }
    
    var body: some View {
        let pilotAltitudes = tracks.map { Int($0.altitude) }
        let allY = groundElevations + pilotAltitudes
        let rawMin = allY.min() ?? 0
        let rawMax = allY.max() ?? 0
        let yMin = (rawMin / 1_000) * 1_000
        let yMax = ((rawMax + 999) / 1_000) * 1_000
        
        Chart {
            ForEach(Array(tracks.enumerated()), id: \.offset) { idx, track in
                AreaMark(
                    x: .value("Time", track.dateTime),
                    yStart: .value("Baseline", yMin),
                    yEnd: .value("Ground Elevation", groundElevations[idx])
                )
                .opacity(0.2)
            }
            
            ForEach(tracks) { track in
                LineMark(
                    x: .value("Time", track.dateTime),
                    y: .value("Pilot Altitude", track.altitude)
                )
                .lineStyle(StrokeStyle(lineWidth: 1))
                .foregroundStyle(chartLineColor)
            }
            
            RuleMark(x: .value("Selected", selectedTime))
                .lineStyle(StrokeStyle(lineWidth: 1, dash: [5]))
                .foregroundStyle(chartCurrentNodeColor)
        }
        .chartYScale(domain: Double(yMin)...Double(yMax))
        .frame(height: 220)
        .padding(.vertical, 8)
    }
}
import SwiftUI
import MapKit
import UIKit

let timeChangeNotification = UIApplication.significantTimeChangeNotification

@main
struct Cloudbase_ProjectApp: App {
    @Environment(\.scenePhase) private var scenePhase
    @State private var refreshMetadata: Bool = false
    @StateObject private var appRegionViewModel             = AppRegionViewModel()
    @StateObject private var appRegionCodesViewModel        = AppRegionCodesViewModel()
    @StateObject private var appURLViewModel                = AppURLViewModel()
    @StateObject private var liftParametersViewModel        = LiftParametersViewModel()
    @StateObject private var sunriseSunsetViewModel         = SunriseSunsetViewModel()
    @StateObject private var weatherCodesViewModel          = WeatherCodeViewModel()
    @StateObject private var siteViewModel                  = SiteViewModel()
    @StateObject private var pilotViewModel                 = PilotViewModel()
    @StateObject private var pilotTrackViewModel:             PilotTrackViewModel
    @StateObject private var siteForecastViewModel:           SiteForecastViewModel
    @StateObject private var stationLatestReadingViewModel:   StationLatestReadingViewModel
    @StateObject private var userSettingsViewModel          = UserSettingsViewModel(
        mapRegion: MKCoordinateRegion(
            center: CLLocationCoordinate2D(latitude: mapDefaultLatitude, longitude: mapDefaultLongitude),
            span: MKCoordinateSpan(latitudeDelta: mapDefaultLatitudeSpan, longitudeDelta: mapDefaultLongitudeSpan)
        ),
        selectedMapType: defaultmapType,
        pilotTrackDays: defaultPilotTrackDays,
        mapDisplayMode: defaultmapDisplayMode,
        showSites: defaultShowSites,
        showStations: defaultShowStations
    )
    
    init() {
        
        // Configure picker to use different widths based on content text
        UISegmentedControl.appearance().apportionsSegmentWidthsByContent = true
        
        // Create each view‐model in the proper order, using locals
        // pilotTrackViewModel isn't created here; waiting for mapView to be accessed before creating
        let appRegionVM         = AppRegionViewModel()
        let appRegionCodesVM    = AppRegionCodesViewModel()
        let appURLVM            = AppURLViewModel()
        let liftVM              = LiftParametersViewModel()
        let sunVM               = SunriseSunsetViewModel()
        let weatherVM           = WeatherCodeViewModel()
        let siteVM              = SiteViewModel()
        let pilotVM             = PilotViewModel()
        let forecastVM          = SiteForecastViewModel(
            liftParametersViewModel: liftVM,
            sunriseSunsetViewModel: sunVM,
            weatherCodesViewModel: weatherVM
        )
        let userSettingsVM      = UserSettingsViewModel(
            mapRegion: MKCoordinateRegion(
                center:     CLLocationCoordinate2D(
                    latitude:   mapDefaultLatitude,
                    longitude:  mapDefaultLongitude
                ),
                span: MKCoordinateSpan(
                    latitudeDelta:  mapDefaultLatitudeSpan,
                    longitudeDelta: mapDefaultLongitudeSpan
                )
            ),
            selectedMapType:    defaultmapType,
            pilotTrackDays:     defaultPilotTrackDays,
            mapDisplayMode:     defaultmapDisplayMode,
            showSites:          defaultShowSites,
            showStations:       defaultShowStations
        )
        let stationVM           = StationLatestReadingViewModel(siteViewModel: siteVM, userSettingsViewModel: userSettingsVM)
        
        // Populate app region view model (for user to select region and other metadata to load)
        appRegionVM.getAppRegions() {}
        
        // Populate app URLs and region codes
        appURLVM.getAppURLs() {}
        appRegionCodesVM.getAppRegionCodes() {}
        
        // Load user settings from storage
        userSettingsVM.loadFromStorage()
        _userSettingsViewModel = StateObject(wrappedValue: userSettingsVM)
        
        // Wire view models into their @StateObject wrappers:
        _appRegionViewModel             = StateObject(wrappedValue: appRegionVM)
        _appRegionCodesViewModel        = StateObject(wrappedValue: appRegionCodesVM)
        _appURLViewModel                = StateObject(wrappedValue: appURLVM)
        _liftParametersViewModel        = StateObject(wrappedValue: liftVM)
        _sunriseSunsetViewModel         = StateObject(wrappedValue: sunVM)
        _weatherCodesViewModel          = StateObject(wrappedValue: weatherVM)
        _siteViewModel                  = StateObject(wrappedValue: siteVM)
        _pilotViewModel                 = StateObject(wrappedValue: pilotVM)
        _stationLatestReadingViewModel  = StateObject(wrappedValue: stationVM)
        _siteForecastViewModel          = StateObject(wrappedValue: forecastVM)
        _userSettingsViewModel          = StateObject(wrappedValue: userSettingsVM)
        _pilotTrackViewModel            = StateObject(wrappedValue: PilotTrackViewModel(pilotViewModel: pilotVM))
    }
    
    var body: some Scene {
        WindowGroup {
            BaseAppView(refreshMetadata: $refreshMetadata)
                .environmentObject(appRegionViewModel)
                .environmentObject(appRegionCodesViewModel)
                .environmentObject(appURLViewModel)
                .environmentObject(liftParametersViewModel)
                .environmentObject(weatherCodesViewModel)
                .environmentObject(sunriseSunsetViewModel)
                .environmentObject(siteViewModel)
                .environmentObject(pilotViewModel)
                .environmentObject(pilotTrackViewModel)
                .environmentObject(siteForecastViewModel)
                .environmentObject(stationLatestReadingViewModel)
                .environmentObject(userSettingsViewModel)
                .environment(\.colorScheme, .dark)
                .onReceive(NotificationCenter.default.publisher(for: UIApplication.significantTimeChangeNotification)) { _ in
                    refreshMetadata = true
                }
                .onChange(of: scenePhase) { oldPhase, newPhase in
                    switch newPhase {
                    case .background, .inactive:
                        userSettingsViewModel.saveToStorage()
                    default:
                        break
                    }
                }
        }
    }
}

struct BaseAppView: View {
    @Binding var refreshMetadata: Bool
    @State private var isActive = false
    @State private var metadataLoaded = false
    @State private var showAppRegionSelector: Bool = false
    @EnvironmentObject var appRegionViewModel: AppRegionViewModel
    @EnvironmentObject var appURLViewModel: AppURLViewModel
    @EnvironmentObject var appRegionCodesViewModel: AppRegionCodesViewModel
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var pilotTrackViewModel: PilotTrackViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var siteForecastViewModel: SiteForecastViewModel
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @ObservedObject var regionManager = RegionManager.shared

    var body: some View {
        
        ZStack {
            backgroundColor.edgesIgnoringSafeArea(.all)
            VStack {
                if isActive && metadataLoaded {
                    
                    if RegionManager.shared.activeAppRegion.isEmpty {
                        // Empty view or placeholder while waiting for selection
                        Color.clear
                            .onAppear {
                                showAppRegionSelector = true
                            }
                    } else {
                        MainView(refreshMetadata: $refreshMetadata)
                    }
                    
                } else {
                    SplashScreenView()
                        .onAppear {
                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                checkIfReadyToTransition()
                            }
                        }
                }
            }
        }

        .onAppear {
            
            if !RegionManager.shared.activeAppRegion.isEmpty && !metadataLoaded {
                loadInitialMetadata()
            } else {
                showAppRegionSelector = true
            }
        }

        .onChange(of: regionManager.activeAppRegion) { _, newRegion in
            if !newRegion.isEmpty && !metadataLoaded {
                loadInitialMetadata()
            }
        }

        .onChange(of: refreshMetadata) { _, newValue in
            if newValue {

                // Force station latest readings refresh when region changes
                stationLatestReadingViewModel.resetLastFetchTimes()
                
                isActive = false
                metadataLoaded = false
                if !RegionManager.shared.activeAppRegion.isEmpty {
                    loadInitialMetadata()
                }
                refreshMetadata = false
            }
        }
    
        .sheet(isPresented: $showAppRegionSelector) {
            AppRegionView()
                .interactiveDismissDisabled(true)
                .environmentObject(userSettingsViewModel)
        }
    
    }
    
    private func loadInitialMetadata() {
        let group = DispatchGroup()

        // Load app regions before loading all other metadata
        appRegionViewModel.getAppRegions() {

            group.enter()
            appURLViewModel.getAppURLs() {

                group.enter()
                appRegionCodesViewModel.getAppRegionCodes() {
                    group.leave()
                }

                group.enter()
                liftParametersViewModel.getLiftParameters {
                    group.leave()
                }

                group.enter()
                weatherCodesViewModel.getWeatherCodes {
                    group.leave()
                }

                group.enter()
                sunriseSunsetViewModel.getSunriseSunset() {
                    group.leave()
                }

                group.enter()
                pilotViewModel.getPilots() {
                    group.leave()
                }

                group.enter()
                siteViewModel.getSites() {
                    stationLatestReadingViewModel.getLatestReadingsData(sitesOnly: true) {
                        group.leave()
                    }
                }

                group.leave() // Done initiating all the above
            }

            // Place notify after all enter calls
            group.notify(queue: .main) {
                metadataLoaded = true
                checkIfReadyToTransition()
            }
        }

        initializeLoggingFile()
    }

    private func checkIfReadyToTransition() {
        if metadataLoaded {
            withAnimation {
                isActive = true
            }
        }
    }
}

struct SplashScreenView: View {
    var body: some View {
        ZStack {
            backgroundColor.edgesIgnoringSafeArea(.all)
            VStack {
                Image("CloudbaseProjectIcon")
                    .resizable()
                    .scaledToFit()
                Text("Cloudbase Project")
                    .bold()
                    .foregroundColor(titleFontColor)
                    .padding(.top, 2)
            }
        }
    }
}
import SwiftUI
import Foundation

struct SkewTDataPoint: Decodable, CustomStringConvertible {
    var Temp_c: Double
    var Dewpoint_c: Double
    var Altitude_m: Double
    var description: String { "Temp_c: \(Temp_c), Dewpoint_c: \(Dewpoint_c), Altitude_m: \(Altitude_m)" }
}

struct SkewTLiftParameters {
    var tol: Double
    var tolTemp: Double
    var neg3: Double
    var neg3Temp: Double
}

// Array safe access extension (indexing safeguard)
extension Array {
    subscript(safe index: Int) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}

class SkewTChartManager: ObservableObject {
    var soaringForecastViewModel: SoaringForecastViewModel?
    @Published var dalrFlag = 0
    let surfaceAlt: Double = 4.229
    let maxAlt: Double = 20
    let dalr: Double = 5.4
    let screenWidth: CGFloat = UIScreen.main.bounds.width
    var proportionalHeight: CGFloat { screenWidth * 0.67 }
    
    var margin: (top: CGFloat, bottom: CGFloat, left: CGFloat, right: CGFloat) {
        (top: proportionalHeight * 0.06,
         bottom: proportionalHeight * 0.06,
         left: screenWidth * 0.14,
         right: screenWidth * 0.08)
    }
    
    var width: CGFloat { screenWidth - margin.left - margin.right }
    var height: CGFloat { proportionalHeight - margin.top - margin.bottom }
    
    // Scale functions
    func x(_ value: Double) -> CGFloat {
        // Domain [-10, 110] mapped to range [0, width]
        return CGFloat((value + 10) / 120 * Double(width)) + margin.left
    }
    func y(_ value: Double) -> CGFloat {
        // Domain [surfaceAlt, maxAlt] mapped to range [height, 0]
        return CGFloat(height - ((value - surfaceAlt) / (maxAlt - surfaceAlt) * Double(height))) + margin.top
    }
    
    // Data and lift parameters
    @Published var skewTSoundingData: [SkewTDataPoint] = []
    @Published var skewTLiftParameters: SkewTLiftParameters = SkewTLiftParameters(tol: 0, tolTemp: 0, neg3: 0, neg3Temp: 0)
    @Published var maxTempF: Double = 0
    
    // Draw DALR parameters
    func drawDALRParams(temp: Double, params: SkewTLiftParameters, context: inout GraphicsContext) {
        
        // Max temp for the day DALR line
        var dalrLine = Path()
        dalrLine.move(to: CGPoint(x: x(temp - (maxAlt - surfaceAlt) * dalr), y: y(maxAlt)))
        dalrLine.addLine(to: CGPoint(x: x(temp), y: y(surfaceAlt)))
        context.stroke(dalrLine, with: .color(skewTDALRColor), lineWidth: 1)
        
        // -3 index line
        var neg3Line = Path()
        neg3Line.move(to: CGPoint(x: x((params.neg3Temp * 9 / 5) + 32), y: y(params.neg3 * 3.28084 / 1000)))
        neg3Line.addLine(to: CGPoint(x: x((params.neg3Temp * 9 / 5) + 32 - 5.4), y: y(params.neg3 * 3.28084 / 1000)))
        context.stroke(neg3Line, with: .color(.white), lineWidth: 2)
        let neg3Label = Text("-3")
            .font(.subheadline)
        context.draw(neg3Label, at: CGPoint(x: x((params.neg3Temp * 9 / 5) + 32 + 6), y: y(params.neg3 * 3.284084 / 1000)))
        
        // Top of lift point
        let tolCircleCenter = CGPoint(x: x((params.tolTemp * 9 / 5) + 32), y: y(params.tol * 3.284084 / 1000))
        let tolCircle = Path(ellipseIn: CGRect(x: tolCircleCenter.x - 3, y: tolCircleCenter.y - 3, width: 6, height: 6))
        context.fill(tolCircle, with: .color(.white))
        let tolLabel = Text("ToL")
            .font(.subheadline)
        context.draw(tolLabel, at: CGPoint(x: x((params.tolTemp * 9 / 5) + 32 + 8), y: y(params.tol * 3.284084 / 1000)))
    }
    
    // Read user input and updates chart parameters
    func d3Update(userTemp: Double) {
        DispatchQueue.main.async {
            if self.skewTSoundingData.count > 1 {
                let threshold = (self.skewTSoundingData[1].Temp_c * 9 / 5) + 32 + 5.4
                if userTemp > threshold && userTemp < 120 {
                    let userSkewTLiftParameters = self.getSkewTLiftParameters(temp: userTemp, data: self.skewTSoundingData)
                    self.dalrFlag = 1
                    self.d3Clear()
                    self.skewTLiftParameters = userSkewTLiftParameters
                    self.dalrFlag = 0
                } else {
                    self.d3Clear()
                }
            }
        }
    }
    
    // Reset dynamic parameters
    func d3Clear() {
        if dalrFlag == 0 {
            skewTLiftParameters = getSkewTLiftParameters(temp: maxTempF, data: skewTSoundingData)
        }
    }
    
    // Calculate SkewT lift parameters
    func getSkewTLiftParameters(temp: Double, data: [SkewTDataPoint], position: Int = 0, raobSlope: Double? = nil, raobYInt: Double? = nil, params: SkewTLiftParameters? = nil) -> SkewTLiftParameters {
        var pos = position
        var skewTLiftParameters = params ?? SkewTLiftParameters(tol: 0, tolTemp: 0, neg3: 0, neg3Temp: 0)
        let tempC = (temp - 32) * 5 / 9
        let surfaceAlt_m = 1289.0
        let dalrSlope = -101.6
        let dalrYInt = surfaceAlt_m - (dalrSlope * tempC)
        
        // Find height of -3 index first
        while pos < data.count && (data[pos].Temp_c - ((data[pos].Altitude_m - dalrYInt) / dalrSlope)) < -3 {
            pos += 1
        }
        var interpolateX1 = data[pos].Temp_c
        var interpolateY1 = data[pos].Altitude_m
        var interpolateX2 = 0.0
        var interpolateY2 = 0.0
        if pos > 0 {
            interpolateX2 = data[pos - 1].Temp_c
            interpolateY2 = data[pos - 1].Altitude_m
        }
        if interpolateX1 != interpolateX2 {
            let computedRaobSlope = (interpolateY1 - interpolateY2) / (interpolateX1 - interpolateX2)
            let computedRaobYInt = interpolateY1 - (computedRaobSlope * interpolateX1)
            let interpolateX = (computedRaobYInt - dalrYInt - (3 * dalrSlope)) / (dalrSlope - computedRaobSlope)
            skewTLiftParameters.neg3 = interpolateY1 + (interpolateX - interpolateX1) * (interpolateY2 - interpolateY1) / (interpolateX2 - interpolateX1)
        } else {
            skewTLiftParameters.neg3 = (interpolateX1 + 3) * dalrSlope + dalrYInt
        }
        skewTLiftParameters.neg3Temp = (skewTLiftParameters.neg3 - dalrYInt) / dalrSlope
        
        // Now find top of lift point (thermal index is 0)
        while pos < data.count && (data[pos].Temp_c - ((data[pos].Altitude_m - dalrYInt) / dalrSlope)) < 0 {
            pos += 1
        }
        interpolateX1 = data[pos].Temp_c
        interpolateY1 = data[pos].Altitude_m
        interpolateX2 = 0.0
        interpolateY2 = 0.0
        if pos > 0 {
            interpolateX2 = data[pos - 1].Temp_c
            interpolateY2 = data[pos - 1].Altitude_m
        }
        if interpolateX1 != interpolateX2 {
            let computedRaobSlope = (interpolateY1 - interpolateY2) / (interpolateX1 - interpolateX2)
            let computedRaobYInt = interpolateY1 - (computedRaobSlope * interpolateX1)
            skewTLiftParameters.tol = ((dalrSlope * computedRaobYInt) - (computedRaobSlope * dalrYInt)) / (dalrSlope - computedRaobSlope)
        } else {
            skewTLiftParameters.tol = (interpolateX1 * dalrSlope) + dalrYInt
        }
        skewTLiftParameters.tolTemp = (skewTLiftParameters.tol - dalrYInt) / dalrSlope
        return skewTLiftParameters
    }
    
    func populateSoaringForecast(forecastMaxTemp: Int) {
        
        // Use soaringForecastViewModel to get forecast max temp
        self.maxTempF = Double(forecastMaxTemp)
        
        // Get sounding data
        let soundingURL = URL(string: "https://storage.googleapis.com/wasatch-wind-static/raob.json")!
        URLSession.shared.dataTask(with: soundingURL) { [weak self] data2, response2, error2 in
            if let self = self, let data2 = data2 {
                if let jsonData = try? JSONSerialization.jsonObject(with: data2) as? [[String: Any]] {
                    let decodedData = jsonData.compactMap { dict -> SkewTDataPoint? in
                        if let Temp_c = dict["Temp_c"] as? Double,
                           let Dewpoint_c = dict["Dewpoint_c"] as? Double,
                           let Altitude_m = dict["Altitude_m"] as? Double {
                            return SkewTDataPoint(Temp_c: Temp_c, Dewpoint_c: Dewpoint_c, Altitude_m: Altitude_m)
                        }
                        return nil
                    }
                    DispatchQueue.main.async {
                        self.skewTSoundingData = decodedData
                        self.skewTLiftParameters = self.getSkewTLiftParameters(temp: self.maxTempF, data: decodedData)
                    }
                }
            }
        }.resume()
    }
}

struct SkewTChartView: View {
    let forecastMaxTemp: Int
    
    @StateObject var manager = SkewTChartManager()
    @ObservedObject private var soaringForecastViewModel = SoaringForecastViewModel()   // Used to get max surface temp for the day
    @State private var userTemp: String = ""
    
    var body: some View {
        VStack {
            
            // Canvas for the skew-T chart drawing
            Canvas { context, size in
                // Set vertical x axis gridlines
                let xAxisTicks = stride(from: -10.0, through: 110.0, by: 5.0)
                for tick in xAxisTicks {
                    var line = Path()
                    let start = CGPoint(x: manager.x(tick), y: manager.y(4.2))
                    let end = CGPoint(x: manager.x(tick), y: 0 )
                    line.move(to: start)
                    line.addLine(to: end)
                    context.stroke(line, with: .color(skewTGridLineColor), lineWidth: 0.5)
                }
                
                // Set horizontal y axis gridlines
                let yAxisTicks = stride(from: manager.surfaceAlt, through: Double(manager.maxAlt + 2), by: 1.0)
                for tick in yAxisTicks {
                    var line = Path()
                    let start = CGPoint(x: manager.x(-10), y: manager.y(tick))
                    let end = CGPoint(x: manager.x(110), y: manager.y(tick))
                    line.move(to: start)
                    line.addLine(to: end)
                    context.stroke(line, with: .color(skewTGridLineColor), lineWidth: 0.5)
                }
                
                // Draw skewed border line
                var skewLine = Path()
                skewLine.move(to: CGPoint(x: manager.x(110), y: manager.y(manager.surfaceAlt)))
                skewLine.addLine(to: CGPoint(x: manager.x(25), y: manager.y(21)))
                context.stroke(skewLine, with: .color(skewTGridBorderColor), lineWidth: 1)
                
                // Plot Temp line
                if !manager.skewTSoundingData.isEmpty {
                    var tempPath = Path()
                    var firstPoint = true
                    for d in manager.skewTSoundingData {
                        let xVal = manager.x((d.Temp_c * 9 / 5) + 32)
                        let yVal = manager.y(d.Altitude_m * 3.28084 / 1000)
                        let point = CGPoint(x: xVal, y: yVal)
                        if firstPoint {
                            tempPath.move(to: point)
                            firstPoint = false
                        } else {
                            tempPath.addLine(to: point)
                        }
                    }
                    context.stroke(tempPath, with: .color(skewTTempColor), lineWidth: 1)
                }
                
                // Plot Dewpoint line
                if !manager.skewTSoundingData.isEmpty {
                    var dewPath = Path()
                    var firstPoint = true
                    for d in manager.skewTSoundingData {
                        let xVal = manager.x((d.Dewpoint_c * 9 / 5) + 32)
                        let yVal = manager.y(d.Altitude_m * 3.28084 / 1000)
                        let point = CGPoint(x: xVal, y: yVal)
                        if firstPoint {
                            dewPath.move(to: point)
                            firstPoint = false
                        } else {
                            dewPath.addLine(to: point)
                        }
                    }
                    context.stroke(dewPath, with: .color(skewTDewpointColor), lineWidth: 1)
                }
                
                // Draw DALR parameters using manager function
                manager.drawDALRParams(temp: manager.maxTempF, params: manager.skewTLiftParameters, context: &context)
                
                // Draw blank rectangle to cover temp and dewpoint lines above chart
                var rectPath = Path()
                 rectPath.addRect(CGRect(x: 0,
                 y: 0,
                 width: manager.width + manager.margin.left + manager.margin.right,
                 height: manager.margin.top - 4))
                context.fill(rectPath, with: .color(tableBackgroundColor))
                
                // Draw blank rectangle to cover temp and dewpoint lines left of chart
                rectPath.addRect(CGRect(x: 0,
                y: 0,
                width: manager.margin.left,
                height: manager.height + manager.margin.top + manager.margin.bottom))
                context.fill(rectPath, with: .color(tableBackgroundColor))
                
                // Draw blank polygon to cover upper right grid
                var polyPath = Path()
                polyPath.move(to: CGPoint(x: manager.x(25), y: 0))
                polyPath.addLine(to: CGPoint(x: manager.margin.left + manager.width, y: manager.y(manager.surfaceAlt)))
                polyPath.addLine(to: CGPoint(x: manager.margin.left + manager.width + manager.margin.right, y: manager.y(manager.surfaceAlt)))
                polyPath.addLine(to: CGPoint(x: manager.margin.left + manager.width + manager.margin.right, y: 0))
                polyPath.closeSubpath()
                context.fill(polyPath, with: .color(tableBackgroundColor))
                
                // Draw x axis
                var xAxis = Path()
                xAxis.move(to: CGPoint(x: manager.x(-10), y: manager.y(manager.surfaceAlt)))
                xAxis.addLine(to: CGPoint(x: manager.x(110), y: manager.y(manager.surfaceAlt)))
                context.stroke(xAxis, with: .color(skewTGridBorderColor), lineWidth: 1)
                // x axis tick labels
                for tick in stride(from: -10.0, through: 110.0, by: 10.0) {
                    let label = Text("\(Int(tick))°")
                        .font(.footnote)
                        .foregroundStyle(skewTAxisLabelColor)
                    context.draw(label, at: CGPoint(x: manager.x(tick), y: manager.y(manager.surfaceAlt) + 10))
                }
                
                // Draw y axis
                var yAxis = Path()
                yAxis.move(to: CGPoint(x: manager.x(-10), y: manager.y(manager.surfaceAlt)))
                yAxis.addLine(to: CGPoint(x: manager.x(-10), y: manager.y(manager.maxAlt)))
                context.stroke(yAxis, with: .color(skewTGridBorderColor), lineWidth: 1)
                // y axis tick labels (adding 2 in order to skip a label through the y-axis and ensure the top of the chart is labelled
                for tick in stride(from: manager.surfaceAlt + 2, through: Double(manager.maxAlt + 2), by: 2.0) {
                    let label = Text("\(Int(tick))k")
                        .font(.footnote)
                        .foregroundStyle(skewTAxisLabelColor)
                    context.draw(label, at: CGPoint(x: manager.x(-10) - 20, y: manager.y(tick))) // Adjust y position
                }
                
            }
            .frame(width: manager.screenWidth, height: manager.proportionalHeight)
            .background(tableBackgroundColor)
            .overlay {
                // Display text in front of Skew-T chart
                VStack (alignment: .trailing) {
                    Text("Top of Lift:  \(convertMetersToFeet(manager.skewTLiftParameters.tol)) ft")
                        .font(.headline)
                    Text("-3 Index: \(convertMetersToFeet(manager.skewTLiftParameters.neg3)) ft")
                        .font(.headline)
                        .padding(.bottom, 2)
                    Text("Forecast max temp: \(String(Int(manager.maxTempF)))°F")
                        .font(.footnote)
                        .foregroundStyle(infoFontColor)
                        .padding(.bottom, 4)
                    Text("Legend:")
                        .font(.caption)
                        .foregroundStyle(infoFontColor)
                        .padding(.bottom, 0)
                    Text("Dewpoint temp")
                        .font(.caption)
                        .foregroundColor(skewTDewpointColor)
                        .padding(.bottom, 0)
                    Text("Thermal temp")
                        .font(.caption)
                        .foregroundColor(skewTTempColor)
                        .padding(.bottom, 0)
                    Text("DALR")
                        .font(.caption)
                        .foregroundColor(skewTDALRColor)
                        .padding(.bottom, 1)
                    Spacer()
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .trailing)
                .padding(.vertical, 8)
                .padding(.horizontal, 24)
            }

            // Alternate max temp controls
            Text("Use alternate max temperature:")
                .font(.subheadline)
                .padding(.top)
            HStack (alignment: .center) {
                TextField("Temp", text: $userTemp)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .cornerRadius(8)
                    .frame(width: skewTButtonWidth * 0.7)
                    .keyboardType(.decimalPad)
                    .padding(.trailing, 0)
                    .onSubmit {
                        hideKeyboard()
                    }
                Text("°F ")
                    .font(.subheadline)
                    .padding(.leading, 0)
                Button(action: {
                    hideKeyboard()
                    manager.d3Update(userTemp: Double(userTemp) ?? manager.maxTempF)
                }) {
                    Text("Submit")
                        .foregroundColor(skewTButtonTextColor)
                        .padding(8)
                }
                .frame(width: skewTButtonWidth)
                .background(skewTButtonBackgroundColor)
                .cornerRadius(8)
                Button(action: {
                    userTemp = ""
                    hideKeyboard()
                    manager.d3Update(userTemp: manager.maxTempF)
                }) {
                    Text("Clear")
                        .foregroundColor(skewTButtonTextColor)
                        .padding(8)
                }
                .frame(width: skewTButtonWidth)
                .background(skewTButtonBackgroundColor)
                .cornerRadius(8)
            }
            // Setting buttonStyle to work around a SwiftUI bug where both buttons are actioned when either is pressed
            .buttonStyle(BorderlessButtonStyle())
            .padding(.horizontal)
            .padding(.top, 0)
            .padding(.bottom, 8)
        }
        .padding(.vertical, 0)
        .background(tableBackgroundColor)
        .cornerRadius(8)
        .onAppear {
            manager.populateSoaringForecast(forecastMaxTemp: forecastMaxTemp)
        }
    }

    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
import SwiftUI
import SDWebImageSwiftUI

struct DevTempView: View {
    let urlString: String = "https://flymarshall.com/co-4k/OUT/FCST/sounding1.curr.1600lst.d2.png?1753456649"

    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0

    @State private var offset: CGSize = .zero
    @State private var lastOffset: CGSize = .zero

    var body: some View {
        GeometryReader { geometry in
            WebImage(url: URL(string: urlString)) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fit)
            } placeholder: {
                Text("Tap to view")
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
            .scaleEffect(scale)
            .offset(offset)
            .gesture(
                SimultaneousGesture(
                    // Zoom
                    MagnificationGesture()
                        .onChanged { value in
                            let newScale = lastScale * value
                            scale = max(1.0, newScale)
                        }
                        .onEnded { _ in
                            lastScale = scale
                            offset = clampedOffset(
                                offset,
                                in: geometry.size,
                                scale: scale
                            )
                            lastOffset = offset
                        },

                    // Pan
                    DragGesture()
                        .onChanged { value in
                            let newOffset = CGSize(
                                width: lastOffset.width + value.translation.width,
                                height: lastOffset.height + value.translation.height
                            )
                            offset = clampedOffset(newOffset, in: geometry.size, scale: scale)
                        }
                        .onEnded { _ in
                            lastOffset = offset
                        }
                )
            )
            .gesture(
                TapGesture(count: 2)
                    .onEnded {
                        withAnimation {
                            scale = 1.0
                            lastScale = 1.0
                            offset = .zero
                            lastOffset = .zero
                        }
                    }
            )
            .frame(width: geometry.size.width, height: geometry.size.height)
            .background(Color.black.opacity(0.01))
        }
    }

    // Clamp offset so no part of image moves inside screen
    private func clampedOffset(_ offset: CGSize, in containerSize: CGSize, scale: CGFloat) -> CGSize {
        // The image is fit-aspect, so its dimensions depend on container
        let imageAspectRatio: CGFloat = 1.0 // 1:1 is safe for weather plots; override if needed

        let imageSize: CGSize
        if containerSize.width / containerSize.height < imageAspectRatio {
            // width-bound
            let width = containerSize.width * scale
            let height = width / imageAspectRatio
            imageSize = CGSize(width: width, height: height)
        } else {
            // height-bound
            let height = containerSize.height * scale
            let width = height * imageAspectRatio
            imageSize = CGSize(width: width, height: height)
        }

        let horizontalLimit = max(0, (imageSize.width - containerSize.width) / 2)
        let verticalLimit = max(0, (imageSize.height - containerSize.height) / 2)

        return CGSize(
            width: offset.width.clamped(to: -horizontalLimit...horizontalLimit),
            height: offset.height.clamped(to: -verticalLimit...verticalLimit)
        )
    }
}

// Helper to clamp CGFloat values
extension Comparable {
    func clamped(to limits: ClosedRange<Self>) -> Self {
        min(max(self, limits.lowerBound), limits.upperBound)
    }
}
import SwiftUI
import MapKit

// Page navigation values
enum NavBarSelectedView: Int {
    case site = 0
    case weather = 1
    case potential = 2
    case map = 3
    case webcam = 4
    case link = 5
}

struct MainView: View {
    @Binding var refreshMetadata: Bool
    @EnvironmentObject var liftParametersViewModel: LiftParametersViewModel
    @EnvironmentObject var weatherCodesViewModel: WeatherCodeViewModel
    @EnvironmentObject var sunriseSunsetViewModel: SunriseSunsetViewModel
    @EnvironmentObject var siteViewModel: SiteViewModel
    @EnvironmentObject var pilotViewModel: PilotViewModel
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @EnvironmentObject var stationLatestReadingViewModel: StationLatestReadingViewModel

    @State var selectedView:NavBarSelectedView = .site
    @State var siteViewActive =         true
    @State var weatherViewActive =      false
    @State var potentialViewActive =    false
    @State var mapViewActive =          false
    @State var webcamViewActive =       false
    @State var linkViewActive =         false
    @State private var openAboutView =  false

    private var appRegionName: String {
        AppRegionManager.shared.getRegionName() ?? ""
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                
                // Call content based on selected navigation
                if selectedView == .site {
                    SiteView()
                }
                if selectedView == .weather {
                    WeatherView()
                }
                if selectedView == .potential {
                    FlyingPotentialView()
                }
                if selectedView == .map {
                    MapContainerView(
                        pilotViewModel: pilotViewModel,
                        siteViewModel: siteViewModel,
                        userSettingsViewModel: userSettingsViewModel
                    )
                    .environmentObject(siteViewModel)
                    .environmentObject(pilotViewModel)
                    .environmentObject(stationLatestReadingViewModel)
                }
                if selectedView == .webcam {
                    WeatherCamView()
                }
                if selectedView == .link {
                    LinkView()
                }
                Spacer()
                  
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    // Title bar (top of screen)
                    ToolbarItem(placement: .navigationBarLeading) {
                        HStack (spacing:3) {
                            Image(systemName: "sunrise")
                                .foregroundColor(sunImageColor)
                                .imageScale(.medium)
                            Text(sunriseSunsetViewModel.sunriseSunset?.sunrise ?? "")
                                .foregroundColor(sunFontColor)
                                .font(.caption)
                        }
                    }
                    ToolbarItem(placement: .principal) {
                        Button(action: { openAboutView.toggle() }) {
                            HStack {
                                Text("Cloudbase: \(appRegionName)")
                                    .font(.subheadline)
                                    .bold()
                                    .foregroundColor(titleFontColor)
                                Image(systemName: "chevron.down")
                                    .font(.subheadline)
                                    .foregroundColor(infoFontColor)
                                    .imageScale(.medium)

                            }
                        }
                        .sheet(isPresented: $openAboutView) {
                            AboutView(refreshMetadata: $refreshMetadata)
                                .interactiveDismissDisabled(true) // Disables swipe-to-dismiss (force use of back button)\
                                .environmentObject(userSettingsViewModel)
                        }

                    }
                    ToolbarItem(placement: .navigationBarTrailing) {
                        HStack (spacing:3) {
                            Text(sunriseSunsetViewModel.sunriseSunset?.sunset ?? "")
                                .foregroundColor(sunFontColor)
                                .font(.caption)
                            Image(systemName: "sunset")
                                .foregroundColor(sunImageColor)
                                .imageScale(.medium)
                        }
                    }
                    // Navigation bar (bottom of screen)
                    ToolbarItemGroup(placement: .bottomBar) {
                        HStack {
                            Button {
                                selectedView = .site
                                siteViewActive = true
                                weatherViewActive = false
                                potentialViewActive = false
                                mapViewActive = false
                                webcamViewActive = false
                                linkViewActive = false
                            } label: {
                                VStack {
                                    Image(systemName: "cloud.sun")
                                        .foregroundColor(siteViewActive ? toolbarActiveImageColor : toolbarImageColor)
                                        .font(.system(size: toolbarItemSize))
                                        .frame(width: toolbarItemSize, height: toolbarItemSize)
                                    Text("Sites")
                                        .foregroundColor(siteViewActive ? toolbarActiveFontColor : toolbarFontColor)
                                        .font(.caption)
                                        .padding(.top, 4)
                                }
                            }
                            Spacer()
                            Button {
                                selectedView = .weather
                                siteViewActive = false
                                weatherViewActive = true
                                potentialViewActive = false
                                mapViewActive = false
                                webcamViewActive = false
                                linkViewActive = false
                            } label: {
                                VStack {
                                    Image(systemName: "cloud.sun")
                                        .foregroundColor(weatherViewActive ? toolbarActiveImageColor : toolbarImageColor)
                                        .font(.system(size: toolbarItemSize))
                                        .frame(width: toolbarItemSize, height: toolbarItemSize)
                                    Text("Weather")
                                        .foregroundColor(weatherViewActive ? toolbarActiveFontColor : toolbarFontColor)
                                        .font(.caption)
                                        .padding(.top, 4)
                                }
                            }
                            Spacer()
                            Button {
                                selectedView = .potential
                                siteViewActive = false
                                weatherViewActive = false
                                potentialViewActive = true
                                mapViewActive = false
                                webcamViewActive = false
                                linkViewActive = false
                            } label: {
                                VStack {
                                    Image("PGIconSystemImage")
                                        .renderingMode(.template)
                                        .resizable()
                                        .scaledToFit()
                                        // Customizing frame dimensions as it seems dependent on original image size
                                        .frame(width: toolbarItemSize * 1.6, height: toolbarItemSize * 1.6)                                        //.offset(y: 1) // Adjust height relative to other toolbar icons
                                        .foregroundColor(potentialViewActive ? toolbarActiveImageColor : toolbarImageColor)
                                    Text("Potential")
                                        .foregroundColor(potentialViewActive ? toolbarActiveFontColor : toolbarFontColor)
                                        .font(.caption)
                                        .padding(.top, 0)
                                }
                            }
                            Spacer()
                            Button {
                                selectedView = .map
                                siteViewActive = false
                                weatherViewActive = false
                                potentialViewActive = false
                                mapViewActive = true
                                webcamViewActive = false
                                linkViewActive = false
                            } label: {
                                VStack {
                                    Image(systemName: "map")
                                        .foregroundColor(mapViewActive ? toolbarActiveImageColor : toolbarImageColor)
                                        .font(.system(size: toolbarItemSize))
                                        .frame(width: toolbarItemSize, height: toolbarItemSize)
                                    Text("Map")
                                        .foregroundColor(mapViewActive ? toolbarActiveFontColor : toolbarFontColor)
                                        .font(.caption)
                                        .padding(.top, 4)
                                }
                            }
                            Spacer()
                            Button {
                                selectedView = .webcam
                                siteViewActive = false
                                weatherViewActive = false
                                potentialViewActive = false
                                mapViewActive = false
                                webcamViewActive = true
                                linkViewActive = false
                            } label: {
                                VStack {
                                    Image(systemName: "photo")
                                        .foregroundColor(webcamViewActive ? toolbarActiveImageColor : toolbarImageColor)
                                        .font(.system(size: toolbarItemSize))
                                        .frame(width: toolbarItemSize, height: toolbarItemSize)
                                    Text("Cams")
                                        .foregroundColor(webcamViewActive ? toolbarActiveFontColor : toolbarFontColor)
                                        .font(.caption)
                                        .padding(.top, 4)
                                }
                            }
                            Spacer()
                        }
                    }
                }
                // Separator bar below title bar
                VStack {
                    Rectangle()
                        .fill(titlebarSeparatorColor)
                        .frame(height: 1)
                    Spacer()
                }
            }
        }
    }
}
import SwiftUI
import Combine
import Foundation

struct LinkView: View {
    @StateObject private var linkViewModel = LinkViewModel()
    @EnvironmentObject var userSettingsViewModel: UserSettingsViewModel
    @Environment(\.presentationMode) var presentationMode
    @Environment(\.openURL) var openURL     // Used to open URL links as an in-app sheet using Safari
    @State private var externalURL: URL?    // Used to open URL links as an in-app sheet using Safari
    @State private var showWebView = false  // Used to open URL links as an in-app sheet using Safari

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                        Spacer()
                        Text("Links")
                            .foregroundColor(sectionHeaderColor)
                            .bold()
                    }
                }
                .padding()
                Spacer()
            }
            .background(toolbarBackgroundColor)
        }

        Group {
            if linkViewModel.isLoading {
                loadingView
            } else if linkViewModel.sortedGroupedLinks().isEmpty {
                emptyView
            } else {
                contentView
            }
        }
        .onAppear {
            linkViewModel.fetchLinks()
        }
        .sheet(isPresented: $showWebView) {
            if let url = externalURL { SafariView(url: url) }
        }
    }

    private var loadingView: some View {
        VStack {
            Spacer()
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
            Spacer()
        }
    }

    private var emptyView: some View {
        VStack {
            Spacer()
            Text("No links available")
                .font(.subheadline)
                .foregroundColor(.gray)
                .padding()
            Spacer()
        }
    }

    private var contentView: some View {
        
        List {
            ForEach(linkViewModel.sortedGroupedLinks(), id: \.0) { category, items in
                Section(header:
                    Text(category)
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                        .bold()
                ) {
                    ForEach(items) { item in
                        Button(action: {
                            if let url = URL(string: item.link) {
                                externalURL = url
                                showWebView = true
                            }
                        }) {
                            VStack(alignment: .leading) {
                                Text(item.title)
                                    .font(.subheadline)
                                    .foregroundColor(rowHeaderColor)
                                Text(item.description)
                                    .font(.footnote)
                                    .foregroundColor(rowTextColor)
                            }
                            .padding(.vertical, 2)
                        }
                    }
                }
            }
        }
    }

    // Open URL in in-app Safari view
    func openLink(_ url: URL) {
        externalURL = url
        showWebView = true
    }
}
import SwiftUI
import Combine
import Foundation

struct FlySkyHyDataView: View {
    @Environment(\.presentationMode) var presentationMode
    @Environment(\.openURL) var openURL     // Used to open URL links as an in-app sheet using Safari
    @State private var externalURL: URL?    // Used to open URL links as an in-app sheet using Safari
    @State private var showWebView = false  // Used to open URL links as an in-app sheet using Safari

    var body: some View {
        
        let stepSpacing: CGFloat = 3
        
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                        Spacer()
                        Text("FlySkyHy custom data")
                            .foregroundColor(sectionHeaderColor)
                            .bold()
                    }
                }
                .padding()
                Spacer()
            }
            .background(toolbarBackgroundColor)
        }
        
        List {
            Section(header:
                        Text("Custom data contents")
                .font(.subheadline)
                .foregroundColor(sectionHeaderColor)
                .bold()
            ) {
                VStack(alignment: .leading) {
                    Text("Utah")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("Various LZs, thermal hot spots")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                VStack(alignment: .leading) {
                    Text("Oregon")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("Various LZs / No Land areas")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                VStack(alignment: .leading) {
                    Text("Colorado")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("LZs, No Land areas, seasonal closures")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                VStack(alignment: .leading) {
                    Text("California - Santa Barbara")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("No Land areas")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                VStack(alignment: .leading) {
                    Text("Washington - Chelan")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("LZs, thermal hot spots")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                VStack(alignment: .leading) {
                    Text("Mexico - Valle de Bravo")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                    Text("Thermal hot spots, airspaces")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                }
                .padding(.vertical, 2)
            }
            
            Section(header:
                        Text("Setup instructions")
                .font(.subheadline)
                .foregroundColor(sectionHeaderColor)
                .bold()
            ) {
                VStack(alignment: .leading) {
                    Text("Installation Steps")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                        .padding(.bottom, stepSpacing)
                    Text("1. Tap here to open file:")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Button(action: {
                        let baseURL = AppURLManager.shared.getAppURL(URLName: "flyskyhyCustomAirspaceLink") ?? "<Unknown FlySkyHy data URL>"
                        if let url = URL(string: baseURL) {
                            externalURL = url
                            showWebView = true
                        }
                    }) {
                        Text("     FlySkyHy custom data file")
                            .font(.subheadline)
                            .bold()
                            .underline()
                            .foregroundColor(rowHeaderColor)
                            .padding(.bottom, stepSpacing)
                    }
                    Text("2. Tap the download icon (and if Google drive is installed, select 'Open' and then 'Download' again")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("3. Select 'Open in FlySkyHy'")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("4. FlySkyHy will open and ask to import airspaces - tap 'OK'")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)

                }
                
                VStack(alignment: .leading) {
                    Text("FlySkyHy Configuration Steps")
                        .font(.subheadline)
                        .foregroundColor(rowHeaderColor)
                        .padding(.bottom, stepSpacing)
                    Text("1. Tap on Settings in FlySkyHy")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("2. Tap on Airspace under Settings (not under Extensions)")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("2. Tap on Airspace sources and set to 'Both'")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("3. Tap on Airspace classes and set to:")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                    Text("  W - Green (LZs)")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                    Text("  R - Red (No land areas)")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                    Text("  SRZ - Yellow (seasonal raptor closures)")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                    Text("  AWY - Med Orange (high % thermal hot spot)")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                    Text("  TMZ - Light Orange (med % thermal hot spot)")
                        .font(.subheadline)
                        .foregroundColor(infoFontColor)
                        .padding(.bottom, stepSpacing)
                    Text("4. Turn off alerts, warnings, alarms, and warnings for each of these airspaces")
                        .font(.subheadline)
                        .foregroundColor(rowTextColor)
                        .padding(.bottom, stepSpacing)
                }
                .padding(.vertical, 2)
            }
        }
        .sheet(isPresented: $showWebView) {
            if let url = externalURL { SafariView(url: url) }
        }
    }

    // Open URL in in-app Safari view
    func openLink(_ url: URL) {
        externalURL = url
        showWebView = true
    }
}
import SwiftUI
import MapKit
import Foundation
import CoreLocation

struct DevSiteCoordView: View {
    @EnvironmentObject var siteViewModel: SiteViewModel
    @State private var selectedSite: Site?
    @State private var showMapSheet = false
    @State private var coordinateRegion: MKCoordinateRegion = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: 0.0, longitude: 0.0),
        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
    )

    var body: some View {
        NavigationView {
            List(siteViewModel.sites) { site in
                Button(action: {
                    let latitude = Double(site.siteLat) ?? 0.0
                    let longitude = Double(site.siteLon) ?? 0.0

                    selectedSite = site // Set site first
                    coordinateRegion = MKCoordinateRegion(
                        center: CLLocationCoordinate2D(latitude: latitude, longitude: longitude),
                        span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05)
                    )
                }) {
                    Text(site.siteName)
                        .font(.subheadline)
                        .foregroundColor(sectionHeaderColor)
                }
            }
            .onChange(of: selectedSite) {
                showMapSheet = true
            }
            .sheet(isPresented: $showMapSheet) {
                if let selectedSite = selectedSite {
                    SiteMapView(site: selectedSite, coordinateRegion: $coordinateRegion)
                        .interactiveDismissDisabled(true) // ← disables swipe-to-dismiss
                } else {
                    Text("No selected site found")
                }
            }
        }
    }
}

struct IdentifiableCoordinate: Identifiable {
    let id = UUID()
    let coordinate: CLLocationCoordinate2D
}

struct SiteCoordMapViewRepresentable: UIViewRepresentable {
    @Binding var coordinateRegion: MKCoordinateRegion
    @Binding var markerCoordinate: CLLocationCoordinate2D?

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    func makeUIView(context: Context) -> MKMapView {
        let mapView = MKMapView()
        mapView.mapType = .hybrid
        mapView.delegate = context.coordinator

        let tapGesture = UITapGestureRecognizer(target: context.coordinator, action: #selector(context.coordinator.handleMapTap))
        mapView.addGestureRecognizer(tapGesture)

        return mapView
    }

    func updateUIView(_ uiView: MKMapView, context: Context) {
        uiView.setRegion(coordinateRegion, animated: true)

        // Remove existing annotations before adding a new one
        uiView.removeAnnotations(uiView.annotations)

        if let markerCoordinate = markerCoordinate {
            let annotation = MKPointAnnotation()
            annotation.coordinate = markerCoordinate
            uiView.addAnnotation(annotation)
        }        
    }

    class Coordinator: NSObject, MKMapViewDelegate {
        var parent: SiteCoordMapViewRepresentable

        init(parent: SiteCoordMapViewRepresentable) {
            self.parent = parent
        }

        @objc func handleMapTap(sender: UITapGestureRecognizer) {
            let mapView = sender.view as! MKMapView
            let touchPoint = sender.location(in: mapView)
            let coordinate = mapView.convert(touchPoint, toCoordinateFrom: mapView)

            DispatchQueue.main.async {
                self.parent.markerCoordinate = coordinate // Update tapped marker
                self.parent.coordinateRegion.center = coordinate // Center map on new marker
            }
        }
    }
}

struct SiteMapView: View {
    var site: Site
    @Binding var coordinateRegion: MKCoordinateRegion
    @State private var markerCoordinate: CLLocationCoordinate2D?
    @EnvironmentObject var siteViewModel: SiteViewModel
    @Environment(\.presentationMode) var presentationMode

    init(site: Site, coordinateRegion: Binding<MKCoordinateRegion>) {
        self.site = site
        _coordinateRegion = coordinateRegion
        _markerCoordinate = State(initialValue: coordinateRegion.wrappedValue.center) // Initialize marker at center
    }

    var body: some View {
        VStack(alignment: .leading) {
            HStack {
                Button(action: {
                    presentationMode.wrappedValue.dismiss()
                }) {
                    HStack {
                        Image(systemName: "chevron.left")
                            .foregroundColor(toolbarActiveImageColor)
                        Text("Back")
                            .foregroundColor(toolbarActiveFontColor)
                        Spacer()
                        Text(site.siteName)
                            .foregroundColor(sectionHeaderColor)
                            .bold()
                    }
                }
                .padding()
                Spacer()
            }
            .background(toolbarBackgroundColor)
            SiteCoordMapViewRepresentable(coordinateRegion: $coordinateRegion, markerCoordinate: $markerCoordinate)
            
            // Commented out...need to implement Google client app authorization to call update APIs
            /*            Button("Update Coordinates") {
             if let newCoordinate = markerCoordinate {
             updateSiteCoordinates(siteName: site.siteName, sheetRow: site.sheetRow, newCoordinate: newCoordinate)
             presentationMode.wrappedValue.dismiss()
             }
             }
             */
            // In the mean time, simply displaying values to cut and paste.
            
            // Display latitude and longitude as buttons
            if let markerCoordinate = markerCoordinate {
                HStack {
                    Button(action: {
                        UIPasteboard.general.string = String(format: "%.5f", markerCoordinate.latitude)
                    }) {
                        Text("Lat: \(String(format: "%.5f", markerCoordinate.latitude))")
                    }
                    .padding()
                    .background(skewTButtonBackgroundColor)
                    .foregroundColor(skewTButtonTextColor)
                    .cornerRadius(8)
                    
                    Button(action: {
                        UIPasteboard.general.string = String(format: "%.5f", markerCoordinate.longitude)
                    }) {
                        Text("Lon: \(String(format: "%.5f", markerCoordinate.longitude))")
                    }
                    .padding()
                    .background(skewTButtonBackgroundColor)
                    .foregroundColor(skewTButtonTextColor)
                    .cornerRadius(8)
                }
                .padding()
            }
        }
    }
            
    func updateSiteCoordinates(siteName: String,
                               sheetRow: Int,
                               newCoordinate: CLLocationCoordinate2D) {
        // Build range to specify row and columns to be updated
        let rangeName = "Sites!R\(sheetRow)C11:R\(sheetRow)C12"
        let regionSheetID = AppRegionManager.shared.getRegionGoogleSheet() ?? ""
        let url = URL(string: "https://sheets.googleapis.com/v4/spreadsheets/\(regionSheetID)/values/\(rangeName)?alt=json&key=\(googleAPIKey)")!

        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")

        let body: [String: Any] = [
            "range": rangeName,
            "majorDimension": "ROWS",
            "values": [
                ["\(newCoordinate.latitude)", "\(newCoordinate.longitude)"]
            ]
        ]

        request.httpBody = try? JSONSerialization.data(withJSONObject: body, options: [])

        URLSession.shared.dataTask(with: request) { data, response, error in
            if let error = error {
                print("Error updating coordinates: \(error.localizedDescription)")
                return
            }
            print("Coordinates updated successfully.")
        }.resume()
    }
}
